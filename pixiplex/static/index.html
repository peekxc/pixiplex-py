<!DOCTYPE html><head><meta charset="utf-8"><title>d3 webGL force graph with PIXI.js</title><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="description" content=""><meta name="theme-color" content="#000000"></head><body><button id="center_button" type="button">Center</button><div> <button id="enable_force_button" type="button">Enable force</button><button id="disable_force_button" type="button">Disable forces</button></div><div> <button id="enable_drag_button" type="button">Enable drag</button><button id="disable_drag_button" type="button">Disable drag</button></div><div> <button id="change_node_color_button" type="button">Change node color</button><button id="change_node_colors_button" type="button">Change node colors</button><button id="change_node_radius_button" type="button">Change node radius</button><button id="change_node_size" type="button">Change node size</button><button id="change_link_width" type="button">Change link width</button><button id="change_link_color" type="button">Change link color</button></div><div> <button id="insert_node_button" type="button">Insert node</button><button id="remove_node_button" type="button">Remove node</button><button id="insert_link_button" type="button">Insert link</button><button id="remove_link_button" type="button">Remove link</button><button id="insert_polygon_button" type="button">Insert polygon</button><button id="remove_polygon_button" type="button">Remove polygon</button><button id="add_text" type="button">Add node text </button></div><div> <button id="lasso_button" type="button">Do Lasso</button><button id="enable_weak_tree" type="button">Enable weak tree</button></div><div id="pixir_container" style="position: relative; overflow: hidden; overflow-y: hidden; padding: 0; margin: 0; width: 1200px; height: 800px;"></div></body><script src="https://d3js.org/d3-fetch.v1.min.js"></script><script src="https://d3js.org/d3-color.v1.min.js"></script><script src="https://d3js.org/d3-interpolate.v1.min.js"></script><script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.core.js"></script><script type="module">import * as pn from "./pixinet.js"
console.log(pn)
console.log("Pixel ratio: " + devicePixelRatio)

// Setup bordered container to house the canvas for debugging
const pn_cont = pn.select("#pixir_container").attr('display', 'inline');
var pixir_container = document.getElementById("pixir_container")
const width = pixir_container.clientWidth;
const height = pixir_container.clientHeight;
pixir_container.style.border = '1px solid black';
pixir_container.style.margin = '5px';

// Construct the instance 
const pp = new pn.Pixiplex(width, height);

// Initializations
await pp.initialize_application()
pp.initialize_viewport();
pp.init_ticker();
document.getElementById("pixir_container").appendChild(pp.view);

// Enable dynamic resizing
//- const resize = pn.enable_resize(pp.app, pp.vp);
//- window.addEventListener('resize', resize); 	// Listen for window resize events
//- resize();

// Loads the graph, initializes the graphics (+ nodes w/ random coordinates)
await pp.initialize_graph("data/les_miserables.json");

// Add the graphics into the viewport; note viewport *is* a container
pn.add_items(pp.vp, [pp.links_gfx]); // add links to stage
pn.add_items(pp.vp, pp.nodes_gfx);   // add nodes to stage

// 
pp.ticker.add((ticker) => {
	pn.update_links(pp.links, pp.links_gfx);
});

// Finally, add the viewport itself to the stage 
pp.app.stage.addChild(pp.vp)

// Start the animation
console.log("beginning ticker");
pp.ticker.start();

console.log("pixiplex: ")
console.log(pp);


// pn.register_tick_stops(ticker, vp);

// The default drawing method to update on each tick. Draw polygons, then links. Nodes are automatically updated.
//- const default_draw = () => {
//- 	//- if (polygons) { pn.draw_polygons(polygons); }
//- 	if (links) { links_gfx.clear(); pn.draw_links(links, links_gfx); }
//- 	//- if (sim){ sim.tick(); }
//- }

//- d3.json("data/les_miserables.json").then(function(graph) {

//- 	// Show the graph 
//- 	console.log(graph)

//- 	// Generate link graphics first?
//- 	links_gfx = pn.generate_links_graphic();
//- 	links = graph.links; 
//- 	console.log(links_gfx);

//- 	// Create node graphics, then stage them
//- 	pn.scale_nodes(graph.nodes, width, height); // this must happen before the node graphics are generated
//- 	nodes_gfx = pn.generate_node_graphics(graph.nodes);
//- 	console.log(nodes_gfx)


//- 	// Assign actual source and target node references
//- 	pn.resolve_links(nodes_gfx, links);
//- 	//- pn.resolve_links_index(nodes_gfx, links);
//- 	console.log("links: ")
//- 	console.log(links)
//- 	pn.draw_links(links, links_gfx);

//- 	// Add the graphics to the viewport
//- 	pn.stage_items(pp.vp, [links_gfx]); // add links to stage
//- 	pn.stage_items(pp.vp, nodes_gfx);  // add nodes to stage


	//- const N_LINES = links.length;
	//- const SOURCE_IDS = new Int32Array(links.map((link) => { return link.source }));
	//- const TARGET_IDS = new Int32Array(links.map((link) => { return link.target }));
	//- console.log(SOURCE_IDS);
	//- ticker.add((ticker) =>{
		//- console.log("drawing edges");
		//- default_draw();
		//- links_gfx.clear(); 
		// Somehow this is really what causes the CPU spike, unknown how to fix
		//- for (let i = 0; i < N_LINES; i++){
		//- 	//- links_gfx
		//- 	//- 	.moveTo(nodes_gfx[links[i].source].x, nodes_gfx[links[i].source].y)
		//- 	//- 	.lineTo(nodes_gfx[links[i].target].x, nodes_gfx[links[i].target].y)	
		//- 	links_gfx
		//- 		.moveTo(nodes_gfx[SOURCE_IDS[i]].x, nodes_gfx[SOURCE_IDS[i]].y)
		//- 		.lineTo(nodes_gfx[TARGET_IDS[i]].x, nodes_gfx[TARGET_IDS[i]].y)	
		//- }
		//- links.forEach((link) => {
		//- 	const { source, target } = link;
		//- 	links_gfx
		//- 		.moveTo(source.x, source.y)
		//- 		.lineTo(target.x, target.y)	
		//- 		//- .stroke({ width: 1, color: 0x000000 });
		//- });
		//- links_gfx.stroke({ width: 1, color: 0x000000 });
		//- links_gfx.save()

		//- links_gfx.clear(); 
		//- pn.draw_links(links, links_gfx);
		
		//- let new_ls = merge(line_style, ls);
		//- link_gfx.clear();
		//- const { source, target } = link;
		//- link_gfx
		//- 	.moveTo(source.x, source.y)
		//- 	.lineTo(target.x, target.y)
		//- 	.stroke({ width: ls.lineWidth, color: ls.color });
		//- return(link)
	//- });

	// Initiate the animation
	//- dispatcher.on('tick', default_draw);
	//- app.stage.cacheAsTexture(true);

	//- ticker.start();
	//- ticker.call('animate'); // start 
//- });


document.getElementById("enable_force_button").addEventListener("click", function(){

	pp.enable_force();

	// Create the force simulation 
	//- sim = pn.force_sim();
	//- sim_params = pn.default_force_settings();
	//- pn.default_force_settings(sim, app, nodes_gfx, links);

	//- // Add force dragging emitter callbacks
	//- nodes_gfx.forEach((node) => {
	//- 	pn.compose(pn.pixi_drag(node), pn.force_drag(sim))(pn.drag_dispatcher(node));
	//- });
	//- sim.stop();
	//- sim.alpha(1); // no restart needed
	
	// Add d3-force steps to the PIXI ticker 
	//- ticker.add((ticker) => {
	//- 	sim.tick();
	//- })
	//- dispatcher.on("tick", function(){ sim.tick(); })
});

document.getElementById("center_button").addEventListener("click", function(){
	//- pp.vp.moveCenter(pp.width/2, pp.height/2);
	pp.center_viewport();
	//- console.log(nodes);
});

document.getElementById("disable_force_button").addEventListener("click", function(){
	pp.disable_force();
	//- console.log(ticker)
});

document.getElementById("enable_drag_button").addEventListener("click", function(){
	console.log("enabling drag")
	pp.enable_drag();
	//- console.log(ticker)
});
document.getElementById("disable_drag_button").addEventListener("click", function(){
	console.log("disabling drag")
	pp.disable_drag();
});

//- // Start lasso on double-click 
//- let lasso_obj = pn.enable_lasso("pixir_container");
//- lasso_obj.on("selected", function(nodes){
//- 		// Highlight selected nodes 
//- 		//- if (nodes) { 
//- 		//- 	pn.draw_nodes(nodes, { color: 0xFFA500 });
			
//- 		//- 	let node_container = pn.group_items(nodes);
//- 		//- 	pn.stage_items(vp, [node_container]);
//- 		//- 	let node_group = pn.enable_drag_container(node_container);
//- 		//- 	console.log(node_group);
//- 		//- 	pn.enable_drag(node_group).on("dragging", function(coords){
//- 		//- 		console.log(this);
//- 		//- 		this.x = coords.x; this.y = coords.y; 
//- 		//- 		this.updateTransform();
//- 		//- 	});

//- 		//- 	//pn.enable_drag(node_group)
//- 		//- };
//- 		// Drag -- or -- do something else w/ selected nodes 
//- 		// unhighlight nodes when finished  
//- });


//- document.getElementById("lasso_button").addEventListener("click", function(){
//- 	console.log("lasso clicked")
//- 	console.log(lasso_obj);
//- 	console.log(nodes);
//- 	lasso_obj.call("start", this, nodes);
//- 	// var interact_svg = pn.enable_lasso("pixir_container");
//- 	// var selected_nodes = pn.start_lasso(nodes, interact_svg);
//- });

//- document.getElementById("insert_node_button").addEventListener("click", function(){
//- 	console.log("inserting new node");
//- 	let new_nodes = [{id: "new_node", group: 5, x: 0.5, y: 0.5}]; 
//- 	let ins_nodes = pn.differenceBy(new_nodes, nodes, 'id');
//- 	ins_nodes = pn.generate_node_graphics(pn.scale_nodes(ins_nodes, width, height));
//- 	ins_nodes.forEach((node) => {
//- 		pn.compose(
//- 			pn.pixi_drag(node), 
//- 			sim ? pn.force_drag(sim) : pn.identity,
//- 			((typeof HTMLWidgets !== 'undefined') && HTMLWidgets.shinyMode) ? pn.shiny_drag(Shiny) : pn.identity
//- 		)(pn.drag_dispatcher(node));
//- 	});
//- 	pn.stage_items(vp, ins_nodes);
//- 	nodes = pn.concat(nodes, ins_nodes);
//- 	if (sim){ sim.nodes(nodes); }
//- });
//- document.getElementById("remove_node_button").addEventListener("click", function(){
//- 	console.log("remove new node");
//- 	let node_ids = [nodes[0].id, nodes[1].id]
//- 	pn.remove_nodes(node_ids, nodes, links, vp);

//- 	// Update simulation after any removal or addition
//- 	if (sim){ 
//- 		sim.nodes(nodes); 
//- 		if (sim.force('link')){	sim.force('link').links(links); }
//- 	}
//- });
//- document.getElementById("insert_link_button").addEventListener("click", function(){
//- 	let new_links = [{ source: "Labarre", target: "Mabeuf" }];
//- 	pn.resolve_links(nodes, new_links); // attach source + target
//- 	links = pn.concat(links, new_links);
//- 	if (sim && sim.force('link')){ sim.force('link').links(links); }
//- });
//- document.getElementById("remove_link_button").addEventListener("click", function(){
//- 	let links_to_remove = [{ source: "Labarre", target: "Mabeuf" }];
//- 	// This probably has to be O(n^2) without further sorting 
//- 	pn.remove(links, (link) => {
//- 		let tmp = links_to_remove.find((o) => { return link.source.id == o.source && link.target.id == o.target });
//- 		return (typeof tmp !== 'undefined')
//- 	});
//- 	if (sim && sim.force('link')){ sim.force('link').links(links); }
//- });
//- document.getElementById("insert_polygon_button").addEventListener("click", function(){
//- 	console.log("Inserting polygon");
//- 	let cpoly = new Polygon();
//- 	cpoly.gfx = new Graphics();
//- 	cpoly.nodes = [nodes[0], nodes[1], nodes[2]];
//- 	console.log(cpoly);

//- 	// Add to stage, update on ticker
//- 	pn.stage_items(vp, [cpoly.gfx]);
//- 	if (!polygons){ polygons = []; }
//- 	polygons.push(cpoly);
//- });

//- document.getElementById("remove_polygon_button").addEventListener("click", function(){
//- });

//- document.getElementById("change_node_color_button").addEventListener("click", function(){
//- 	let new_node_style = { color: 65280, radius: 8 };
//- 	let node_subset = pn.filter(nodes, (node) => { return node.id == 0 });
//- 	console.log(node_subset);
//- 	console.log(new_node_style);
//- 	pn.draw_nodes(node_subset, [new_node_style]);
//- });
//- document.getElementById("change_node_colors_button").addEventListener("click", function(){
//- 	const rgb_to_hex = (col) => {
//- 		return parseInt(d3.color(col).hex().substring(1), 16)
//- 	}
//- 	let node_colors = [];
//- 	nodes.forEach((node, i) => { 
//- 		node_colors.push({ color: rgb_to_hex(d3.interpolateSpectral(i/nodes.length)) });
//- 	});
//- 	console.log(node_colors)
//- 	// pn.draw_nodes(nodes, node_colors);
//- 	// pn.draw_nodes(nodes, { color: node_colors[0].color });
//- 	pn.draw_nodes(nodes, node_colors);
//- });
//- document.getElementById("change_node_radius_button").addEventListener("click", function(){
//- 	pn.draw_nodes(nodes, { radius: 2 });
//- });
//- document.getElementById("change_link_width").addEventListener("click", function(){
//- 	pn.draw_links(links, links_gfx, { lineWidth: 5 })
//- });
//- document.getElementById("change_link_color").addEventListener("click", function(){
//- 	console.log("Changing link color");
//- 	pn.draw_links(links, links_gfx, { color: 0xff0000 })
//- });

document.getElementById("enable_weak_tree").addEventListener("click", function(){
	pp.dispatcher.on("tick", function(e){
		//- links_gfx.clear();
		//- pn.draw_links(links, links_gfx);	

		// Form weak tree by push targets downward
		let k = 10 * pp.sim.alpha();
		pp.links.forEach((link) => { 
			link.source.y -= k;
			link.target.y += k;  
		});
		sim.tick();
	});
});

//- document.getElementById("add_text").addEventListener("click", function(){
//- 	nodes.forEach((node) => {
//- 		let text = new Text('Text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});
//- 		node.addChild(text);
//- 		//- text.position.x = function() { return node.x }
//- 		//- text.position.y = function() { return node.y }
//- 		//- vp.addChild(text);
//- 	});
//- 	console.log(nodes[0]);

//- });

	// Add the viewport as a child of a container itself
//- let cn = new pn.Container();
//- cn.addChild(pp.vp);
//- //- cn.cacheAsTexture();
//- //- cn.enableRenderGroup();
//- //- cn.cacheAsTexture = true; 
//- pn.add_items(pp.app.stage, [cn])</script>