var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/pixi.js/lib/extensions/Extensions.mjs
var ExtensionType, normalizeExtension, normalizeExtensionPriority, extensions;
var init_Extensions = __esm({
  "node_modules/pixi.js/lib/extensions/Extensions.mjs"() {
    "use strict";
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2["Application"] = "application";
      ExtensionType2["WebGLPipes"] = "webgl-pipes";
      ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
      ExtensionType2["WebGLSystem"] = "webgl-system";
      ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
      ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
      ExtensionType2["WebGPUSystem"] = "webgpu-system";
      ExtensionType2["CanvasSystem"] = "canvas-system";
      ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
      ExtensionType2["CanvasPipes"] = "canvas-pipes";
      ExtensionType2["Asset"] = "asset";
      ExtensionType2["LoadParser"] = "load-parser";
      ExtensionType2["ResolveParser"] = "resolve-parser";
      ExtensionType2["CacheParser"] = "cache-parser";
      ExtensionType2["DetectionParser"] = "detection-parser";
      ExtensionType2["MaskEffect"] = "mask-effect";
      ExtensionType2["BlendMode"] = "blend-mode";
      ExtensionType2["TextureSource"] = "texture-source";
      ExtensionType2["Environment"] = "environment";
      ExtensionType2["ShapeBuilder"] = "shape-builder";
      return ExtensionType2;
    })(ExtensionType || {});
    normalizeExtension = (ext) => {
      if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
        if (!ext.extension) {
          throw new Error("Extension class must have an extension object");
        }
        const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
        ext = { ...metadata, ref: ext };
      }
      if (typeof ext === "object") {
        ext = { ...ext };
      } else {
        throw new Error("Invalid extension type");
      }
      if (typeof ext.type === "string") {
        ext.type = [ext.type];
      }
      return ext;
    };
    normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
    extensions = {
      /** @ignore */
      _addHandlers: {},
      /** @ignore */
      _removeHandlers: {},
      /** @ignore */
      _queue: {},
      /**
       * Remove extensions from PixiJS.
       * @param extensions - Extensions to be removed.
       * @returns {extensions} For chaining.
       */
      remove(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type2) => this._removeHandlers[type2]?.(ext));
        });
        return this;
      },
      /**
       * Register new extensions with PixiJS.
       * @param extensions - The spread of extensions to add to PixiJS.
       * @returns {extensions} For chaining.
       */
      add(...extensions2) {
        extensions2.map(normalizeExtension).forEach((ext) => {
          ext.type.forEach((type2) => {
            const handlers = this._addHandlers;
            const queue = this._queue;
            if (!handlers[type2]) {
              queue[type2] = queue[type2] || [];
              queue[type2]?.push(ext);
            } else {
              handlers[type2]?.(ext);
            }
          });
        });
        return this;
      },
      /**
       * Internal method to handle extensions by name.
       * @param type - The extension type.
       * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
       * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
       * @returns {extensions} For chaining.
       */
      handle(type2, onAdd2, onRemove2) {
        const addHandlers = this._addHandlers;
        const removeHandlers = this._removeHandlers;
        if (addHandlers[type2] || removeHandlers[type2]) {
          throw new Error(`Extension type ${type2} already has a handler`);
        }
        addHandlers[type2] = onAdd2;
        removeHandlers[type2] = onRemove2;
        const queue = this._queue;
        if (queue[type2]) {
          queue[type2]?.forEach((ext) => onAdd2(ext));
          delete queue[type2];
        }
        return this;
      },
      /**
       * Handle a type, but using a map by `name` property.
       * @param type - Type of extension to handle.
       * @param map - The object map of named extensions.
       * @returns {extensions} For chaining.
       */
      handleByMap(type2, map3) {
        return this.handle(
          type2,
          (extension) => {
            if (extension.name) {
              map3[extension.name] = extension.ref;
            }
          },
          (extension) => {
            if (extension.name) {
              delete map3[extension.name];
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions with a `name` property.
       * @param type - Type of extension to handle.
       * @param map - The array of named extensions.
       * @param defaultPriority - Fallback priority if none is defined.
       * @returns {extensions} For chaining.
       */
      handleByNamedList(type2, map3, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            const index2 = map3.findIndex((item) => item.name === extension.name);
            if (index2 >= 0)
              return;
            map3.push({ name: extension.name, value: extension.ref });
            map3.sort((a3, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a3.value, defaultPriority));
          },
          (extension) => {
            const index2 = map3.findIndex((item) => item.name === extension.name);
            if (index2 !== -1) {
              map3.splice(index2, 1);
            }
          }
        );
      },
      /**
       * Handle a type, but using a list of extensions.
       * @param type - Type of extension to handle.
       * @param list - The list of extensions.
       * @param defaultPriority - The default priority to use if none is specified.
       * @returns {extensions} For chaining.
       */
      handleByList(type2, list, defaultPriority = -1) {
        return this.handle(
          type2,
          (extension) => {
            if (list.includes(extension.ref)) {
              return;
            }
            list.push(extension.ref);
            list.sort((a3, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a3, defaultPriority));
          },
          (extension) => {
            const index2 = list.indexOf(extension.ref);
            if (index2 !== -1) {
              list.splice(index2, 1);
            }
          }
        );
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a22);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter2;
    }
  }
});

// node_modules/eventemitter3/index.mjs
var import_index, eventemitter3_default;
var init_eventemitter3 = __esm({
  "node_modules/eventemitter3/index.mjs"() {
    import_index = __toESM(require_eventemitter3(), 1);
    eventemitter3_default = import_index.default;
  }
});

// node_modules/@pixi/colord/index.mjs
var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
var init_colord = __esm({
  "node_modules/@pixi/colord/index.mjs"() {
    r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
    t = function(r2) {
      return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
    };
    n = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
    };
    e = function(r2, t2, n2) {
      return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
    };
    u = function(r2) {
      return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
    };
    a = function(r2) {
      return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
    };
    o = function(r2) {
      return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
    };
    i = /^#([0-9a-f]{3,8})$/i;
    s = function(r2) {
      var t2 = r2.toString(16);
      return t2.length < 2 ? "0" + t2 : t2;
    };
    h = function(r2) {
      var t2 = r2.r, n2 = r2.g, e3 = r2.b, u3 = r2.a, a3 = Math.max(t2, n2, e3), o2 = a3 - Math.min(t2, n2, e3), i2 = o2 ? a3 === t2 ? (n2 - e3) / o2 : a3 === n2 ? 2 + (e3 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
      return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a3 ? o2 / a3 * 100 : 0, v: a3 / 255 * 100, a: u3 };
    };
    b = function(r2) {
      var t2 = r2.h, n2 = r2.s, e3 = r2.v, u3 = r2.a;
      t2 = t2 / 360 * 6, n2 /= 100, e3 /= 100;
      var a3 = Math.floor(t2), o2 = e3 * (1 - n2), i2 = e3 * (1 - (t2 - a3) * n2), s2 = e3 * (1 - (1 - t2 + a3) * n2), h2 = a3 % 6;
      return { r: 255 * [e3, i2, o2, o2, s2, e3][h2], g: 255 * [s2, e3, e3, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e3, e3, i2][h2], a: u3 };
    };
    g = function(r2) {
      return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
    };
    d = function(r2) {
      return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
    };
    f = function(r2) {
      return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e3 = t2.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n2 / (e3 + n2) * 100 : 0, v: e3 + n2, a: t2.a }));
      var t2, n2, e3;
    };
    c = function(r2) {
      return { h: (t2 = h(r2)).h, s: (u3 = (200 - (n2 = t2.s)) * (e3 = t2.v) / 100) > 0 && u3 < 200 ? n2 * e3 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t2.a };
      var t2, n2, e3, u3;
    };
    l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
    y = { string: [[function(r2) {
      var t2 = i.exec(r2);
      return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
    }, "hex"], [function(r2) {
      var t2 = v.exec(r2) || m.exec(r2);
      return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
    }, "rgb"], [function(t2) {
      var n2 = l.exec(t2) || p.exec(t2);
      if (!n2) return null;
      var e3, u3, a3 = g({ h: (e3 = n2[1], u3 = n2[2], void 0 === u3 && (u3 = "deg"), Number(e3) * (r[u3] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
      return f(a3);
    }, "hsl"]], object: [[function(r2) {
      var n2 = r2.r, e3 = r2.g, u3 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
      return t(n2) && t(e3) && t(u3) ? a({ r: Number(n2), g: Number(e3), b: Number(u3), a: Number(i2) }) : null;
    }, "rgb"], [function(r2) {
      var n2 = r2.h, e3 = r2.s, u3 = r2.l, a3 = r2.a, o2 = void 0 === a3 ? 1 : a3;
      if (!t(n2) || !t(e3) || !t(u3)) return null;
      var i2 = g({ h: Number(n2), s: Number(e3), l: Number(u3), a: Number(o2) });
      return f(i2);
    }, "hsl"], [function(r2) {
      var n2 = r2.h, a3 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
      if (!t(n2) || !t(a3) || !t(o2)) return null;
      var h2 = function(r3) {
        return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
      }({ h: Number(n2), s: Number(a3), v: Number(o2), a: Number(s2) });
      return b(h2);
    }, "hsv"]] };
    N = function(r2, t2) {
      for (var n2 = 0; n2 < t2.length; n2++) {
        var e3 = t2[n2][0](r2);
        if (e3) return [e3, t2[n2][1]];
      }
      return [null, void 0];
    };
    x = function(r2) {
      return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
    };
    M = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
    };
    H = function(r2) {
      return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
    };
    $ = function(r2, t2) {
      var n2 = c(r2);
      return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
    };
    j = function() {
      function r2(r3) {
        this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
      }
      return r2.prototype.isValid = function() {
        return null !== this.parsed;
      }, r2.prototype.brightness = function() {
        return n(H(this.rgba), 2);
      }, r2.prototype.isDark = function() {
        return H(this.rgba) < 0.5;
      }, r2.prototype.isLight = function() {
        return H(this.rgba) >= 0.5;
      }, r2.prototype.toHex = function() {
        return r3 = o(this.rgba), t2 = r3.r, e3 = r3.g, u3 = r3.b, i2 = (a3 = r3.a) < 1 ? s(n(255 * a3)) : "", "#" + s(t2) + s(e3) + s(u3) + i2;
        var r3, t2, e3, u3, a3, i2;
      }, r2.prototype.toRgb = function() {
        return o(this.rgba);
      }, r2.prototype.toRgbString = function() {
        return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e3 = r3.b, (u3 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e3 + ", " + u3 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e3 + ")";
        var r3, t2, n2, e3, u3;
      }, r2.prototype.toHsl = function() {
        return d(c(this.rgba));
      }, r2.prototype.toHslString = function() {
        return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e3 = r3.l, (u3 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e3 + "%, " + u3 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e3 + "%)";
        var r3, t2, n2, e3, u3;
      }, r2.prototype.toHsv = function() {
        return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
        var r3;
      }, r2.prototype.invert = function() {
        return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
        var r3;
      }, r2.prototype.saturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
      }, r2.prototype.desaturate = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
      }, r2.prototype.grayscale = function() {
        return w(M(this.rgba, -1));
      }, r2.prototype.lighten = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
      }, r2.prototype.darken = function(r3) {
        return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
      }, r2.prototype.rotate = function(r3) {
        return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
      }, r2.prototype.alpha = function(r3) {
        return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
        var t2;
      }, r2.prototype.hue = function(r3) {
        var t2 = c(this.rgba);
        return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
      }, r2.prototype.isEqual = function(r3) {
        return this.toHex() === w(r3).toHex();
      }, r2;
    }();
    w = function(r2) {
      return r2 instanceof j ? r2 : new j(r2);
    };
    S = [];
    k = function(r2) {
      r2.forEach(function(r3) {
        S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
      });
    };
  }
});

// node_modules/@pixi/colord/plugins/names.mjs
function names_default(e3, f2) {
  var a3 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d3 in a3) r2[a3[d3]] = d3;
  var l2 = {};
  e3.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d4, i2, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c3 in a3) l2[c3] = new e3(a3[c3]).toRgb();
      for (var g2 in a3) {
        var u3 = (d4 = o2, i2 = l2[g2], Math.pow(d4.r - i2.r, 2) + Math.pow(d4.g - i2.g, 2) + Math.pow(d4.b - i2.b, 2));
        u3 < t2 && (t2 = u3, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d4 = "transparent" === r3 ? "#0000" : a3[r3];
    return d4 ? new e3(d4).toRgb() : null;
  }, "name"]);
}
var init_names = __esm({
  "node_modules/@pixi/colord/plugins/names.mjs"() {
  }
});

// node_modules/pixi.js/lib/color/Color.mjs
var _Color, Color;
var init_Color = __esm({
  "node_modules/pixi.js/lib/color/Color.mjs"() {
    init_colord();
    init_names();
    k([names_default]);
    _Color = class _Color2 {
      /**
       * @param {ColorSource} value - Optional value to use, if not provided, white is used.
       */
      constructor(value = 16777215) {
        this._value = null;
        this._components = new Float32Array(4);
        this._components.fill(1);
        this._int = 16777215;
        this.value = value;
      }
      /** Get red component (0 - 1) */
      get red() {
        return this._components[0];
      }
      /** Get green component (0 - 1) */
      get green() {
        return this._components[1];
      }
      /** Get blue component (0 - 1) */
      get blue() {
        return this._components[2];
      }
      /** Get alpha component (0 - 1) */
      get alpha() {
        return this._components[3];
      }
      /**
       * Set the value, suitable for chaining
       * @param value
       * @see Color.value
       */
      setValue(value) {
        this.value = value;
        return this;
      }
      /**
       * The current color source.
       *
       * When setting:
       * - Setting to an instance of `Color` will copy its color source and components.
       * - Otherwise, `Color` will try to normalize the color source and set the components.
       *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.
       *
       * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter
       * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.
       *
       * When getting:
       * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},
       *   {@link Color.premultiply premultiply} or {@link Color.round round}).
       * - Otherwise, the color source used when setting is returned.
       */
      set value(value) {
        if (value instanceof _Color2) {
          this._value = this._cloneSource(value._value);
          this._int = value._int;
          this._components.set(value._components);
        } else if (value === null) {
          throw new Error("Cannot set Color#value to null");
        } else if (this._value === null || !this._isSourceEqual(this._value, value)) {
          this._normalize(value);
          this._value = this._cloneSource(value);
        }
      }
      get value() {
        return this._value;
      }
      /**
       * Copy a color source internally.
       * @param value - Color source
       */
      _cloneSource(value) {
        if (typeof value === "string" || typeof value === "number" || value instanceof Number || value === null) {
          return value;
        } else if (Array.isArray(value) || ArrayBuffer.isView(value)) {
          return value.slice(0);
        } else if (typeof value === "object" && value !== null) {
          return { ...value };
        }
        return value;
      }
      /**
       * Equality check for color sources.
       * @param value1 - First color source
       * @param value2 - Second color source
       * @returns `true` if the color sources are equal, `false` otherwise.
       */
      _isSourceEqual(value1, value2) {
        const type1 = typeof value1;
        const type2 = typeof value2;
        if (type1 !== type2) {
          return false;
        } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
          return value1 === value2;
        } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
          if (value1.length !== value2.length) {
            return false;
          }
          return value1.every((v3, i2) => v3 === value2[i2]);
        } else if (value1 !== null && value2 !== null) {
          const keys1 = Object.keys(value1);
          const keys2 = Object.keys(value2);
          if (keys1.length !== keys2.length) {
            return false;
          }
          return keys1.every((key) => value1[key] === value2[key]);
        }
        return value1 === value2;
      }
      /**
       * Convert to a RGBA color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }
       */
      toRgba() {
        const [r2, g2, b2, a3] = this._components;
        return { r: r2, g: g2, b: b2, a: a3 };
      }
      /**
       * Convert to a RGB color object.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }
       */
      toRgb() {
        const [r2, g2, b2] = this._components;
        return { r: r2, g: g2, b: b2 };
      }
      /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */
      toRgbaString() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return `rgba(${r2},${g2},${b2},${this.alpha})`;
      }
      toUint8RgbArray(out2) {
        const [r2, g2, b2] = this._components;
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 = out2 || this._arrayRgb;
        out2[0] = Math.round(r2 * 255);
        out2[1] = Math.round(g2 * 255);
        out2[2] = Math.round(b2 * 255);
        return out2;
      }
      toArray(out2) {
        if (!this._arrayRgba) {
          this._arrayRgba = [];
        }
        out2 = out2 || this._arrayRgba;
        const [r2, g2, b2, a3] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        out2[3] = a3;
        return out2;
      }
      toRgbArray(out2) {
        if (!this._arrayRgb) {
          this._arrayRgb = [];
        }
        out2 = out2 || this._arrayRgb;
        const [r2, g2, b2] = this._components;
        out2[0] = r2;
        out2[1] = g2;
        out2[2] = b2;
        return out2;
      }
      /**
       * Convert to a hexadecimal number.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toNumber(); // returns 16777215
       */
      toNumber() {
        return this._int;
      }
      /**
       * Convert to a BGR number
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
       */
      toBgrNumber() {
        const [r2, g2, b2] = this.toUint8RgbArray();
        return (b2 << 16) + (g2 << 8) + r2;
      }
      /**
       * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
       * @example
       * import { Color } from 'pixi.js';
       * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
       * @returns {number} - The color as a number in little endian format.
       */
      toLittleEndianNumber() {
        const value = this._int;
        return (value >> 16) + (value & 65280) + ((value & 255) << 16);
      }
      /**
       * Multiply with another color. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param {ColorSource} value - The color to multiply by.
       */
      multiply(value) {
        const [r2, g2, b2, a3] = _Color2._temp.setValue(value)._components;
        this._components[0] *= r2;
        this._components[1] *= g2;
        this._components[2] *= b2;
        this._components[3] *= a3;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Converts color to a premultiplied alpha format. This action is destructive, and will
       * override the previous `value` property to be `null`.
       * @param alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {Color} - Itself.
       */
      premultiply(alpha, applyToRGB = true) {
        if (applyToRGB) {
          this._components[0] *= alpha;
          this._components[1] *= alpha;
          this._components[2] *= alpha;
        }
        this._components[3] = alpha;
        this._refreshInt();
        this._value = null;
        return this;
      }
      /**
       * Premultiplies alpha with current color.
       * @param {number} alpha - The alpha to multiply by.
       * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.
       * @returns {number} tint multiplied by alpha
       */
      toPremultiplied(alpha, applyToRGB = true) {
        if (alpha === 1) {
          return (255 << 24) + this._int;
        }
        if (alpha === 0) {
          return applyToRGB ? 0 : this._int;
        }
        let r2 = this._int >> 16 & 255;
        let g2 = this._int >> 8 & 255;
        let b2 = this._int & 255;
        if (applyToRGB) {
          r2 = r2 * alpha + 0.5 | 0;
          g2 = g2 * alpha + 0.5 | 0;
          b2 = b2 * alpha + 0.5 | 0;
        }
        return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
      }
      /**
       * Convert to a hexadecimal string.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHex(); // returns "#ffffff"
       */
      toHex() {
        const hexString = this._int.toString(16);
        return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
      }
      /**
       * Convert to a hexadecimal string with alpha.
       * @example
       * import { Color } from 'pixi.js';
       * new Color('white').toHexa(); // returns "#ffffffff"
       */
      toHexa() {
        const alphaValue = Math.round(this._components[3] * 255);
        const alphaString = alphaValue.toString(16);
        return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
      }
      /**
       * Set alpha, suitable for chaining.
       * @param alpha
       */
      setAlpha(alpha) {
        this._components[3] = this._clamp(alpha);
        return this;
      }
      /**
       * Normalize the input value into rgba
       * @param value - Input value
       */
      _normalize(value) {
        let r2;
        let g2;
        let b2;
        let a3;
        if ((typeof value === "number" || value instanceof Number) && value >= 0 && value <= 16777215) {
          const int = value;
          r2 = (int >> 16 & 255) / 255;
          g2 = (int >> 8 & 255) / 255;
          b2 = (int & 255) / 255;
          a3 = 1;
        } else if ((Array.isArray(value) || value instanceof Float32Array) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value);
          [r2, g2, b2, a3 = 1] = value;
        } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && value.length >= 3 && value.length <= 4) {
          value = this._clamp(value, 0, 255);
          [r2, g2, b2, a3 = 255] = value;
          r2 /= 255;
          g2 /= 255;
          b2 /= 255;
          a3 /= 255;
        } else if (typeof value === "string" || typeof value === "object") {
          if (typeof value === "string") {
            const match = _Color2.HEX_PATTERN.exec(value);
            if (match) {
              value = `#${match[2]}`;
            }
          }
          const color2 = w(value);
          if (color2.isValid()) {
            ({ r: r2, g: g2, b: b2, a: a3 } = color2.rgba);
            r2 /= 255;
            g2 /= 255;
            b2 /= 255;
          }
        }
        if (r2 !== void 0) {
          this._components[0] = r2;
          this._components[1] = g2;
          this._components[2] = b2;
          this._components[3] = a3;
          this._refreshInt();
        } else {
          throw new Error(`Unable to convert color ${value}`);
        }
      }
      /** Refresh the internal color rgb number */
      _refreshInt() {
        this._clamp(this._components);
        const [r2, g2, b2] = this._components;
        this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
      }
      /**
       * Clamps values to a range. Will override original values
       * @param value - Value(s) to clamp
       * @param min - Minimum value
       * @param max - Maximum value
       */
      _clamp(value, min2 = 0, max2 = 1) {
        if (typeof value === "number") {
          return Math.min(Math.max(value, min2), max2);
        }
        value.forEach((v3, i2) => {
          value[i2] = Math.min(Math.max(v3, min2), max2);
        });
        return value;
      }
      /**
       * Check if the value is a color-like object
       * @param value - Value to check
       * @returns True if the value is a color-like object
       * @static
       * @example
       * import { Color } from 'pixi.js';
       * Color.isColorLike('white'); // returns true
       * Color.isColorLike(0xffffff); // returns true
       * Color.isColorLike([1, 1, 1]); // returns true
       */
      static isColorLike(value) {
        return typeof value === "number" || typeof value === "string" || value instanceof Number || value instanceof _Color2 || Array.isArray(value) || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Float32Array || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 || value.r !== void 0 && value.g !== void 0 && value.b !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 || value.h !== void 0 && value.s !== void 0 && value.l !== void 0 && value.a !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 || value.h !== void 0 && value.s !== void 0 && value.v !== void 0 && value.a !== void 0;
      }
    };
    _Color.shared = new _Color();
    _Color._temp = new _Color();
    _Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
    Color = _Color;
  }
});

// node_modules/pixi.js/lib/culling/cullingMixin.mjs
var cullingMixin;
var init_cullingMixin = __esm({
  "node_modules/pixi.js/lib/culling/cullingMixin.mjs"() {
    "use strict";
    cullingMixin = {
      cullArea: null,
      cullable: false,
      cullableChildren: true
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/const.mjs
var PI_2, RAD_TO_DEG, DEG_TO_RAD;
var init_const = __esm({
  "node_modules/pixi.js/lib/maths/misc/const.mjs"() {
    "use strict";
    PI_2 = Math.PI * 2;
    RAD_TO_DEG = 180 / Math.PI;
    DEG_TO_RAD = Math.PI / 180;
  }
});

// node_modules/pixi.js/lib/maths/point/Point.mjs
var Point, tempPoint;
var init_Point = __esm({
  "node_modules/pixi.js/lib/maths/point/Point.mjs"() {
    "use strict";
    Point = class _Point {
      /**
       * Creates a new `Point`
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(x5 = 0, y4 = 0) {
        this.x = 0;
        this.y = 0;
        this.x = x5;
        this.y = y4;
      }
      /**
       * Creates a clone of this point
       * @returns A clone of this point
       */
      clone() {
        return new _Point(this.x, this.y);
      }
      /**
       * Copies `x` and `y` from the given point into this point
       * @param p - The point to copy from
       * @returns The point instance itself
       */
      copyFrom(p2) {
        this.set(p2.x, p2.y);
        return this;
      }
      /**
       * Copies this point's x and y into the given point (`p`).
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this.x, this.y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this.x && p2.y === this.y;
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the `x` axis
       * @param {number} [y=x] - position of the point on the `y` axis
       * @returns The point instance itself
       */
      set(x5 = 0, y4 = x5) {
        this.x = x5;
        this.y = y4;
        return this;
      }
      toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
      }
      /**
       * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.
       * @readonly
       */
      static get shared() {
        tempPoint.x = 0;
        tempPoint.y = 0;
        return tempPoint;
      }
    };
    tempPoint = new Point();
  }
});

// node_modules/pixi.js/lib/maths/matrix/Matrix.mjs
var Matrix, tempMatrix, identityMatrix;
var init_Matrix = __esm({
  "node_modules/pixi.js/lib/maths/matrix/Matrix.mjs"() {
    init_const();
    init_Point();
    Matrix = class _Matrix {
      /**
       * @param a - x scale
       * @param b - y skew
       * @param c - x skew
       * @param d - y scale
       * @param tx - x translation
       * @param ty - y translation
       */
      constructor(a3 = 1, b2 = 0, c3 = 0, d3 = 1, tx = 0, ty = 0) {
        this.array = null;
        this.a = a3;
        this.b = b2;
        this.c = c3;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
      }
      /**
       * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
       *
       * a = array[0]
       * b = array[1]
       * c = array[3]
       * d = array[4]
       * tx = array[2]
       * ty = array[5]
       * @param array - The array that the matrix will be populated from.
       */
      fromArray(array2) {
        this.a = array2[0];
        this.b = array2[1];
        this.c = array2[3];
        this.d = array2[4];
        this.tx = array2[2];
        this.ty = array2[5];
      }
      /**
       * Sets the matrix properties.
       * @param a - Matrix component
       * @param b - Matrix component
       * @param c - Matrix component
       * @param d - Matrix component
       * @param tx - Matrix component
       * @param ty - Matrix component
       * @returns This matrix. Good for chaining method calls.
       */
      set(a3, b2, c3, d3, tx, ty) {
        this.a = a3;
        this.b = b2;
        this.c = c3;
        this.d = d3;
        this.tx = tx;
        this.ty = ty;
        return this;
      }
      /**
       * Creates an array from the current Matrix object.
       * @param transpose - Whether we need to transpose the matrix or not
       * @param [out=new Float32Array(9)] - If provided the array will be assigned to out
       * @returns The newly created array which contains the matrix
       */
      toArray(transpose, out2) {
        if (!this.array) {
          this.array = new Float32Array(9);
        }
        const array2 = out2 || this.array;
        if (transpose) {
          array2[0] = this.a;
          array2[1] = this.b;
          array2[2] = 0;
          array2[3] = this.c;
          array2[4] = this.d;
          array2[5] = 0;
          array2[6] = this.tx;
          array2[7] = this.ty;
          array2[8] = 1;
        } else {
          array2[0] = this.a;
          array2[1] = this.c;
          array2[2] = this.tx;
          array2[3] = this.b;
          array2[4] = this.d;
          array2[5] = this.ty;
          array2[6] = 0;
          array2[7] = 0;
          array2[8] = 1;
        }
        return array2;
      }
      /**
       * Get a new position with the current transformation applied.
       * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, transformed through this matrix
       */
      apply(pos, newPos) {
        newPos = newPos || new Point();
        const x5 = pos.x;
        const y4 = pos.y;
        newPos.x = this.a * x5 + this.c * y4 + this.tx;
        newPos.y = this.b * x5 + this.d * y4 + this.ty;
        return newPos;
      }
      /**
       * Get a new position with the inverse of the current transformation applied.
       * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
       * @param pos - The origin
       * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
       * @returns {Point} The new point, inverse-transformed through this matrix
       */
      applyInverse(pos, newPos) {
        newPos = newPos || new Point();
        const a3 = this.a;
        const b2 = this.b;
        const c3 = this.c;
        const d3 = this.d;
        const tx = this.tx;
        const ty = this.ty;
        const id2 = 1 / (a3 * d3 + c3 * -b2);
        const x5 = pos.x;
        const y4 = pos.y;
        newPos.x = d3 * id2 * x5 + -c3 * id2 * y4 + (ty * c3 - tx * d3) * id2;
        newPos.y = a3 * id2 * y4 + -b2 * id2 * x5 + (-ty * a3 + tx * b2) * id2;
        return newPos;
      }
      /**
       * Translates the matrix on the x and y.
       * @param x - How much to translate x by
       * @param y - How much to translate y by
       * @returns This matrix. Good for chaining method calls.
       */
      translate(x5, y4) {
        this.tx += x5;
        this.ty += y4;
        return this;
      }
      /**
       * Applies a scale transformation to the matrix.
       * @param x - The amount to scale horizontally
       * @param y - The amount to scale vertically
       * @returns This matrix. Good for chaining method calls.
       */
      scale(x5, y4) {
        this.a *= x5;
        this.d *= y4;
        this.c *= x5;
        this.b *= y4;
        this.tx *= x5;
        this.ty *= y4;
        return this;
      }
      /**
       * Applies a rotation transformation to the matrix.
       * @param angle - The angle in radians.
       * @returns This matrix. Good for chaining method calls.
       */
      rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const a1 = this.a;
        const c1 = this.c;
        const tx1 = this.tx;
        this.a = a1 * cos - this.b * sin;
        this.b = a1 * sin + this.b * cos;
        this.c = c1 * cos - this.d * sin;
        this.d = c1 * sin + this.d * cos;
        this.tx = tx1 * cos - this.ty * sin;
        this.ty = tx1 * sin + this.ty * cos;
        return this;
      }
      /**
       * Appends the given Matrix to this Matrix.
       * @param matrix - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      append(matrix) {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        this.a = matrix.a * a1 + matrix.b * c1;
        this.b = matrix.a * b1 + matrix.b * d1;
        this.c = matrix.c * a1 + matrix.d * c1;
        this.d = matrix.c * b1 + matrix.d * d1;
        this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
        this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
        return this;
      }
      /**
       * Appends two matrix's and sets the result to this matrix. AB = A * B
       * @param a - The matrix to append.
       * @param b - The matrix to append.
       * @returns This matrix. Good for chaining method calls.
       */
      appendFrom(a3, b2) {
        const a1 = a3.a;
        const b1 = a3.b;
        const c1 = a3.c;
        const d1 = a3.d;
        const tx = a3.tx;
        const ty = a3.ty;
        const a22 = b2.a;
        const b22 = b2.b;
        const c22 = b2.c;
        const d22 = b2.d;
        this.a = a1 * a22 + b1 * c22;
        this.b = a1 * b22 + b1 * d22;
        this.c = c1 * a22 + d1 * c22;
        this.d = c1 * b22 + d1 * d22;
        this.tx = tx * a22 + ty * c22 + b2.tx;
        this.ty = tx * b22 + ty * d22 + b2.ty;
        return this;
      }
      /**
       * Sets the matrix based on all the available properties
       * @param x - Position on the x axis
       * @param y - Position on the y axis
       * @param pivotX - Pivot on the x axis
       * @param pivotY - Pivot on the y axis
       * @param scaleX - Scale on the x axis
       * @param scaleY - Scale on the y axis
       * @param rotation - Rotation in radians
       * @param skewX - Skew on the x axis
       * @param skewY - Skew on the y axis
       * @returns This matrix. Good for chaining method calls.
       */
      setTransform(x5, y4, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x5 - (pivotX * this.a + pivotY * this.c);
        this.ty = y4 - (pivotX * this.b + pivotY * this.d);
        return this;
      }
      /**
       * Prepends the given Matrix to this Matrix.
       * @param matrix - The matrix to prepend
       * @returns This matrix. Good for chaining method calls.
       */
      prepend(matrix) {
        const tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
          const a1 = this.a;
          const c1 = this.c;
          this.a = a1 * matrix.a + this.b * matrix.c;
          this.b = a1 * matrix.b + this.b * matrix.d;
          this.c = c1 * matrix.a + this.d * matrix.c;
          this.d = c1 * matrix.b + this.d * matrix.d;
        }
        this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
        return this;
      }
      /**
       * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
       * @param transform - The transform to apply the properties to.
       * @returns The transform with the newly applied properties
       */
      decompose(transform4) {
        const a3 = this.a;
        const b2 = this.b;
        const c3 = this.c;
        const d3 = this.d;
        const pivot = transform4.pivot;
        const skewX = -Math.atan2(-c3, d3);
        const skewY = Math.atan2(b2, a3);
        const delta = Math.abs(skewX + skewY);
        if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
          transform4.rotation = skewY;
          transform4.skew.x = transform4.skew.y = 0;
        } else {
          transform4.rotation = 0;
          transform4.skew.x = skewX;
          transform4.skew.y = skewY;
        }
        transform4.scale.x = Math.sqrt(a3 * a3 + b2 * b2);
        transform4.scale.y = Math.sqrt(c3 * c3 + d3 * d3);
        transform4.position.x = this.tx + (pivot.x * a3 + pivot.y * c3);
        transform4.position.y = this.ty + (pivot.x * b2 + pivot.y * d3);
        return transform4;
      }
      /**
       * Inverts this matrix
       * @returns This matrix. Good for chaining method calls.
       */
      invert() {
        const a1 = this.a;
        const b1 = this.b;
        const c1 = this.c;
        const d1 = this.d;
        const tx1 = this.tx;
        const n2 = a1 * d1 - b1 * c1;
        this.a = d1 / n2;
        this.b = -b1 / n2;
        this.c = -c1 / n2;
        this.d = a1 / n2;
        this.tx = (c1 * this.ty - d1 * tx1) / n2;
        this.ty = -(a1 * this.ty - b1 * tx1) / n2;
        return this;
      }
      /** Checks if this matrix is an identity matrix */
      isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
      }
      /**
       * Resets this Matrix to an identity (default) matrix.
       * @returns This matrix. Good for chaining method calls.
       */
      identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
      }
      /**
       * Creates a new Matrix object with the same values as this one.
       * @returns A copy of this matrix. Good for chaining method calls.
       */
      clone() {
        const matrix = new _Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the given matrix to be the same as the ones in this matrix
       * @param matrix - The matrix to copy to.
       * @returns The matrix given in parameter with its values updated.
       */
      copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
      }
      /**
       * Changes the values of the matrix to be the same as the ones in given matrix
       * @param matrix - The matrix to copy from.
       * @returns this
       */
      copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
      }
      /**
       * check to see if two matrices are the same
       * @param matrix - The matrix to compare to.
       */
      equals(matrix) {
        return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
      }
      toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
      }
      /**
       * A default (identity) matrix.
       *
       * This is a shared object, if you want to modify it consider creating a new `Matrix`
       * @readonly
       */
      static get IDENTITY() {
        return identityMatrix.identity();
      }
      /**
       * A static Matrix that can be used to avoid creating new objects.
       * Will always ensure the matrix is reset to identity when requested.
       * Use this object for fast but temporary calculations, as it may be mutated later on.
       * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.
       * @readonly
       */
      static get shared() {
        return tempMatrix.identity();
      }
    };
    tempMatrix = new Matrix();
    identityMatrix = new Matrix();
  }
});

// node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs
var ObservablePoint;
var init_ObservablePoint = __esm({
  "node_modules/pixi.js/lib/maths/point/ObservablePoint.mjs"() {
    "use strict";
    ObservablePoint = class _ObservablePoint {
      /**
       * Creates a new `ObservablePoint`
       * @param observer - Observer to pass to listen for change events.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=0] - position of the point on the y axis
       */
      constructor(observer, x5, y4) {
        this._x = x5 || 0;
        this._y = y4 || 0;
        this._observer = observer;
      }
      /**
       * Creates a clone of this point.
       * @param observer - Optional observer to pass to the new observable point.
       * @returns a copy of this observable point
       */
      clone(observer) {
        return new _ObservablePoint(observer ?? this._observer, this._x, this._y);
      }
      /**
       * Sets the point to a new `x` and `y` position.
       * If `y` is omitted, both `x` and `y` will be set to `x`.
       * @param {number} [x=0] - position of the point on the x axis
       * @param {number} [y=x] - position of the point on the y axis
       * @returns The observable point instance itself
       */
      set(x5 = 0, y4 = x5) {
        if (this._x !== x5 || this._y !== y4) {
          this._x = x5;
          this._y = y4;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies x and y from the given point (`p`)
       * @param p - The point to copy from. Can be any of type that is or extends `PointData`
       * @returns The observable point instance itself
       */
      copyFrom(p2) {
        if (this._x !== p2.x || this._y !== p2.y) {
          this._x = p2.x;
          this._y = p2.y;
          this._observer._onUpdate(this);
        }
        return this;
      }
      /**
       * Copies this point's x and y into that of the given point (`p`)
       * @param p - The point to copy to. Can be any of type that is or extends `PointData`
       * @returns The point (`p`) with values updated
       */
      copyTo(p2) {
        p2.set(this._x, this._y);
        return p2;
      }
      /**
       * Accepts another point (`p`) and returns `true` if the given point is equal to this point
       * @param p - The point to check
       * @returns Returns `true` if both `x` and `y` are equal
       */
      equals(p2) {
        return p2.x === this._x && p2.y === this._y;
      }
      toString() {
        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;
      }
      /** Position of the observable point on the x axis. */
      get x() {
        return this._x;
      }
      set x(value) {
        if (this._x !== value) {
          this._x = value;
          this._observer._onUpdate(this);
        }
      }
      /** Position of the observable point on the y axis. */
      get y() {
        return this._y;
      }
      set y(value) {
        if (this._y !== value) {
          this._y = value;
          this._observer._onUpdate(this);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/data/uid.mjs
function uid(name = "default") {
  if (uidCache[name] === void 0) {
    uidCache[name] = -1;
  }
  return ++uidCache[name];
}
var uidCache;
var init_uid = __esm({
  "node_modules/pixi.js/lib/utils/data/uid.mjs"() {
    "use strict";
    uidCache = {
      default: -1
    };
  }
});

// node_modules/pixi.js/lib/utils/logging/deprecation.mjs
function deprecation(version, message, ignoreDepth = 3) {
  if (warnings[message]) {
    return;
  }
  let stack = new Error().stack;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (console.groupCollapsed) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        `${message}
Deprecated since v${version}`
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", `${message}
Deprecated since v${version}`);
      console.warn(stack);
    }
  }
  warnings[message] = true;
}
var warnings, v8_0_0;
var init_deprecation = __esm({
  "node_modules/pixi.js/lib/utils/logging/deprecation.mjs"() {
    "use strict";
    warnings = {};
    v8_0_0 = "8.0.0";
  }
});

// node_modules/pixi.js/lib/utils/pool/Pool.mjs
var Pool;
var init_Pool = __esm({
  "node_modules/pixi.js/lib/utils/pool/Pool.mjs"() {
    "use strict";
    Pool = class {
      /**
       * Constructs a new Pool.
       * @param ClassType - The constructor of the items in the pool.
       * @param {number} [initialSize] - The initial size of the pool.
       */
      constructor(ClassType, initialSize) {
        this._pool = [];
        this._count = 0;
        this._index = 0;
        this._classType = ClassType;
        if (initialSize) {
          this.prepopulate(initialSize);
        }
      }
      /**
       * Prepopulates the pool with a given number of items.
       * @param total - The number of items to add to the pool.
       */
      prepopulate(total) {
        for (let i2 = 0; i2 < total; i2++) {
          this._pool[this._index++] = new this._classType();
        }
        this._count += total;
      }
      /**
       * Gets an item from the pool. Calls the item's `init` method if it exists.
       * If there are no items left in the pool, a new one will be created.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(data) {
        let item;
        if (this._index > 0) {
          item = this._pool[--this._index];
        } else {
          item = new this._classType();
        }
        item.init?.(data);
        return item;
      }
      /**
       * Returns an item to the pool. Calls the item's `reset` method if it exists.
       * @param {T} item - The item to return to the pool.
       */
      return(item) {
        item.reset?.();
        this._pool[this._index++] = item;
      }
      /**
       * Gets the number of items in the pool.
       * @readonly
       * @member {number}
       */
      get totalSize() {
        return this._count;
      }
      /**
       * Gets the number of items in the pool that are free to use without needing to create more.
       * @readonly
       * @member {number}
       */
      get totalFree() {
        return this._index;
      }
      /**
       * Gets the number of items in the pool that are currently in use.
       * @readonly
       * @member {number}
       */
      get totalUsed() {
        return this._count - this._index;
      }
      /** clears the pool - mainly used for debugging! */
      clear() {
        this._pool.length = 0;
        this._index = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs
var PoolGroupClass, BigPool;
var init_PoolGroup = __esm({
  "node_modules/pixi.js/lib/utils/pool/PoolGroup.mjs"() {
    init_Pool();
    PoolGroupClass = class {
      constructor() {
        this._poolsByClass = /* @__PURE__ */ new Map();
      }
      /**
       * Prepopulates a specific pool with a given number of items.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {number} total - The number of items to add to the pool.
       */
      prepopulate(Class, total) {
        const classPool = this.getPool(Class);
        classPool.prepopulate(total);
      }
      /**
       * Gets an item from a specific pool.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
       * @param {unknown} [data] - Optional data to pass to the item's constructor.
       * @returns {T} The item from the pool.
       */
      get(Class, data) {
        const pool = this.getPool(Class);
        return pool.get(data);
      }
      /**
       * Returns an item to its respective pool.
       * @param {PoolItem} item - The item to return to the pool.
       */
      return(item) {
        const pool = this.getPool(item.constructor);
        pool.return(item);
      }
      /**
       * Gets a specific pool based on the class type.
       * @template T The type of items in the pool. Must extend PoolItem.
       * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
       * @returns {Pool<T>} The pool of the given class type.
       */
      getPool(ClassType) {
        if (!this._poolsByClass.has(ClassType)) {
          this._poolsByClass.set(ClassType, new Pool(ClassType));
        }
        return this._poolsByClass.get(ClassType);
      }
      /** gets the usage stats of each pool in the system */
      stats() {
        const stats = {};
        this._poolsByClass.forEach((pool) => {
          const name = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
          stats[name] = {
            free: pool.totalFree,
            used: pool.totalUsed,
            size: pool.totalSize
          };
        });
        return stats;
      }
    };
    BigPool = new PoolGroupClass();
  }
});

// node_modules/pixi.js/lib/utils/data/removeItems.mjs
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
var init_removeItems = __esm({
  "node_modules/pixi.js/lib/utils/data/removeItems.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs
var childrenHelperMixin;
var init_childrenHelperMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/childrenHelperMixin.mjs"() {
    init_removeItems();
    init_deprecation();
    childrenHelperMixin = {
      allowChildren: true,
      /**
       * Removes all children from this container that are within the begin and end indexes.
       * @param beginIndex - The beginning position.
       * @param endIndex - The ending position. Default value is size of the container.
       * @returns - List of removed children
       * @memberof scene.Container#
       */
      removeChildren(beginIndex = 0, endIndex) {
        const end = endIndex ?? this.children.length;
        const range2 = end - beginIndex;
        const removed = [];
        if (range2 > 0 && range2 <= end) {
          for (let i2 = end - 1; i2 >= beginIndex; i2--) {
            const child = this.children[i2];
            if (!child)
              continue;
            removed.push(child);
            child.parent = null;
          }
          removeItems(this.children, beginIndex, end);
          const renderGroup = this.renderGroup || this.parentRenderGroup;
          if (renderGroup) {
            renderGroup.removeChildren(removed);
          }
          for (let i2 = 0; i2 < removed.length; ++i2) {
            this.emit("childRemoved", removed[i2], this, i2);
            removed[i2].emit("removed", this);
          }
          return removed;
        } else if (range2 === 0 && this.children.length === 0) {
          return removed;
        }
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
      },
      /**
       * Removes a child from the specified index position.
       * @param index - The index to get the child from
       * @returns The child that was removed.
       * @memberof scene.Container#
       */
      removeChildAt(index2) {
        const child = this.getChildAt(index2);
        return this.removeChild(child);
      },
      /**
       * Returns the child at the specified index
       * @param index - The index to get the child at
       * @returns - The child at the given index, if any.
       * @memberof scene.Container#
       */
      getChildAt(index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error(`getChildAt: Index (${index2}) does not exist.`);
        }
        return this.children[index2];
      },
      /**
       * Changes the position of an existing child in the container container
       * @param child - The child Container instance for which you want to change the index number
       * @param index - The resulting index number for the child container
       * @memberof scene.Container#
       */
      setChildIndex(child, index2) {
        if (index2 < 0 || index2 >= this.children.length) {
          throw new Error(`The index ${index2} supplied is out of bounds ${this.children.length}`);
        }
        this.getChildIndex(child);
        this.addChildAt(child, index2);
      },
      /**
       * Returns the index position of a child Container instance
       * @param child - The Container instance to identify
       * @returns - The index position of the child container to identify
       * @memberof scene.Container#
       */
      getChildIndex(child) {
        const index2 = this.children.indexOf(child);
        if (index2 === -1) {
          throw new Error("The supplied Container must be a child of the caller");
        }
        return index2;
      },
      /**
       * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.
       * If the child is already in this container, it will be moved to the specified index.
       * @param {Container} child - The child to add.
       * @param {number} index - The absolute index where the child will be positioned at the end of the operation.
       * @returns {Container} The child that was added.
       * @memberof scene.Container#
       */
      addChildAt(child, index2) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
        }
        const { children: children2 } = this;
        if (index2 < 0 || index2 > children2.length) {
          throw new Error(`${child}addChildAt: The index ${index2} supplied is out of bounds ${children2.length}`);
        }
        if (child.parent) {
          const currentIndex = child.parent.children.indexOf(child);
          if (child.parent === this && currentIndex === index2) {
            return child;
          }
          if (currentIndex !== -1) {
            child.parent.children.splice(currentIndex, 1);
          }
        }
        if (index2 === children2.length) {
          children2.push(child);
        } else {
          children2.splice(index2, 0, child);
        }
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        if (this.sortableChildren)
          this.sortDirty = true;
        this.emit("childAdded", child, this, index2);
        child.emit("added", this);
        return child;
      },
      /**
       * Swaps the position of 2 Containers within this container.
       * @param child - First container to swap
       * @param child2 - Second container to swap
       */
      swapChildren(child, child2) {
        if (child === child2) {
          return;
        }
        const index1 = this.getChildIndex(child);
        const index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        this._didContainerChangeTick++;
      },
      /**
       * Remove the Container from its parent Container. If the Container has no parent, do nothing.
       * @memberof scene.Container#
       */
      removeFromParent() {
        this.parent?.removeChild(this);
      },
      /**
       * Reparent the child to this container, keeping the same worldTransform.
       * @param child - The child to reparent
       * @returns The first child that was reparented.
       * @memberof scene.Container#
       */
      reparentChild(...child) {
        if (child.length === 1) {
          return this.reparentChildAt(child[0], this.children.length);
        }
        child.forEach((c3) => this.reparentChildAt(c3, this.children.length));
        return child[0];
      },
      /**
       * Reparent the child to this container at the specified index, keeping the same worldTransform.
       * @param child - The child to reparent
       * @param index - The index to reparent the child to
       * @memberof scene.Container#
       */
      reparentChildAt(child, index2) {
        if (child.parent === this) {
          this.setChildIndex(child, index2);
          return child;
        }
        const childMat = child.worldTransform.clone();
        child.removeFromParent();
        this.addChildAt(child, index2);
        const newMatrix = this.worldTransform.clone();
        newMatrix.invert();
        childMat.prepend(newMatrix);
        child.setFromMatrix(childMat);
        return child;
      }
    };
  }
});

// node_modules/pixi.js/lib/filters/FilterEffect.mjs
var FilterEffect;
var init_FilterEffect = __esm({
  "node_modules/pixi.js/lib/filters/FilterEffect.mjs"() {
    "use strict";
    FilterEffect = class {
      constructor() {
        this.pipe = "filter";
        this.priority = 1;
      }
      destroy() {
        for (let i2 = 0; i2 < this.filters.length; i2++) {
          this.filters[i2].destroy();
        }
        this.filters = null;
        this.filterArea = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs
var MaskEffectManagerClass, MaskEffectManager;
var init_MaskEffectManager = __esm({
  "node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs"() {
    init_Extensions();
    init_PoolGroup();
    MaskEffectManagerClass = class {
      constructor() {
        this._effectClasses = [];
        this._tests = [];
        this._initialized = false;
      }
      init() {
        if (this._initialized)
          return;
        this._initialized = true;
        this._effectClasses.forEach((test) => {
          this.add({
            test: test.test,
            maskClass: test
          });
        });
      }
      add(test) {
        this._tests.push(test);
      }
      getMaskEffect(item) {
        if (!this._initialized)
          this.init();
        for (let i2 = 0; i2 < this._tests.length; i2++) {
          const test = this._tests[i2];
          if (test.test(item)) {
            return BigPool.get(test.maskClass, item);
          }
        }
        return item;
      }
      returnMaskEffect(effect) {
        BigPool.return(effect);
      }
    };
    MaskEffectManager = new MaskEffectManagerClass();
    extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs
var effectsMixin;
var init_effectsMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/effectsMixin.mjs"() {
    init_FilterEffect();
    init_MaskEffectManager();
    effectsMixin = {
      _maskEffect: null,
      _filterEffect: null,
      /**
       * @todo Needs docs.
       * @memberof scene.Container#
       * @type {Array<Effect>}
       */
      effects: [],
      /**
       * @todo Needs docs.
       * @param effect - The effect to add.
       * @memberof scene.Container#
       * @ignore
       */
      addEffect(effect) {
        const index2 = this.effects.indexOf(effect);
        if (index2 !== -1)
          return;
        this.effects.push(effect);
        this.effects.sort((a3, b2) => a3.priority - b2.priority);
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      /**
       * @todo Needs docs.
       * @param effect - The effect to remove.
       * @memberof scene.Container#
       * @ignore
       */
      removeEffect(effect) {
        const index2 = this.effects.indexOf(effect);
        if (index2 === -1)
          return;
        this.effects.splice(index2, 1);
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateIsSimple();
      },
      set mask(value) {
        const effect = this._maskEffect;
        if (effect?.mask === value)
          return;
        if (effect) {
          this.removeEffect(effect);
          MaskEffectManager.returnMaskEffect(effect);
          this._maskEffect = null;
        }
        if (value === null || value === void 0)
          return;
        this._maskEffect = MaskEffectManager.getMaskEffect(value);
        this.addEffect(this._maskEffect);
      },
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * import { Graphics, Sprite } from 'pixi.js';
       *
       * const graphics = new Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new Sprite(texture);
       * sprite.mask = graphics;
       * @memberof scene.Container#
       */
      get mask() {
        return this._maskEffect?.mask;
      },
      set filters(value) {
        if (!Array.isArray(value) && value)
          value = [value];
        const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
        value = value;
        const hasFilters = value?.length > 0;
        const hadFilters = effect.filters?.length > 0;
        const didChange = hasFilters !== hadFilters;
        value = Array.isArray(value) ? value.slice(0) : value;
        effect.filters = Object.freeze(value);
        if (didChange) {
          if (hasFilters) {
            this.addEffect(effect);
          } else {
            this.removeEffect(effect);
            effect.filters = value ?? null;
          }
        }
      },
      /**
       * Sets the filters for the displayObject.
       * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
       * To remove filters simply set this property to `'null'`.
       * @memberof scene.Container#
       */
      get filters() {
        return this._filterEffect?.filters;
      },
      set filterArea(value) {
        this._filterEffect || (this._filterEffect = new FilterEffect());
        this._filterEffect.filterArea = value;
      },
      /**
       * The area the filter is applied to. This is used as more of an optimization
       * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
       *
       * Also works as an interaction mask.
       * @memberof scene.Container#
       */
      get filterArea() {
        return this._filterEffect?.filterArea;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs
var findMixin;
var init_findMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/findMixin.mjs"() {
    init_deprecation();
    findMixin = {
      /**
       * The instance label of the object.
       * @memberof scene.Container#
       * @member {string} label
       */
      label: null,
      /**
       * The instance name of the object.
       * @deprecated since 8.0.0
       * @see scene.Container#label
       * @member {string} name
       * @memberof scene.Container#
       */
      get name() {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        return this.label;
      },
      set name(value) {
        deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
        this.label = value;
      },
      /**
       * @method getChildByName
       * @deprecated since 8.0.0
       * @param {string} name - Instance name.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified name.
       * @see scene.Container#getChildByLabel
       * @memberof scene.Container#
       */
      getChildByName(name, deep = false) {
        return this.getChildByLabel(name, deep);
      },
      /**
       * Returns the first child in the container with the specified label.
       *
       * Recursive searches are done in a pre-order traversal.
       * @memberof scene.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @returns {Container} The child with the specified label.
       */
      getChildByLabel(label, deep = false) {
        const children2 = this.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          const child = children2[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label))
            return child;
        }
        if (deep) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            const child = children2[i2];
            const found = child.getChildByLabel(label, true);
            if (found) {
              return found;
            }
          }
        }
        return null;
      },
      /**
       * Returns all children in the container with the specified label.
       * @memberof scene.Container#
       * @param {string|RegExp} label - Instance label.
       * @param {boolean}[deep=false] - Whether to search recursively
       * @param {Container[]} [out=[]] - The array to store matching children in.
       * @returns {Container[]} An array of children with the specified label.
       */
      getChildrenByLabel(label, deep = false, out2 = []) {
        const children2 = this.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          const child = children2[i2];
          if (child.label === label || label instanceof RegExp && label.test(child.label)) {
            out2.push(child);
          }
        }
        if (deep) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            children2[i2].getChildrenByLabel(label, true, out2);
          }
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs
var tempPoints, Rectangle;
var init_Rectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Rectangle.mjs"() {
    init_Point();
    tempPoints = [new Point(), new Point(), new Point(), new Point()];
    Rectangle = class _Rectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rectangle
       * @param y - The Y coordinate of the upper-left corner of the rectangle
       * @param width - The overall width of the rectangle
       * @param height - The overall height of the rectangle
       */
      constructor(x5 = 0, y4 = 0, width = 0, height = 0) {
        this.type = "rectangle";
        this.x = Number(x5);
        this.y = Number(y4);
        this.width = Number(width);
        this.height = Number(height);
      }
      /** Returns the left edge of the rectangle. */
      get left() {
        return this.x;
      }
      /** Returns the right edge of the rectangle. */
      get right() {
        return this.x + this.width;
      }
      /** Returns the top edge of the rectangle. */
      get top() {
        return this.y;
      }
      /** Returns the bottom edge of the rectangle. */
      get bottom() {
        return this.y + this.height;
      }
      /** Determines whether the Rectangle is empty. */
      isEmpty() {
        return this.left === this.right || this.top === this.bottom;
      }
      /** A constant empty rectangle. This is a new object every time the property is accessed */
      static get EMPTY() {
        return new _Rectangle(0, 0, 0, 0);
      }
      /**
       * Creates a clone of this Rectangle
       * @returns a copy of the rectangle
       */
      clone() {
        return new _Rectangle(this.x, this.y, this.width, this.height);
      }
      /**
       * Converts a Bounds object to a Rectangle object.
       * @param bounds - The bounds to copy and convert to a rectangle.
       * @returns Returns itself.
       */
      copyFromBounds(bounds) {
        this.x = bounds.minX;
        this.y = bounds.minY;
        this.width = bounds.maxX - bounds.minX;
        this.height = bounds.maxY - bounds.minY;
        return this;
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rectangle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Rectangle
       */
      contains(x5, y4) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x5 >= this.x && x5 < this.x + this.width) {
          if (y4 >= this.y && y4 < this.y + this.height) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @returns Whether the x/y coordinates are within this rectangle
       */
      strokeContains(x5, y4, strokeWidth) {
        const { width, height } = this;
        if (width <= 0 || height <= 0)
          return false;
        const _x = this.x;
        const _y = this.y;
        const outerLeft = _x - strokeWidth / 2;
        const outerRight = _x + width + strokeWidth / 2;
        const outerTop = _y - strokeWidth / 2;
        const outerBottom = _y + height + strokeWidth / 2;
        const innerLeft = _x + strokeWidth / 2;
        const innerRight = _x + width - strokeWidth / 2;
        const innerTop = _y + strokeWidth / 2;
        const innerBottom = _y + height - strokeWidth / 2;
        return x5 >= outerLeft && x5 <= outerRight && y4 >= outerTop && y4 <= outerBottom && !(x5 > innerLeft && x5 < innerRight && y4 > innerTop && y4 < innerBottom);
      }
      /**
       * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
       * Returns true only if the area of the intersection is >0, this means that Rectangles
       * sharing a side are not overlapping. Another side effect is that an arealess rectangle
       * (width or height equal to zero) can't intersect any other rectangle.
       * @param {Rectangle} other - The Rectangle to intersect with `this`.
       * @param {Matrix} transform - The transformation matrix of `other`.
       * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
       */
      intersects(other, transform4) {
        if (!transform4) {
          const x02 = this.x < other.x ? other.x : this.x;
          const x12 = this.right > other.right ? other.right : this.right;
          if (x12 <= x02) {
            return false;
          }
          const y02 = this.y < other.y ? other.y : this.y;
          const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
          return y12 > y02;
        }
        const x0 = this.left;
        const x1 = this.right;
        const y0 = this.top;
        const y1 = this.bottom;
        if (x1 <= x0 || y1 <= y0) {
          return false;
        }
        const lt = tempPoints[0].set(other.left, other.top);
        const lb = tempPoints[1].set(other.left, other.bottom);
        const rt = tempPoints[2].set(other.right, other.top);
        const rb = tempPoints[3].set(other.right, other.bottom);
        if (rt.x <= lt.x || lb.y <= lt.y) {
          return false;
        }
        const s2 = Math.sign(transform4.a * transform4.d - transform4.b * transform4.c);
        if (s2 === 0) {
          return false;
        }
        transform4.apply(lt, lt);
        transform4.apply(lb, lb);
        transform4.apply(rt, rt);
        transform4.apply(rb, rb);
        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
          return false;
        }
        const nx = s2 * (lb.y - lt.y);
        const ny = s2 * (lt.x - lb.x);
        const n00 = nx * x0 + ny * y0;
        const n10 = nx * x1 + ny * y0;
        const n01 = nx * x0 + ny * y1;
        const n11 = nx * x1 + ny * y1;
        if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
          return false;
        }
        const mx = s2 * (lt.y - rt.y);
        const my = s2 * (rt.x - lt.x);
        const m00 = mx * x0 + my * y0;
        const m10 = mx * x1 + my * y0;
        const m01 = mx * x0 + my * y1;
        const m11 = mx * x1 + my * y1;
        if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
          return false;
        }
        return true;
      }
      /**
       * Pads the rectangle making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       * @returns Returns itself.
       */
      pad(paddingX = 0, paddingY = paddingX) {
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
        return this;
      }
      /**
       * Fits this rectangle around the passed one.
       * @param rectangle - The rectangle to fit.
       * @returns Returns itself.
       */
      fit(rectangle) {
        const x1 = Math.max(this.x, rectangle.x);
        const x22 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.max(this.y, rectangle.y);
        const y22 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x22 - x1, 0);
        this.y = y1;
        this.height = Math.max(y22 - y1, 0);
        return this;
      }
      /**
       * Enlarges rectangle that way its corners lie on grid
       * @param resolution - resolution
       * @param eps - precision
       * @returns Returns itself.
       */
      ceil(resolution = 1, eps = 1e-3) {
        const x22 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        const y22 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x22 - this.x;
        this.height = y22 - this.y;
        return this;
      }
      /**
       * Enlarges this rectangle to include the passed rectangle.
       * @param rectangle - The rectangle to include.
       * @returns Returns itself.
       */
      enlarge(rectangle) {
        const x1 = Math.min(this.x, rectangle.x);
        const x22 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        const y1 = Math.min(this.y, rectangle.y);
        const y22 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x22 - x1;
        this.y = y1;
        this.height = y22 - y1;
        return this;
      }
      /**
       * Returns the framing rectangle of the rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new _Rectangle();
        out2.copyFrom(this);
        return out2;
      }
      toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs
var defaultMatrix, Bounds;
var init_Bounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/Bounds.mjs"() {
    init_Matrix();
    init_Rectangle();
    defaultMatrix = new Matrix();
    Bounds = class _Bounds {
      constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if bounds are empty.
       * @returns - True if empty.
       */
      isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
      }
      /** The bounding rectangle of the bounds. */
      get rectangle() {
        if (!this._rectangle) {
          this._rectangle = new Rectangle();
        }
        const rectangle = this._rectangle;
        if (this.minX > this.maxX || this.minY > this.maxY) {
          rectangle.x = 0;
          rectangle.y = 0;
          rectangle.width = 0;
          rectangle.height = 0;
        } else {
          rectangle.copyFromBounds(this);
        }
        return rectangle;
      }
      /** Clears the bounds and resets. */
      clear() {
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
        this.matrix = defaultMatrix;
        return this;
      }
      /**
       * Sets the bounds.
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       */
      set(x0, y0, x1, y1) {
        this.minX = x0;
        this.minY = y0;
        this.maxX = x1;
        this.maxY = y1;
      }
      /**
       * Adds sprite frame
       * @param x0 - left X of frame
       * @param y0 - top Y of frame
       * @param x1 - right X of frame
       * @param y1 - bottom Y of frame
       * @param matrix
       */
      addFrame(x0, y0, x1, y1, matrix) {
        matrix || (matrix = this.matrix);
        const a3 = matrix.a;
        const b2 = matrix.b;
        const c3 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        let x5 = a3 * x0 + c3 * y0 + tx;
        let y4 = b2 * x0 + d3 * y0 + ty;
        if (x5 < minX)
          minX = x5;
        if (y4 < minY)
          minY = y4;
        if (x5 > maxX)
          maxX = x5;
        if (y4 > maxY)
          maxY = y4;
        x5 = a3 * x1 + c3 * y0 + tx;
        y4 = b2 * x1 + d3 * y0 + ty;
        if (x5 < minX)
          minX = x5;
        if (y4 < minY)
          minY = y4;
        if (x5 > maxX)
          maxX = x5;
        if (y4 > maxY)
          maxY = y4;
        x5 = a3 * x0 + c3 * y1 + tx;
        y4 = b2 * x0 + d3 * y1 + ty;
        if (x5 < minX)
          minX = x5;
        if (y4 < minY)
          minY = y4;
        if (x5 > maxX)
          maxX = x5;
        if (y4 > maxY)
          maxY = y4;
        x5 = a3 * x1 + c3 * y1 + tx;
        y4 = b2 * x1 + d3 * y1 + ty;
        if (x5 < minX)
          minX = x5;
        if (y4 < minY)
          minY = y4;
        if (x5 > maxX)
          maxX = x5;
        if (y4 > maxY)
          maxY = y4;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Adds a rectangle to the bounds.
       * @param rect - The rectangle to be added.
       * @param matrix - The matrix to apply to the bounds.
       */
      addRect(rect, matrix) {
        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
      }
      /**
       * Adds other {@link Bounds}.
       * @param bounds - The Bounds to be added
       * @param matrix
       */
      addBounds(bounds, matrix) {
        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
      }
      /**
       * Adds other Bounds, masked with Bounds.
       * @param mask - The Bounds to be added.
       */
      addBoundsMask(mask) {
        this.minX = this.minX > mask.minX ? this.minX : mask.minX;
        this.minY = this.minY > mask.minY ? this.minY : mask.minY;
        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
      }
      /**
       * Adds other Bounds, multiplied with matrix.
       * @param matrix - The matrix to apply to the bounds.
       */
      applyMatrix(matrix) {
        const minX = this.minX;
        const minY = this.minY;
        const maxX = this.maxX;
        const maxY = this.maxY;
        const { a: a3, b: b2, c: c3, d: d3, tx, ty } = matrix;
        let x5 = a3 * minX + c3 * minY + tx;
        let y4 = b2 * minX + d3 * minY + ty;
        this.minX = x5;
        this.minY = y4;
        this.maxX = x5;
        this.maxY = y4;
        x5 = a3 * maxX + c3 * minY + tx;
        y4 = b2 * maxX + d3 * minY + ty;
        this.minX = x5 < this.minX ? x5 : this.minX;
        this.minY = y4 < this.minY ? y4 : this.minY;
        this.maxX = x5 > this.maxX ? x5 : this.maxX;
        this.maxY = y4 > this.maxY ? y4 : this.maxY;
        x5 = a3 * minX + c3 * maxY + tx;
        y4 = b2 * minX + d3 * maxY + ty;
        this.minX = x5 < this.minX ? x5 : this.minX;
        this.minY = y4 < this.minY ? y4 : this.minY;
        this.maxX = x5 > this.maxX ? x5 : this.maxX;
        this.maxY = y4 > this.maxY ? y4 : this.maxY;
        x5 = a3 * maxX + c3 * maxY + tx;
        y4 = b2 * maxX + d3 * maxY + ty;
        this.minX = x5 < this.minX ? x5 : this.minX;
        this.minY = y4 < this.minY ? y4 : this.minY;
        this.maxX = x5 > this.maxX ? x5 : this.maxX;
        this.maxY = y4 > this.maxY ? y4 : this.maxY;
      }
      /**
       * Resizes the bounds object to include the given rectangle.
       * @param rect - The rectangle to be included.
       */
      fit(rect) {
        if (this.minX < rect.left)
          this.minX = rect.left;
        if (this.maxX > rect.right)
          this.maxX = rect.right;
        if (this.minY < rect.top)
          this.minY = rect.top;
        if (this.maxY > rect.bottom)
          this.maxY = rect.bottom;
        return this;
      }
      /**
       * Resizes the bounds object to include the given bounds.
       * @param left - The left value of the bounds.
       * @param right - The right value of the bounds.
       * @param top - The top value of the bounds.
       * @param bottom - The bottom value of the bounds.
       */
      fitBounds(left, right, top, bottom) {
        if (this.minX < left)
          this.minX = left;
        if (this.maxX > right)
          this.maxX = right;
        if (this.minY < top)
          this.minY = top;
        if (this.maxY > bottom)
          this.maxY = bottom;
        return this;
      }
      /**
       * Pads bounds object, making it grow in all directions.
       * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
       * @param paddingX - The horizontal padding amount.
       * @param paddingY - The vertical padding amount.
       */
      pad(paddingX, paddingY = paddingX) {
        this.minX -= paddingX;
        this.maxX += paddingX;
        this.minY -= paddingY;
        this.maxY += paddingY;
        return this;
      }
      /** Ceils the bounds. */
      ceil() {
        this.minX = Math.floor(this.minX);
        this.minY = Math.floor(this.minY);
        this.maxX = Math.ceil(this.maxX);
        this.maxY = Math.ceil(this.maxY);
        return this;
      }
      /** Clones the bounds. */
      clone() {
        return new _Bounds(this.minX, this.minY, this.maxX, this.maxY);
      }
      /**
       * Scales the bounds by the given values
       * @param x - The X value to scale by.
       * @param y - The Y value to scale by.
       */
      scale(x5, y4 = x5) {
        this.minX *= x5;
        this.minY *= y4;
        this.maxX *= x5;
        this.maxY *= y4;
        return this;
      }
      /** the x value of the bounds. */
      get x() {
        return this.minX;
      }
      set x(value) {
        const width = this.maxX - this.minX;
        this.minX = value;
        this.maxX = value + width;
      }
      /** the y value of the bounds. */
      get y() {
        return this.minY;
      }
      set y(value) {
        const height = this.maxY - this.minY;
        this.minY = value;
        this.maxY = value + height;
      }
      /** the width value of the bounds. */
      get width() {
        return this.maxX - this.minX;
      }
      set width(value) {
        this.maxX = this.minX + value;
      }
      /** the height value of the bounds. */
      get height() {
        return this.maxY - this.minY;
      }
      set height(value) {
        this.maxY = this.minY + value;
      }
      /** the left value of the bounds. */
      get left() {
        return this.minX;
      }
      /** the right value of the bounds. */
      get right() {
        return this.maxX;
      }
      /** the top value of the bounds. */
      get top() {
        return this.minY;
      }
      /** the bottom value of the bounds. */
      get bottom() {
        return this.maxY;
      }
      /** Is the bounds positive. */
      get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
      }
      get isValid() {
        return this.minX + this.minY !== Infinity;
      }
      /**
       * Adds screen vertices from array
       * @param vertexData - calculated vertices
       * @param beginOffset - begin offset
       * @param endOffset - end offset, excluded
       * @param matrix
       */
      addVertexData(vertexData, beginOffset, endOffset, matrix) {
        let minX = this.minX;
        let minY = this.minY;
        let maxX = this.maxX;
        let maxY = this.maxY;
        matrix || (matrix = this.matrix);
        const a3 = matrix.a;
        const b2 = matrix.b;
        const c3 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
          const localX = vertexData[i2];
          const localY = vertexData[i2 + 1];
          const x5 = a3 * localX + c3 * localY + tx;
          const y4 = b2 * localX + d3 * localY + ty;
          minX = x5 < minX ? x5 : minX;
          minY = y4 < minY ? y4 : minY;
          maxX = x5 > maxX ? x5 : maxX;
          maxY = y4 > maxY ? y4 : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
      }
      /**
       * Checks if the point is contained within the bounds.
       * @param x - x coordinate
       * @param y - y coordinate
       */
      containsPoint(x5, y4) {
        if (this.minX <= x5 && this.minY <= y4 && this.maxX >= x5 && this.maxY >= y4) {
          return true;
        }
        return false;
      }
      toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs
var matrixPool, boundsPool;
var init_matrixAndBoundsPool = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/utils/matrixAndBoundsPool.mjs"() {
    init_Matrix();
    init_Pool();
    init_Bounds();
    matrixPool = new Pool(Matrix);
    boundsPool = new Pool(Bounds);
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    if (target.addBounds) {
      bounds.matrix = worldTransform;
      target.addBounds(bounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addBounds?.(bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent2 = target.parent;
  if (parent2) {
    updateTransformBackwards(parent2, parentTransform);
    parent2.updateLocalTransform();
    parentTransform.append(parent2.localTransform);
  }
  return parentTransform;
}
var init_getGlobalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getGlobalBounds.mjs"() {
    init_Matrix();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/utils/logging/warn.mjs
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
var warnCount, maxWarnings;
var init_warn = __esm({
  "node_modules/pixi.js/lib/utils/logging/warn.mjs"() {
    "use strict";
    warnCount = 0;
    maxWarnings = 500;
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      target.addBounds(bounds);
    }
    const children2 = target.children;
    for (let i2 = 0; i2 < children2.length; i2++) {
      _getLocalBounds(children2[i2], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      target.effects[i2].addLocalBounds?.(bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}
var init_getLocalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getLocalBounds.mjs"() {
    init_Matrix();
    init_matrixAndBoundsPool();
  }
});

// node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs
function checkChildrenDidChange(container, previousData) {
  const children2 = container.children;
  for (let i2 = 0; i2 < children2.length; i2++) {
    const child = children2[i2];
    const uid3 = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index2 = previousData.index;
    if (previousData.data[index2] !== uid3 || previousData.data[index2 + 1] !== didChange) {
      previousData.data[previousData.index] = uid3;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index2 + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}
var init_checkChildrenDidChange = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/checkChildrenDidChange.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs
var tempMatrix2, measureMixin;
var init_measureMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/measureMixin.mjs"() {
    init_Matrix();
    init_Bounds();
    init_getGlobalBounds();
    init_getLocalBounds();
    init_checkChildrenDidChange();
    tempMatrix2 = new Matrix();
    measureMixin = {
      _localBoundsCacheId: -1,
      _localBoundsCacheData: null,
      _setWidth(value, localWidth) {
        const sign = Math.sign(this.scale.x) || 1;
        if (localWidth !== 0) {
          this.scale.x = value / localWidth * sign;
        } else {
          this.scale.x = sign;
        }
      },
      _setHeight(value, localHeight) {
        const sign = Math.sign(this.scale.y) || 1;
        if (localHeight !== 0) {
          this.scale.y = value / localHeight * sign;
        } else {
          this.scale.y = sign;
        }
      },
      /**
       * Retrieves the local bounds of the container as a Bounds object.
       * @returns - The bounding area.
       * @memberof scene.Container#
       */
      getLocalBounds() {
        if (!this._localBoundsCacheData) {
          this._localBoundsCacheData = {
            data: [],
            index: 1,
            didChange: false,
            localBounds: new Bounds()
          };
        }
        const localBoundsCacheData = this._localBoundsCacheData;
        localBoundsCacheData.index = 1;
        localBoundsCacheData.didChange = false;
        if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
          localBoundsCacheData.didChange = true;
          localBoundsCacheData.data[0] = this._didViewChangeTick;
        }
        checkChildrenDidChange(this, localBoundsCacheData);
        if (localBoundsCacheData.didChange) {
          getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix2);
        }
        return localBoundsCacheData.localBounds;
      },
      /**
       * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.
       * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from
       *  being updated. This means the calculation returned MAY be out of date BUT will give you a
       *  nice performance boost.
       * @param bounds - Optional bounds to store the result of the bounds calculation.
       * @returns - The minimum axis-aligned rectangle in world space that fits around this object.
       * @memberof scene.Container#
       */
      getBounds(skipUpdate, bounds) {
        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs
var onRenderMixin;
var init_onRenderMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/onRenderMixin.mjs"() {
    "use strict";
    onRenderMixin = {
      _onRender: null,
      set onRender(func) {
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (!func) {
          if (this._onRender) {
            renderGroup?.removeOnRender(this);
          }
          this._onRender = null;
          return;
        }
        if (!this._onRender) {
          renderGroup?.addOnRender(this);
        }
        this._onRender = func;
      },
      /**
       * This callback is used when the container is rendered. This is where you should add your custom
       * logic that is needed to be run every frame.
       *
       * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different
       * and "updateTransform" is no longer called every frame
       * @example
       * const container = new Container();
       * container.onRender = () => {
       *    container.rotation += 0.01;
       * };
       * @memberof scene.Container#
       */
      get onRender() {
        return this._onRender;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs
function sortChildren(a3, b2) {
  return a3._zIndex - b2._zIndex;
}
var sortMixin;
var init_sortMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/sortMixin.mjs"() {
    "use strict";
    sortMixin = {
      _zIndex: 0,
      /**
       * Should children be sorted by zIndex at the next render call.
       *
       * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
       * @type {boolean}
       * @memberof scene.Container#
       */
      sortDirty: false,
      /**
       * If set to true, the container will sort its children by `zIndex` value
       * when the next render is called, or manually if `sortChildren()` is called.
       *
       * This actually changes the order of elements in the array, so should be treated
       * as a basic solution that is not performant compared to other solutions,
       * such as {@link https://github.com/pixijs/layers PixiJS Layers}
       *
       * Also be aware of that this may not work nicely with the `addChildAt()` function,
       * as the `zIndex` sorting may cause the child to automatically sorted to another position.
       * @type {boolean}
       * @memberof scene.Container#
       */
      sortableChildren: false,
      /**
       * The zIndex of the container.
       *
       * Setting this value, will automatically set the parent to be sortable. Children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see scene.Container#sortableChildren
       * @memberof scene.Container#
       */
      get zIndex() {
        return this._zIndex;
      },
      set zIndex(value) {
        if (this._zIndex === value)
          return;
        this._zIndex = value;
        this.depthOfChildModified();
      },
      depthOfChildModified() {
        if (this.parent) {
          this.parent.sortableChildren = true;
          this.parent.sortDirty = true;
        }
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
      },
      /**
       * Sorts children by zIndex.
       * @memberof scene.Container#
       */
      sortChildren() {
        if (!this.sortDirty)
          return;
        this.sortDirty = false;
        this.children.sort(sortChildren);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs
var toLocalGlobalMixin;
var init_toLocalGlobalMixin = __esm({
  "node_modules/pixi.js/lib/scene/container/container-mixins/toLocalGlobalMixin.mjs"() {
    init_Matrix();
    init_Point();
    init_getGlobalBounds();
    toLocalGlobalMixin = {
      /**
       * Returns the global position of the container.
       * @param point - The optional point to write the global value to.
       * @param skipUpdate - Should we skip the update transform.
       * @returns - The updated point.
       * @memberof scene.Container#
       */
      getGlobalPosition(point = new Point(), skipUpdate = false) {
        if (this.parent) {
          this.parent.toGlobal(this._position, point, skipUpdate);
        } else {
          point.x = this._position.x;
          point.y = this._position.y;
        }
        return point;
      },
      /**
       * Calculates the global position of the container.
       * @param position - The world origin to calculate from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform.
       * @returns - A point object representing the position of this object.
       * @memberof scene.Container#
       */
      toGlobal(position, point, skipUpdate = false) {
        if (!skipUpdate) {
          this.updateLocalTransform();
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.apply(position, point);
        }
        return this.worldTransform.apply(position, point);
      },
      /**
       * Calculates the local position of the container relative to another point.
       * @param position - The world origin to calculate from.
       * @param from - The Container to calculate the global position from.
       * @param point - A Point object in which to store the value, optional
       *  (otherwise will create a new Point).
       * @param skipUpdate - Should we skip the update transform
       * @returns - A point object representing the position of this object
       * @memberof scene.Container#
       */
      toLocal(position, from, point, skipUpdate) {
        if (from) {
          position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
          this.updateLocalTransform();
          const globalMatrix = updateTransformBackwards(this, new Matrix());
          globalMatrix.append(this.localTransform);
          return globalMatrix.applyInverse(position, point);
        }
        return this.worldTransform.applyInverse(position, point);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs
var _tick, InstructionSet;
var init_InstructionSet = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs"() {
    init_uid();
    _tick = 0;
    InstructionSet = class {
      constructor() {
        this.uid = uid("instructionSet");
        this.instructions = [];
        this.instructionSize = 0;
        this.renderables = [];
        this.tick = 0;
      }
      /** reset the instruction set so it can be reused set size back to 0 */
      reset() {
        this.instructionSize = 0;
        this.tick = _tick++;
      }
      /**
       * Add an instruction to the set
       * @param instruction - add an instruction to the set
       */
      add(instruction) {
        this.instructions[this.instructionSize++] = instruction;
      }
      /**
       * Log the instructions to the console (for debugging)
       * @internal
       * @ignore
       */
      log() {
        this.instructions.length = this.instructionSize;
        console.table(this.instructions, ["type", "action"]);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroup.mjs
var RenderGroup;
var init_RenderGroup = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroup.mjs"() {
    init_Matrix();
    init_InstructionSet();
    RenderGroup = class {
      constructor() {
        this.renderPipeId = "renderGroup";
        this.root = null;
        this.canBundle = false;
        this.renderGroupParent = null;
        this.renderGroupChildren = [];
        this.worldTransform = new Matrix();
        this.worldColorAlpha = 4294967295;
        this.worldColor = 16777215;
        this.worldAlpha = 1;
        this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
        this.updateTick = 0;
        this.childrenRenderablesToUpdate = { list: [], index: 0 };
        this.structureDidChange = true;
        this.instructionSet = new InstructionSet();
        this._onRenderContainers = [];
      }
      init(root3) {
        this.root = root3;
        if (root3._onRender)
          this.addOnRender(root3);
        root3.didChange = true;
        const children2 = root3.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          this.addChild(children2[i2]);
        }
      }
      reset() {
        this.renderGroupChildren.length = 0;
        for (const i2 in this.childrenToUpdate) {
          const childrenAtDepth = this.childrenToUpdate[i2];
          childrenAtDepth.list.fill(null);
          childrenAtDepth.index = 0;
        }
        this.childrenRenderablesToUpdate.index = 0;
        this.childrenRenderablesToUpdate.list.fill(null);
        this.root = null;
        this.updateTick = 0;
        this.structureDidChange = true;
        this._onRenderContainers.length = 0;
        this.renderGroupParent = null;
      }
      get localTransform() {
        return this.root.localTransform;
      }
      addRenderGroupChild(renderGroupChild) {
        if (renderGroupChild.renderGroupParent) {
          renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
        }
        renderGroupChild.renderGroupParent = this;
        this.renderGroupChildren.push(renderGroupChild);
      }
      _removeRenderGroupChild(renderGroupChild) {
        const index2 = this.renderGroupChildren.indexOf(renderGroupChild);
        if (index2 > -1) {
          this.renderGroupChildren.splice(index2, 1);
        }
        renderGroupChild.renderGroupParent = null;
      }
      addChild(child) {
        this.structureDidChange = true;
        child.parentRenderGroup = this;
        child.updateTick = -1;
        if (child.parent === this.root) {
          child.relativeRenderGroupDepth = 1;
        } else {
          child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
        }
        child.didChange = true;
        this.onChildUpdate(child);
        if (child.renderGroup) {
          this.addRenderGroupChild(child.renderGroup);
          return;
        }
        if (child._onRender)
          this.addOnRender(child);
        const children2 = child.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          this.addChild(children2[i2]);
        }
      }
      removeChild(child) {
        this.structureDidChange = true;
        if (child._onRender) {
          if (!child.renderGroup) {
            this.removeOnRender(child);
          }
        }
        child.parentRenderGroup = null;
        if (child.renderGroup) {
          this._removeRenderGroupChild(child.renderGroup);
          return;
        }
        const children2 = child.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          this.removeChild(children2[i2]);
        }
      }
      removeChildren(children2) {
        for (let i2 = 0; i2 < children2.length; i2++) {
          this.removeChild(children2[i2]);
        }
      }
      onChildUpdate(child) {
        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
        if (!childrenToUpdate) {
          childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
            index: 0,
            list: []
          };
        }
        childrenToUpdate.list[childrenToUpdate.index++] = child;
      }
      // SHOULD THIS BE HERE?
      updateRenderable(container) {
        if (container.globalDisplayStatus < 7)
          return;
        container.didViewUpdate = false;
        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);
      }
      onChildViewUpdate(child) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
      }
      get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
      }
      /**
       * adding a container to the onRender list will make sure the user function
       * passed in to the user defined 'onRender` callBack
       * @param container - the container to add to the onRender list
       */
      addOnRender(container) {
        this._onRenderContainers.push(container);
      }
      removeOnRender(container) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
      }
      runOnRender() {
        for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
          this._onRenderContainers[i2]._onRender();
        }
      }
      destroy() {
        this.renderGroupParent = null;
        this.root = null;
        this.childrenRenderablesToUpdate = null;
        this.childrenToUpdate = null;
        this.renderGroupChildren = null;
        this._onRenderContainers = null;
        this.instructionSet = null;
      }
      getChildren(out2 = []) {
        const children2 = this.root.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          this._getChildren(children2[i2], out2);
        }
        return out2;
      }
      _getChildren(container, out2 = []) {
        out2.push(container);
        if (container.renderGroup)
          return out2;
        const children2 = container.children;
        for (let i2 = 0; i2 < children2.length; i2++) {
          this._getChildren(children2[i2], out2);
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs
function assignWithIgnore(target, options, ignore = {}) {
  for (const key in options) {
    if (!ignore[key] && options[key] !== void 0) {
      target[key] = options[key];
    }
  }
}
var init_assignWithIgnore = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/assignWithIgnore.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/Container.mjs
var defaultSkew, defaultPivot, defaultScale, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE, Container;
var init_Container = __esm({
  "node_modules/pixi.js/lib/scene/container/Container.mjs"() {
    init_eventemitter3();
    init_Color();
    init_cullingMixin();
    init_Matrix();
    init_const();
    init_ObservablePoint();
    init_uid();
    init_deprecation();
    init_PoolGroup();
    init_childrenHelperMixin();
    init_effectsMixin();
    init_findMixin();
    init_measureMixin();
    init_onRenderMixin();
    init_sortMixin();
    init_toLocalGlobalMixin();
    init_RenderGroup();
    init_assignWithIgnore();
    defaultSkew = new ObservablePoint(null);
    defaultPivot = new ObservablePoint(null);
    defaultScale = new ObservablePoint(null, 1, 1);
    UPDATE_COLOR = 1;
    UPDATE_BLEND = 2;
    UPDATE_VISIBLE = 4;
    Container = class _Container extends eventemitter3_default {
      constructor(options = {}) {
        super();
        this.uid = uid("renderable");
        this._updateFlags = 15;
        this.renderGroup = null;
        this.parentRenderGroup = null;
        this.parentRenderGroupIndex = 0;
        this.didChange = false;
        this.didViewUpdate = false;
        this.relativeRenderGroupDepth = 0;
        this.children = [];
        this.parent = null;
        this.includeInBuild = true;
        this.measurable = true;
        this.isSimple = true;
        this.updateTick = -1;
        this.localTransform = new Matrix();
        this.relativeGroupTransform = new Matrix();
        this.groupTransform = this.relativeGroupTransform;
        this.destroyed = false;
        this._position = new ObservablePoint(this, 0, 0);
        this._scale = defaultScale;
        this._pivot = defaultPivot;
        this._skew = defaultSkew;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._rotation = 0;
        this.localColor = 16777215;
        this.localAlpha = 1;
        this.groupAlpha = 1;
        this.groupColor = 16777215;
        this.groupColorAlpha = 4294967295;
        this.localBlendMode = "inherit";
        this.groupBlendMode = "normal";
        this.localDisplayStatus = 7;
        this.globalDisplayStatus = 7;
        this._didContainerChangeTick = 0;
        this._didViewChangeTick = 0;
        this._didLocalTransformChangeId = -1;
        this.effects = [];
        assignWithIgnore(this, options, {
          children: true,
          parent: true,
          effects: true
        });
        options.children?.forEach((child) => this.addChild(child));
        options.parent?.addChild(this);
      }
      /**
       * Mixes all enumerable properties and methods from a source object to Container.
       * @param source - The source of properties and methods to mix in.
       */
      static mixin(source2) {
        Object.defineProperties(_Container.prototype, Object.getOwnPropertyDescriptors(source2));
      }
      /**
       * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
       * @deprecated since 8.2.6
       * @ignore
       */
      set _didChangeId(value) {
        this._didViewChangeTick = value >> 12 & 4095;
        this._didContainerChangeTick = value & 4095;
      }
      get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
      }
      /**
       * Adds one or more children to the container.
       *
       * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
       * @param {...Container} children - The Container(s) to add to the container
       * @returns {Container} - The first child that was added.
       */
      addChild(...children2) {
        if (!this.allowChildren) {
          deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
        }
        if (children2.length > 1) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.addChild(children2[i2]);
          }
          return children2[0];
        }
        const child = children2[0];
        if (child.parent === this) {
          this.children.splice(this.children.indexOf(child), 1);
          this.children.push(child);
          if (this.parentRenderGroup) {
            this.parentRenderGroup.structureDidChange = true;
          }
          return child;
        }
        if (child.parent) {
          child.parent.removeChild(child);
        }
        this.children.push(child);
        if (this.sortableChildren)
          this.sortDirty = true;
        child.parent = this;
        child.didChange = true;
        child.didViewUpdate = false;
        child._updateFlags = 15;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.addChild(child);
        }
        this.emit("childAdded", child, this, this.children.length - 1);
        child.emit("added", this);
        this._didViewChangeTick++;
        if (child._zIndex !== 0) {
          child.depthOfChildModified();
        }
        return child;
      }
      /**
       * Removes one or more children from the container.
       * @param {...Container} children - The Container(s) to remove
       * @returns {Container} The first child that was removed.
       */
      removeChild(...children2) {
        if (children2.length > 1) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            this.removeChild(children2[i2]);
          }
          return children2[0];
        }
        const child = children2[0];
        const index2 = this.children.indexOf(child);
        if (index2 > -1) {
          this._didViewChangeTick++;
          this.children.splice(index2, 1);
          if (this.renderGroup) {
            this.renderGroup.removeChild(child);
          } else if (this.parentRenderGroup) {
            this.parentRenderGroup.removeChild(child);
          }
          child.parent = null;
          this.emit("childRemoved", child, this, index2);
          child.emit("removed", this);
        }
        return child;
      }
      /** @ignore */
      _onUpdate(point) {
        if (point) {
          if (point === this._skew) {
            this._updateSkew();
          }
        }
        this._didContainerChangeTick++;
        if (this.didChange)
          return;
        this.didChange = true;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.onChildUpdate(this);
        }
      }
      set isRenderGroup(value) {
        if (!!this.renderGroup === value)
          return;
        if (value) {
          this.enableRenderGroup();
        } else {
          this.disableRenderGroup();
        }
      }
      /**
       * Returns true if this container is a render group.
       * This means that it will be rendered as a separate pass, with its own set of instructions
       */
      get isRenderGroup() {
        return !!this.renderGroup;
      }
      /**
       * Calling this enables a render group for this container.
       * This means it will be rendered as a separate set of instructions.
       * The transform of the container will also be handled on the GPU rather than the CPU.
       */
      enableRenderGroup() {
        if (this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        this.renderGroup = BigPool.get(RenderGroup, this);
        this.groupTransform = Matrix.IDENTITY;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /** This will disable the render group for this container. */
      disableRenderGroup() {
        if (!this.renderGroup)
          return;
        const parentRenderGroup = this.parentRenderGroup;
        parentRenderGroup?.removeChild(this);
        BigPool.return(this.renderGroup);
        this.renderGroup = null;
        this.groupTransform = this.relativeGroupTransform;
        parentRenderGroup?.addChild(this);
        this._updateIsSimple();
      }
      /** @ignore */
      _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0;
      }
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get worldTransform() {
        this._worldTransform || (this._worldTransform = new Matrix());
        if (this.renderGroup) {
          this._worldTransform.copyFrom(this.renderGroup.worldTransform);
        } else if (this.parentRenderGroup) {
          this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
        }
        return this._worldTransform;
      }
      // / ////// transform related stuff
      /**
       * The position of the container on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get x() {
        return this._position.x;
      }
      set x(value) {
        this._position.x = value;
      }
      /**
       * The position of the container on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get y() {
        return this._position.y;
      }
      set y(value) {
        this._position.y = value;
      }
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get position() {
        return this._position;
      }
      set position(value) {
        this._position.copyFrom(value);
      }
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get rotation() {
        return this._rotation;
      }
      set rotation(value) {
        if (this._rotation !== value) {
          this._rotation = value;
          this._onUpdate(this._skew);
        }
      }
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get angle() {
        return this.rotation * RAD_TO_DEG;
      }
      set angle(value) {
        this.rotation = value * DEG_TO_RAD;
      }
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get pivot() {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        return this._pivot;
      }
      set pivot(value) {
        if (this._pivot === defaultPivot) {
          this._pivot = new ObservablePoint(this, 0, 0);
        }
        typeof value === "number" ? this._pivot.set(value) : this._pivot.copyFrom(value);
      }
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get skew() {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        return this._skew;
      }
      set skew(value) {
        if (this._skew === defaultSkew) {
          this._skew = new ObservablePoint(this, 0, 0);
        }
        this._skew.copyFrom(value);
      }
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get scale() {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 1, 1);
        }
        return this._scale;
      }
      set scale(value) {
        if (this._scale === defaultScale) {
          this._scale = new ObservablePoint(this, 0, 0);
        }
        typeof value === "number" ? this._scale.set(value) : this._scale.copyFrom(value);
      }
      /**
       * The width of the Container, setting this will actually modify the scale to achieve the value set.
       * @memberof scene.Container#
       */
      get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width);
      }
      set width(value) {
        const localWidth = this.getLocalBounds().width;
        this._setWidth(value, localWidth);
      }
      /**
       * The height of the Container, setting this will actually modify the scale to achieve the value set.
       * @memberof scene.Container#
       */
      get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height);
      }
      set height(value) {
        const localHeight = this.getLocalBounds().height;
        this._setHeight(value, localHeight);
      }
      /**
       * Retrieves the size of the container as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the container.
       * @memberof scene.Container#
       */
      getSize(out2) {
        if (!out2) {
          out2 = {};
        }
        const bounds = this.getLocalBounds();
        out2.width = Math.abs(this.scale.x * bounds.width);
        out2.height = Math.abs(this.scale.y * bounds.height);
        return out2;
      }
      /**
       * Sets the size of the container to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       * @memberof scene.Container#
       */
      setSize(value, height) {
        const size = this.getLocalBounds();
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, size.width);
        height !== void 0 && this._setHeight(height, size.height);
      }
      /** Called when the skew or the rotation changes. */
      _updateSkew() {
        const rotation = this._rotation;
        const skew = this._skew;
        this._cx = Math.cos(rotation + skew._y);
        this._sx = Math.sin(rotation + skew._y);
        this._cy = -Math.sin(rotation - skew._x);
        this._sy = Math.cos(rotation - skew._x);
      }
      /**
       * Updates the transform properties of the container (accepts partial values).
       * @param {object} opts - The options for updating the transform.
       * @param {number} opts.x - The x position of the container.
       * @param {number} opts.y - The y position of the container.
       * @param {number} opts.scaleX - The scale factor on the x-axis.
       * @param {number} opts.scaleY - The scale factor on the y-axis.
       * @param {number} opts.rotation - The rotation of the container, in radians.
       * @param {number} opts.skewX - The skew factor on the x-axis.
       * @param {number} opts.skewY - The skew factor on the y-axis.
       * @param {number} opts.pivotX - The x coordinate of the pivot point.
       * @param {number} opts.pivotY - The y coordinate of the pivot point.
       */
      updateTransform(opts) {
        this.position.set(
          typeof opts.x === "number" ? opts.x : this.position.x,
          typeof opts.y === "number" ? opts.y : this.position.y
        );
        this.scale.set(
          typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
          typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
        );
        this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
        this.skew.set(
          typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
          typeof opts.skewY === "number" ? opts.skewY : this.skew.y
        );
        this.pivot.set(
          typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
          typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
        );
        return this;
      }
      /**
       * Updates the local transform using the given matrix.
       * @param matrix - The matrix to use for updating the transform.
       */
      setFromMatrix(matrix) {
        matrix.decompose(this);
      }
      /** Updates the local transform. */
      updateLocalTransform() {
        const localTransformChangeId = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === localTransformChangeId)
          return;
        this._didLocalTransformChangeId = localTransformChangeId;
        const lt = this.localTransform;
        const scale = this._scale;
        const pivot = this._pivot;
        const position = this._position;
        const sx = scale._x;
        const sy = scale._y;
        const px = pivot._x;
        const py = pivot._y;
        lt.a = this._cx * sx;
        lt.b = this._sx * sx;
        lt.c = this._cy * sy;
        lt.d = this._sy * sy;
        lt.tx = position._x - (px * lt.a + py * lt.c);
        lt.ty = position._y - (px * lt.b + py * lt.d);
      }
      // / ///// color related stuff
      set alpha(value) {
        if (value === this.localAlpha)
          return;
        this.localAlpha = value;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /** The opacity of the object. */
      get alpha() {
        return this.localAlpha;
      }
      set tint(value) {
        const tempColor = Color.shared.setValue(value ?? 16777215);
        const bgr = tempColor.toBgrNumber();
        if (bgr === this.localColor)
          return;
        this.localColor = bgr;
        this._updateFlags |= UPDATE_COLOR;
        this._onUpdate();
      }
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get tint() {
        const bgr = this.localColor;
        return ((bgr & 255) << 16) + (bgr & 65280) + (bgr >> 16 & 255);
      }
      // / //////////////// blend related stuff
      set blendMode(value) {
        if (this.localBlendMode === value)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_BLEND;
        this.localBlendMode = value;
        this._onUpdate();
      }
      /**
       * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.
       * @default 'normal'
       */
      get blendMode() {
        return this.localBlendMode;
      }
      // / ///////// VISIBILITY / RENDERABLE /////////////////
      /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */
      get visible() {
        return !!(this.localDisplayStatus & 2);
      }
      set visible(value) {
        const valueNumber = value ? 2 : 0;
        if ((this.localDisplayStatus & 2) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 2;
        this._onUpdate();
      }
      /** @ignore */
      get culled() {
        return !(this.localDisplayStatus & 4);
      }
      /** @ignore */
      set culled(value) {
        const valueNumber = value ? 0 : 4;
        if ((this.localDisplayStatus & 4) === valueNumber)
          return;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 4;
        this._onUpdate();
      }
      /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */
      get renderable() {
        return !!(this.localDisplayStatus & 1);
      }
      set renderable(value) {
        const valueNumber = value ? 1 : 0;
        if ((this.localDisplayStatus & 1) === valueNumber)
          return;
        this._updateFlags |= UPDATE_VISIBLE;
        this.localDisplayStatus ^= 1;
        if (this.parentRenderGroup) {
          this.parentRenderGroup.structureDidChange = true;
        }
        this._onUpdate();
      }
      /** Whether or not the object should be rendered. */
      get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0;
      }
      /**
       * Removes all internal references and listeners as well as removes children from the display list.
       * Do not use a Container after calling `destroy`.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
       *  method called as well. 'options' will be passed on to those calls.
       * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children
       * is set to true it should destroy the texture of the child sprite
       * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
       * If options.children is set to true it should destroy the texture source of the child sprite
       * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
       * If options.children is set to true it should destroy the context of the child graphics
       */
      destroy(options = false) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        const oldChildren = this.removeChildren(0, this.children.length);
        this.removeFromParent();
        this.parent = null;
        this._maskEffect = null;
        this._filterEffect = null;
        this.effects = null;
        this._position = null;
        this._scale = null;
        this._pivot = null;
        this._skew = null;
        this.emit("destroyed", this);
        this.removeAllListeners();
        const destroyChildren = typeof options === "boolean" ? options : options?.children;
        if (destroyChildren) {
          for (let i2 = 0; i2 < oldChildren.length; ++i2) {
            oldChildren[i2].destroy(options);
          }
        }
        this.renderGroup?.destroy();
        this.renderGroup = null;
      }
    };
    Container.mixin(childrenHelperMixin);
    Container.mixin(toLocalGlobalMixin);
    Container.mixin(onRenderMixin);
    Container.mixin(measureMixin);
    Container.mixin(effectsMixin);
    Container.mixin(findMixin);
    Container.mixin(sortMixin);
    Container.mixin(cullingMixin);
  }
});

// node_modules/pixi.js/lib/events/FederatedEvent.mjs
var FederatedEvent;
var init_FederatedEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedEvent.mjs"() {
    init_Point();
    FederatedEvent = class _FederatedEvent {
      /**
       * @param manager - The event boundary which manages this event. Propagation can only occur
       *  within the boundary's jurisdiction.
       */
      constructor(manager) {
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.composed = false;
        this.defaultPrevented = false;
        this.eventPhase = _FederatedEvent.prototype.NONE;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point();
        this.page = new Point();
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      /** @readonly */
      get layerX() {
        return this.layer.x;
      }
      /** @readonly */
      get layerY() {
        return this.layer.y;
      }
      /** @readonly */
      get pageX() {
        return this.page.x;
      }
      /** @readonly */
      get pageY() {
        return this.page.y;
      }
      /**
       * Fallback for the deprecated @code{InteractionEvent.data}.
       * @deprecated since 7.0.0
       */
      get data() {
        return this;
      }
      /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */
      composedPath() {
        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.
       * @deprecated
       * @param _type
       * @param _bubbles
       * @param _cancelable
       */
      initEvent(_type, _bubbles, _cancelable) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /**
       * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.
       * @deprecated
       * @param _typeArg
       * @param _bubblesArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       */
      initUIEvent(_typeArg, _bubblesArg, _cancelableArg, _viewArg, _detailArg) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.");
      }
      /** Prevent default behavior of PixiJS and the user agent. */
      preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * Stop this event from propagating to any addition listeners, including on the
       * {@link FederatedEventTarget.currentTarget currentTarget} and also the following
       * event targets on the propagation path.
       */
      stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners
       * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
  }
});

// node_modules/ismobilejs/esm/isMobile.js
function createMatch(userAgent) {
  return function(regex) {
    return regex.test(userAgent);
  };
}
function isMobile(param) {
  var nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  var userAgent = nav.userAgent;
  var tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  var match = createMatch(userAgent);
  var result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}
var appleIphone, appleIpod, appleTablet, appleUniversal, androidPhone, androidTablet, amazonPhone, amazonTablet, windowsPhone, windowsTablet, otherBlackBerry, otherBlackBerry10, otherOpera, otherChrome, otherFirefox, isAppleTabletOnIos13;
var init_isMobile = __esm({
  "node_modules/ismobilejs/esm/isMobile.js"() {
    appleIphone = /iPhone/i;
    appleIpod = /iPod/i;
    appleTablet = /iPad/i;
    appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
    androidPhone = /\bAndroid(?:.+)Mobile\b/i;
    androidTablet = /Android/i;
    amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
    amazonTablet = /Silk/i;
    windowsPhone = /Windows Phone/i;
    windowsTablet = /\bWindows(?:.+)ARM\b/i;
    otherBlackBerry = /BlackBerry/i;
    otherBlackBerry10 = /BB10/i;
    otherOpera = /Opera Mini/i;
    otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
    otherFirefox = /Mobile(?:.+)Firefox\b/i;
    isAppleTabletOnIos13 = function(navigator2) {
      return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && navigator2.maxTouchPoints > 1 && typeof MSStream === "undefined";
    };
  }
});

// node_modules/ismobilejs/esm/index.js
var init_esm = __esm({
  "node_modules/ismobilejs/esm/index.js"() {
    init_isMobile();
    init_isMobile();
  }
});

// node_modules/pixi.js/lib/utils/browser/isMobile.mjs
var isMobileCall, isMobile2;
var init_isMobile2 = __esm({
  "node_modules/pixi.js/lib/utils/browser/isMobile.mjs"() {
    init_esm();
    isMobileCall = isMobile.default ?? isMobile;
    isMobile2 = isMobileCall(globalThis.navigator);
  }
});

// node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs
var KEY_CODE_TAB, DIV_TOUCH_SIZE, DIV_TOUCH_POS_X, DIV_TOUCH_POS_Y, DIV_TOUCH_ZINDEX, DIV_HOOK_SIZE, DIV_HOOK_POS_X, DIV_HOOK_POS_Y, DIV_HOOK_ZINDEX, AccessibilitySystem;
var init_AccessibilitySystem = __esm({
  "node_modules/pixi.js/lib/accessibility/AccessibilitySystem.mjs"() {
    init_FederatedEvent();
    init_Extensions();
    init_isMobile2();
    init_removeItems();
    KEY_CODE_TAB = 9;
    DIV_TOUCH_SIZE = 100;
    DIV_TOUCH_POS_X = 0;
    DIV_TOUCH_POS_Y = 0;
    DIV_TOUCH_ZINDEX = 2;
    DIV_HOOK_SIZE = 1;
    DIV_HOOK_POS_X = -1e3;
    DIV_HOOK_POS_Y = -1e3;
    DIV_HOOK_ZINDEX = 2;
    AccessibilitySystem = class {
      // 2fps
      // eslint-disable-next-line jsdoc/require-param
      /**
       * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer
       */
      constructor(renderer, _mobileInfo = isMobile2) {
        this._mobileInfo = _mobileInfo;
        this.debug = false;
        this._isActive = false;
        this._isMobileAccessibility = false;
        this._pool = [];
        this._renderId = 0;
        this._children = [];
        this._androidUpdateCount = 0;
        this._androidUpdateFrequency = 500;
        this._hookDiv = null;
        if (_mobileInfo.tablet || _mobileInfo.phone) {
          this._createTouchHook();
        }
        const div = document.createElement("div");
        div.style.width = `${DIV_TOUCH_SIZE}px`;
        div.style.height = `${DIV_TOUCH_SIZE}px`;
        div.style.position = "absolute";
        div.style.top = `${DIV_TOUCH_POS_X}px`;
        div.style.left = `${DIV_TOUCH_POS_Y}px`;
        div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
        this._div = div;
        this._renderer = renderer;
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onMouseMove = this._onMouseMove.bind(this);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
      }
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get isActive() {
        return this._isActive;
      }
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      /**
       * Creates the touch hooks.
       * @private
       */
      _createTouchHook() {
        const hookDiv = document.createElement("button");
        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;
        hookDiv.style.position = "absolute";
        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;
        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;
        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = "#FF0000";
        hookDiv.title = "select to enable accessibility for this content";
        hookDiv.addEventListener("focus", () => {
          this._isMobileAccessibility = true;
          this._activate();
          this._destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
      }
      /**
       * Destroys the touch hooks.
       * @private
       */
      _destroyTouchHook() {
        if (!this._hookDiv) {
          return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
      }
      /**
       * Activating will cause the Accessibility layer to be shown.
       * This is called when a user presses the tab key.
       * @private
       */
      _activate() {
        if (this._isActive) {
          return;
        }
        this._isActive = true;
        globalThis.document.addEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.add(this);
        this._renderer.view.canvas.parentNode?.appendChild(this._div);
      }
      /**
       * Deactivating will cause the Accessibility layer to be hidden.
       * This is called when a user moves the mouse.
       * @private
       */
      _deactivate() {
        if (!this._isActive || this._isMobileAccessibility) {
          return;
        }
        this._isActive = false;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.addEventListener("keydown", this._onKeyDown, false);
        this._renderer.runners.postrender.remove(this);
        this._div.parentNode?.removeChild(this._div);
      }
      /**
       * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
       * @private
       * @param {Container} container - The Container to check.
       */
      _updateAccessibleObjects(container) {
        if (!container.visible || !container.accessibleChildren) {
          return;
        }
        if (container.accessible && container.isInteractive()) {
          if (!container._accessibleActive) {
            this._addChild(container);
          }
          container._renderId = this._renderId;
        }
        const children2 = container.children;
        if (children2) {
          for (let i2 = 0; i2 < children2.length; i2++) {
            this._updateAccessibleObjects(children2[i2]);
          }
        }
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        this.debug = options?.debug ?? this.debug;
        this._renderer.runners.postrender.remove(this);
      }
      /**
       * Runner postrender was called, ensure that all divs are mapped correctly to their Containers.
       * Only fires while active.
       * @ignore
       */
      postrender() {
        const now2 = performance.now();
        if (this._mobileInfo.android.device && now2 < this._androidUpdateCount) {
          return;
        }
        this._androidUpdateCount = now2 + this._androidUpdateFrequency;
        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas) {
          return;
        }
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
        }
        const { x: x5, y: y4, width, height } = this._renderer.view.canvas.getBoundingClientRect();
        const { width: viewWidth, height: viewHeight, resolution } = this._renderer;
        const sx = width / viewWidth * resolution;
        const sy = height / viewHeight * resolution;
        let div = this._div;
        div.style.left = `${x5}px`;
        div.style.top = `${y4}px`;
        div.style.width = `${viewWidth}px`;
        div.style.height = `${viewHeight}px`;
        for (let i2 = 0; i2 < this._children.length; i2++) {
          const child = this._children[i2];
          if (child._renderId !== this._renderId) {
            child._accessibleActive = false;
            removeItems(this._children, i2, 1);
            this._div.removeChild(child._accessibleDiv);
            this._pool.push(child._accessibleDiv);
            child._accessibleDiv = null;
            i2--;
          } else {
            div = child._accessibleDiv;
            let hitArea = child.hitArea;
            const wt = child.worldTransform;
            if (child.hitArea) {
              div.style.left = `${(wt.tx + hitArea.x * wt.a) * sx}px`;
              div.style.top = `${(wt.ty + hitArea.y * wt.d) * sy}px`;
              div.style.width = `${hitArea.width * wt.a * sx}px`;
              div.style.height = `${hitArea.height * wt.d * sy}px`;
            } else {
              hitArea = child.getBounds().rectangle;
              this._capHitArea(hitArea);
              div.style.left = `${hitArea.x * sx}px`;
              div.style.top = `${hitArea.y * sy}px`;
              div.style.width = `${hitArea.width * sx}px`;
              div.style.height = `${hitArea.height * sy}px`;
              if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                div.title = child.accessibleTitle || "";
              }
              if (div.getAttribute("aria-label") !== child.accessibleHint && child.accessibleHint !== null) {
                div.setAttribute("aria-label", child.accessibleHint || "");
              }
            }
            if (child.accessibleTitle !== div.title || child.tabIndex !== div.tabIndex) {
              div.title = child.accessibleTitle || "";
              div.tabIndex = child.tabIndex;
              if (this.debug) {
                this._updateDebugHTML(div);
              }
            }
          }
        }
        this._renderId++;
      }
      /**
       * private function that will visually add the information to the
       * accessibility div
       * @param {HTMLElement} div -
       */
      _updateDebugHTML(div) {
        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;
      }
      /**
       * Adjust the hit area based on the bounds of a display object
       * @param {Rectangle} hitArea - Bounds of the child
       */
      _capHitArea(hitArea) {
        if (hitArea.x < 0) {
          hitArea.width += hitArea.x;
          hitArea.x = 0;
        }
        if (hitArea.y < 0) {
          hitArea.height += hitArea.y;
          hitArea.y = 0;
        }
        const { width: viewWidth, height: viewHeight } = this._renderer;
        if (hitArea.x + hitArea.width > viewWidth) {
          hitArea.width = viewWidth - hitArea.x;
        }
        if (hitArea.y + hitArea.height > viewHeight) {
          hitArea.height = viewHeight - hitArea.y;
        }
      }
      /**
       * Adds a Container to the accessibility manager
       * @private
       * @param {Container} container - The child to make accessible.
       */
      _addChild(container) {
        let div = this._pool.pop();
        if (!div) {
          div = document.createElement("button");
          div.style.width = `${DIV_TOUCH_SIZE}px`;
          div.style.height = `${DIV_TOUCH_SIZE}px`;
          div.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent";
          div.style.position = "absolute";
          div.style.zIndex = DIV_TOUCH_ZINDEX.toString();
          div.style.borderStyle = "none";
          if (navigator.userAgent.toLowerCase().includes("chrome")) {
            div.setAttribute("aria-live", "off");
          } else {
            div.setAttribute("aria-live", "polite");
          }
          if (navigator.userAgent.match(/rv:.*Gecko\//)) {
            div.setAttribute("aria-relevant", "additions");
          } else {
            div.setAttribute("aria-relevant", "text");
          }
          div.addEventListener("click", this._onClick.bind(this));
          div.addEventListener("focus", this._onFocus.bind(this));
          div.addEventListener("focusout", this._onFocusOut.bind(this));
        }
        div.style.pointerEvents = container.accessiblePointerEvents;
        div.type = container.accessibleType;
        if (container.accessibleTitle && container.accessibleTitle !== null) {
          div.title = container.accessibleTitle;
        } else if (!container.accessibleHint || container.accessibleHint === null) {
          div.title = `container ${container.tabIndex}`;
        }
        if (container.accessibleHint && container.accessibleHint !== null) {
          div.setAttribute("aria-label", container.accessibleHint);
        }
        if (this.debug) {
          this._updateDebugHTML(div);
        }
        container._accessibleActive = true;
        container._accessibleDiv = div;
        div.container = container;
        this._children.push(container);
        this._div.appendChild(container._accessibleDiv);
        container._accessibleDiv.tabIndex = container.tabIndex;
      }
      /**
       * Dispatch events with the EventSystem.
       * @param e
       * @param type
       * @private
       */
      _dispatchEvent(e3, type2) {
        const { container: target } = e3.target;
        const boundary = this._renderer.events.rootBoundary;
        const event = Object.assign(new FederatedEvent(boundary), { target });
        boundary.rootTarget = this._renderer.lastObjectRendered;
        type2.forEach((type22) => boundary.dispatchEvent(event, type22));
      }
      /**
       * Maps the div button press to pixi's EventSystem (click)
       * @private
       * @param {MouseEvent} e - The click event.
       */
      _onClick(e3) {
        this._dispatchEvent(e3, ["click", "pointertap", "tap"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseover)
       * @private
       * @param {FocusEvent} e - The focus event.
       */
      _onFocus(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "assertive");
        }
        this._dispatchEvent(e3, ["mouseover"]);
      }
      /**
       * Maps the div focus events to pixi's EventSystem (mouseout)
       * @private
       * @param {FocusEvent} e - The focusout event.
       */
      _onFocusOut(e3) {
        if (!e3.target.getAttribute("aria-live")) {
          e3.target.setAttribute("aria-live", "polite");
        }
        this._dispatchEvent(e3, ["mouseout"]);
      }
      /**
       * Is called when a key is pressed
       * @private
       * @param {KeyboardEvent} e - The keydown event.
       */
      _onKeyDown(e3) {
        if (e3.keyCode !== KEY_CODE_TAB) {
          return;
        }
        this._activate();
      }
      /**
       * Is called when the mouse moves across the renderer element
       * @private
       * @param {MouseEvent} e - The mouse event.
       */
      _onMouseMove(e3) {
        if (e3.movementX === 0 && e3.movementY === 0) {
          return;
        }
        this._deactivate();
      }
      /** Destroys the accessibility manager */
      destroy() {
        this._destroyTouchHook();
        this._div = null;
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, true);
        globalThis.removeEventListener("keydown", this._onKeyDown);
        this._pool = null;
        this._children = null;
        this._renderer = null;
      }
    };
    AccessibilitySystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "accessibility"
    };
  }
});

// node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs
var accessibilityTarget;
var init_accessibilityTarget = __esm({
  "node_modules/pixi.js/lib/accessibility/accessibilityTarget.mjs"() {
    "use strict";
    accessibilityTarget = {
      /**
       * Flag for if the object is accessible. If true AccessibilityManager will overlay a
       * shadow div with attributes set
       * @member {boolean}
       * @memberof scene.Container#
       */
      accessible: false,
      /**
       * Sets the title attribute of the shadow div
       * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'
       * @member {string}
       * @memberof scene.Container#
       */
      accessibleTitle: null,
      /**
       * Sets the aria-label attribute of the shadow div
       * @member {string}
       * @memberof scene.Container#
       */
      accessibleHint: null,
      /**
       * @member {number}
       * @memberof scene.Container#
       * @todo Needs docs.
       */
      tabIndex: 0,
      /**
       * @member {boolean}
       * @memberof scene.Container#
       * @private
       */
      _accessibleActive: false,
      /**
       * @memberof scene.Container#
       * @private
       */
      _accessibleDiv: null,
      /**
       * Specify the type of div the accessible layer is. Screen readers treat the element differently
       * depending on this type. Defaults to button.
       * @member {string}
       * @memberof scene.Container#
       * @default 'button'
       */
      accessibleType: "button",
      /**
       * Specify the pointer-events the accessible div will use
       * Defaults to auto.
       * @type {PointerEvents}
       * @memberof scene.Container#
       * @default 'auto'
       */
      accessiblePointerEvents: "auto",
      /**
       * Setting to false will prevent any children inside this container to
       * be accessible. Defaults to true.
       * @member {boolean}
       * @memberof scene.Container#
       * @default true
       */
      accessibleChildren: true,
      /**
       * @member {number}
       * @memberof scene.Container#
       * @private
       */
      _renderId: -1
    };
  }
});

// node_modules/pixi.js/lib/accessibility/init.mjs
var init_init = __esm({
  "node_modules/pixi.js/lib/accessibility/init.mjs"() {
    init_Extensions();
    init_Container();
    init_AccessibilitySystem();
    init_accessibilityTarget();
    extensions.add(AccessibilitySystem);
    Container.mixin(accessibilityTarget);
  }
});

// node_modules/pixi.js/lib/app/ResizePlugin.mjs
var ResizePlugin;
var init_ResizePlugin = __esm({
  "node_modules/pixi.js/lib/app/ResizePlugin.mjs"() {
    init_Extensions();
    ResizePlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        Object.defineProperty(
          this,
          "resizeTo",
          /**
           * The HTML element or window to automatically resize the
           * renderer's view element to match width and height.
           * @member {Window|HTMLElement}
           * @name resizeTo
           * @memberof app.Application#
           */
          {
            set(dom) {
              globalThis.removeEventListener("resize", this.queueResize);
              this._resizeTo = dom;
              if (dom) {
                globalThis.addEventListener("resize", this.queueResize);
                this.resize();
              }
            },
            get() {
              return this._resizeTo;
            }
          }
        );
        this.queueResize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          this._resizeId = requestAnimationFrame(() => this.resize());
        };
        this._cancelResize = () => {
          if (this._resizeId) {
            cancelAnimationFrame(this._resizeId);
            this._resizeId = null;
          }
        };
        this.resize = () => {
          if (!this._resizeTo) {
            return;
          }
          this._cancelResize();
          let width;
          let height;
          if (this._resizeTo === globalThis.window) {
            width = globalThis.innerWidth;
            height = globalThis.innerHeight;
          } else {
            const { clientWidth, clientHeight } = this._resizeTo;
            width = clientWidth;
            height = clientHeight;
          }
          this.renderer.resize(width, height);
          this.render();
        };
        this._resizeId = null;
        this._resizeTo = null;
        this.resizeTo = options.resizeTo || null;
      }
      /**
       * Clean up the ticker, scoped to application
       * @static
       * @private
       */
      static destroy() {
        globalThis.removeEventListener("resize", this.queueResize);
        this._cancelResize();
        this._cancelResize = null;
        this.queueResize = null;
        this.resizeTo = null;
        this.resize = null;
      }
    };
    ResizePlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/ticker/const.mjs
var UPDATE_PRIORITY;
var init_const2 = __esm({
  "node_modules/pixi.js/lib/ticker/const.mjs"() {
    "use strict";
    UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
      UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
      return UPDATE_PRIORITY2;
    })(UPDATE_PRIORITY || {});
  }
});

// node_modules/pixi.js/lib/ticker/TickerListener.mjs
var TickerListener;
var init_TickerListener = __esm({
  "node_modules/pixi.js/lib/ticker/TickerListener.mjs"() {
    "use strict";
    TickerListener = class {
      /**
       * Constructor
       * @private
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param priority - The priority for emitting
       * @param once - If the handler should fire once
       */
      constructor(fn, context2 = null, priority = 0, once = false) {
        this.next = null;
        this.previous = null;
        this._destroyed = false;
        this._fn = fn;
        this._context = context2;
        this.priority = priority;
        this._once = once;
      }
      /**
       * Simple compare function to figure out if a function and context match.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @returns `true` if the listener match the arguments
       */
      match(fn, context2 = null) {
        return this._fn === fn && this._context === context2;
      }
      /**
       * Emit by calling the current function.
       * @param ticker - The ticker emitting.
       * @returns Next ticker
       */
      emit(ticker2) {
        if (this._fn) {
          if (this._context) {
            this._fn.call(this._context, ticker2);
          } else {
            this._fn(ticker2);
          }
        }
        const redirect = this.next;
        if (this._once) {
          this.destroy(true);
        }
        if (this._destroyed) {
          this.next = null;
        }
        return redirect;
      }
      /**
       * Connect to the list.
       * @param previous - Input node, previous listener
       */
      connect(previous) {
        this.previous = previous;
        if (previous.next) {
          previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
      }
      /**
       * Destroy and don't use after this.
       * @param hard - `true` to remove the `next` reference, this
       *        is considered a hard destroy. Soft destroy maintains the next reference.
       * @returns The listener to redirect while emitting or removing.
       */
      destroy(hard = false) {
        this._destroyed = true;
        this._fn = null;
        this._context = null;
        if (this.previous) {
          this.previous.next = this.next;
        }
        if (this.next) {
          this.next.previous = this.previous;
        }
        const redirect = this.next;
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
      }
    };
  }
});

// node_modules/pixi.js/lib/ticker/Ticker.mjs
var _Ticker, Ticker;
var init_Ticker = __esm({
  "node_modules/pixi.js/lib/ticker/Ticker.mjs"() {
    init_const2();
    init_TickerListener();
    _Ticker = class _Ticker2 {
      constructor() {
        this.autoStart = false;
        this.deltaTime = 1;
        this.lastTime = -1;
        this.speed = 1;
        this.started = false;
        this._requestId = null;
        this._maxElapsedMS = 100;
        this._minElapsedMS = 0;
        this._protected = false;
        this._lastFrame = -1;
        this._head = new TickerListener(null, null, Infinity);
        this.deltaMS = 1 / _Ticker2.targetFPMS;
        this.elapsedMS = 1 / _Ticker2.targetFPMS;
        this._tick = (time) => {
          this._requestId = null;
          if (this.started) {
            this.update(time);
            if (this.started && this._requestId === null && this._head.next) {
              this._requestId = requestAnimationFrame(this._tick);
            }
          }
        };
      }
      /**
       * Conditionally requests a new animation frame.
       * If a frame has not already been requested, and if the internal
       * emitter has listeners, a new frame is requested.
       * @private
       */
      _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
          this.lastTime = performance.now();
          this._lastFrame = this.lastTime;
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
      /**
       * Conditionally cancels a pending animation frame.
       * @private
       */
      _cancelIfNeeded() {
        if (this._requestId !== null) {
          cancelAnimationFrame(this._requestId);
          this._requestId = null;
        }
      }
      /**
       * Conditionally requests a new animation frame.
       * If the ticker has been started it checks if a frame has not already
       * been requested, and if the internal emitter has listeners. If these
       * conditions are met, a new frame is requested. If the ticker has not
       * been started, but autoStart is `true`, then the ticker starts now,
       * and continues with the previous conditions to request a new frame.
       * @private
       */
      _startIfPossible() {
        if (this.started) {
          this._requestIfNeeded();
        } else if (this.autoStart) {
          this.start();
        }
      }
      /**
       * Register a handler for tick events. Calls continuously unless
       * it is removed or the ticker is stopped.
       * @param fn - The listener function to be added for updates
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority));
      }
      /**
       * Add a handler for the tick event which is only execute once.
       * @param fn - The listener function to be added for one update
       * @param context - The listener context
       * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting
       * @returns This instance of a ticker
       */
      addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
        return this._addListener(new TickerListener(fn, context2, priority, true));
      }
      /**
       * Internally adds the event handler so that it can be sorted by priority.
       * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
       * before the rendering.
       * @private
       * @param listener - Current listener being added.
       * @returns This instance of a ticker
       */
      _addListener(listener) {
        let current = this._head.next;
        let previous = this._head;
        if (!current) {
          listener.connect(previous);
        } else {
          while (current) {
            if (listener.priority > current.priority) {
              listener.connect(previous);
              break;
            }
            previous = current;
            current = current.next;
          }
          if (!listener.previous) {
            listener.connect(previous);
          }
        }
        this._startIfPossible();
        return this;
      }
      /**
       * Removes any handlers matching the function and context parameters.
       * If no handlers are left after removing, then it cancels the animation frame.
       * @param fn - The listener function to be removed
       * @param context - The listener context to be removed
       * @returns This instance of a ticker
       */
      remove(fn, context2) {
        let listener = this._head.next;
        while (listener) {
          if (listener.match(fn, context2)) {
            listener = listener.destroy();
          } else {
            listener = listener.next;
          }
        }
        if (!this._head.next) {
          this._cancelIfNeeded();
        }
        return this;
      }
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get count() {
        if (!this._head) {
          return 0;
        }
        let count2 = 0;
        let current = this._head;
        while (current = current.next) {
          count2++;
        }
        return count2;
      }
      /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */
      start() {
        if (!this.started) {
          this.started = true;
          this._requestIfNeeded();
        }
      }
      /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */
      stop() {
        if (this.started) {
          this.started = false;
          this._cancelIfNeeded();
        }
      }
      /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */
      destroy() {
        if (!this._protected) {
          this.stop();
          let listener = this._head.next;
          while (listener) {
            listener = listener.destroy(true);
          }
          this._head.destroy();
          this._head = null;
        }
      }
      /**
       * Triggers an update. An update entails setting the
       * current {@link ticker.Ticker#elapsedMS|elapsedMS},
       * the current {@link ticker.Ticker#deltaTime|deltaTime},
       * invoking all listeners with current deltaTime,
       * and then finally setting {@link ticker.Ticker#lastTime|lastTime}
       * with the value of currentTime that was provided.
       * This method will be called automatically by animation
       * frame callbacks if the ticker instance has been started
       * and listeners are added.
       * @param {number} [currentTime=performance.now()] - the current time of execution
       */
      update(currentTime = performance.now()) {
        let elapsedMS;
        if (currentTime > this.lastTime) {
          elapsedMS = this.elapsedMS = currentTime - this.lastTime;
          if (elapsedMS > this._maxElapsedMS) {
            elapsedMS = this._maxElapsedMS;
          }
          elapsedMS *= this.speed;
          if (this._minElapsedMS) {
            const delta = currentTime - this._lastFrame | 0;
            if (delta < this._minElapsedMS) {
              return;
            }
            this._lastFrame = currentTime - delta % this._minElapsedMS;
          }
          this.deltaMS = elapsedMS;
          this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
          const head = this._head;
          let listener = head.next;
          while (listener) {
            listener = listener.emit(this);
          }
          if (!head.next) {
            this._cancelIfNeeded();
          }
        } else {
          this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
      }
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link ticker.Ticker#speed|speed}, which is specific
       * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.
       * @member {number}
       * @readonly
       */
      get FPS() {
        return 1e3 / this.elapsedMS;
      }
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link ticker.Ticker#update|update}.
       * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},
       * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `Ticker.targetFPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get minFPS() {
        return 1e3 / this._maxElapsedMS;
      }
      set minFPS(fps) {
        const minFPS = Math.min(this.maxFPS, fps);
        const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
        this._maxElapsedMS = 1 / minFPMS;
      }
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link ticker.Ticker#update|update}.
       * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get maxFPS() {
        if (this._minElapsedMS) {
          return Math.round(1e3 / this._minElapsedMS);
        }
        return 0;
      }
      set maxFPS(fps) {
        if (fps === 0) {
          this._minElapsedMS = 0;
        } else {
          const maxFPS = Math.max(this.minFPS, fps);
          this._minElapsedMS = 1 / (maxFPS / 1e3);
        }
      }
      /**
       * The shared ticker instance used by {@link AnimatedSprite} and by
       * {@link VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * import { Ticker } from 'pixi.js';
       *
       * const ticker = Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the Ticker.shared instance.
       * ticker.autoStart = false;
       *
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       *
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * import { autoDetectRenderer, Container } from 'pixi.js';
       *
       * // You may use the shared ticker to render...
       * const renderer = autoDetectRenderer();
       * const stage = new Container();
       * document.body.appendChild(renderer.view);
       * ticker.add((time) => renderer.render(stage));
       *
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * const animate = (time) => {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * };
       * animate(performance.now());
       * @member {ticker.Ticker}
       * @readonly
       * @static
       */
      static get shared() {
        if (!_Ticker2._shared) {
          const shared = _Ticker2._shared = new _Ticker2();
          shared.autoStart = true;
          shared._protected = true;
        }
        return _Ticker2._shared;
      }
      /**
       * The system ticker instance used by {@link BasePrepare} for core timing
       * functionality that shouldn't usually need to be paused, unlike the `shared`
       * ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.
       * @member {ticker.Ticker}
       * @readonly
       * @static
       */
      static get system() {
        if (!_Ticker2._system) {
          const system = _Ticker2._system = new _Ticker2();
          system.autoStart = true;
          system._protected = true;
        }
        return _Ticker2._system;
      }
    };
    _Ticker.targetFPMS = 0.06;
    Ticker = _Ticker;
  }
});

// node_modules/pixi.js/lib/app/TickerPlugin.mjs
var TickerPlugin;
var init_TickerPlugin = __esm({
  "node_modules/pixi.js/lib/app/TickerPlugin.mjs"() {
    init_Extensions();
    init_const2();
    init_Ticker();
    TickerPlugin = class {
      /**
       * Initialize the plugin with scope of application instance
       * @static
       * @private
       * @param {object} [options] - See application options
       */
      static init(options) {
        options = Object.assign({
          autoStart: true,
          sharedTicker: false
        }, options);
        Object.defineProperty(
          this,
          "ticker",
          {
            set(ticker2) {
              if (this._ticker) {
                this._ticker.remove(this.render, this);
              }
              this._ticker = ticker2;
              if (ticker2) {
                ticker2.add(this.render, this, UPDATE_PRIORITY.LOW);
              }
            },
            get() {
              return this._ticker;
            }
          }
        );
        this.stop = () => {
          this._ticker.stop();
        };
        this.start = () => {
          this._ticker.start();
        };
        this._ticker = null;
        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();
        if (options.autoStart) {
          this.start();
        }
      }
      /**
       * Clean up the ticker, scoped to application.
       * @static
       * @private
       */
      static destroy() {
        if (this._ticker) {
          const oldTicker = this._ticker;
          this.ticker = null;
          oldTicker.destroy();
        }
      }
    };
    TickerPlugin.extension = ExtensionType.Application;
  }
});

// node_modules/pixi.js/lib/app/init.mjs
var init_init2 = __esm({
  "node_modules/pixi.js/lib/app/init.mjs"() {
    init_Extensions();
    init_ResizePlugin();
    init_TickerPlugin();
    extensions.add(ResizePlugin);
    extensions.add(TickerPlugin);
  }
});

// node_modules/pixi.js/lib/events/EventTicker.mjs
var EventsTickerClass, EventsTicker;
var init_EventTicker = __esm({
  "node_modules/pixi.js/lib/events/EventTicker.mjs"() {
    init_const2();
    init_Ticker();
    EventsTickerClass = class {
      constructor() {
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /**
       * Initializes the event ticker.
       * @param events - The event system.
       */
      init(events) {
        this.removeTickerListener();
        this.events = events;
        this.interactionFrequency = 10;
        this._deltaTime = 0;
        this._didMove = false;
        this._tickerAdded = false;
        this._pauseUpdate = true;
      }
      /** Whether to pause the update checks or not. */
      get pauseUpdate() {
        return this._pauseUpdate;
      }
      set pauseUpdate(paused) {
        this._pauseUpdate = paused;
      }
      /** Adds the ticker listener. */
      addTickerListener() {
        if (this._tickerAdded || !this.domElement) {
          return;
        }
        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);
        this._tickerAdded = true;
      }
      /** Removes the ticker listener. */
      removeTickerListener() {
        if (!this._tickerAdded) {
          return;
        }
        Ticker.system.remove(this._tickerUpdate, this);
        this._tickerAdded = false;
      }
      /** Sets flag to not fire extra events when the user has already moved there mouse */
      pointerMoved() {
        this._didMove = true;
      }
      /** Updates the state of interactive objects. */
      _update() {
        if (!this.domElement || this._pauseUpdate) {
          return;
        }
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        const rootPointerEvent = this.events["_rootPointerEvent"];
        if (this.events.supportsTouchEvents && rootPointerEvent.pointerType === "touch") {
          return;
        }
        globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
          clientX: rootPointerEvent.clientX,
          clientY: rootPointerEvent.clientY,
          pointerType: rootPointerEvent.pointerType,
          pointerId: rootPointerEvent.pointerId
        }));
      }
      /**
       * Updates the state of interactive objects if at least {@link interactionFrequency}
       * milliseconds have passed since the last invocation.
       *
       * Invoked by a throttled ticker update from {@link Ticker.system}.
       * @param ticker - The throttled ticker.
       */
      _tickerUpdate(ticker2) {
        this._deltaTime += ticker2.deltaTime;
        if (this._deltaTime < this.interactionFrequency) {
          return;
        }
        this._deltaTime = 0;
        this._update();
      }
    };
    EventsTicker = new EventsTickerClass();
  }
});

// node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs
var FederatedMouseEvent;
var init_FederatedMouseEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedMouseEvent.mjs"() {
    init_Point();
    init_FederatedEvent();
    FederatedMouseEvent = class extends FederatedEvent {
      constructor() {
        super(...arguments);
        this.client = new Point();
        this.movement = new Point();
        this.offset = new Point();
        this.global = new Point();
        this.screen = new Point();
      }
      /** @readonly */
      get clientX() {
        return this.client.x;
      }
      /** @readonly */
      get clientY() {
        return this.client.y;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientX this.clientX}.
       * @readonly
       */
      get x() {
        return this.clientX;
      }
      /**
       * Alias for {@link FederatedMouseEvent.clientY this.clientY}.
       * @readonly
       */
      get y() {
        return this.clientY;
      }
      /** @readonly */
      get movementX() {
        return this.movement.x;
      }
      /** @readonly */
      get movementY() {
        return this.movement.y;
      }
      /** @readonly */
      get offsetX() {
        return this.offset.x;
      }
      /** @readonly */
      get offsetY() {
        return this.offset.y;
      }
      /** @readonly */
      get globalX() {
        return this.global.x;
      }
      /** @readonly */
      get globalY() {
        return this.global.y;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.
       * @readonly
       */
      get screenX() {
        return this.screen.x;
      }
      /**
       * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.
       * @readonly
       */
      get screenY() {
        return this.screen.y;
      }
      /**
       * This will return the local coordinates of the specified container for this InteractionData
       * @param {Container} container - The Container that you would like the local
       *  coords off
       * @param {PointData} point - A Point object in which to store the value, optional (otherwise
       *  will create a new point)
       * @param {PointData} globalPos - A Point object containing your custom global coords, optional
       *  (otherwise will use the current global coords)
       * @returns - A point containing the coordinates of the InteractionData position relative
       *  to the Container
       */
      getLocalPosition(container, point, globalPos) {
        return container.worldTransform.applyInverse(globalPos || this.global, point);
      }
      /**
       * Whether the modifier key was pressed when this event natively occurred.
       * @param key - The modifier key.
       */
      getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
      /**
       * Not supported.
       * @param _typeArg
       * @param _canBubbleArg
       * @param _cancelableArg
       * @param _viewArg
       * @param _detailArg
       * @param _screenXArg
       * @param _screenYArg
       * @param _clientXArg
       * @param _clientYArg
       * @param _ctrlKeyArg
       * @param _altKeyArg
       * @param _shiftKeyArg
       * @param _metaKeyArg
       * @param _buttonArg
       * @param _relatedTargetArg
       * @deprecated since 7.0.0
       */
      // eslint-disable-next-line max-params
      initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
        throw new Error("Method not implemented.");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs
var FederatedPointerEvent;
var init_FederatedPointerEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedPointerEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedPointerEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.width = 0;
        this.height = 0;
        this.isPrimary = false;
      }
      // Only included for completeness for now
      getCoalescedEvents() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      }
      // Only included for completeness for now
      getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
    };
  }
});

// node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs
var FederatedWheelEvent;
var init_FederatedWheelEvent = __esm({
  "node_modules/pixi.js/lib/events/FederatedWheelEvent.mjs"() {
    init_FederatedMouseEvent();
    FederatedWheelEvent = class extends FederatedMouseEvent {
      constructor() {
        super(...arguments);
        this.DOM_DELTA_PIXEL = 0;
        this.DOM_DELTA_LINE = 1;
        this.DOM_DELTA_PAGE = 2;
      }
    };
    FederatedWheelEvent.DOM_DELTA_PIXEL = 0;
    FederatedWheelEvent.DOM_DELTA_LINE = 1;
    FederatedWheelEvent.DOM_DELTA_PAGE = 2;
  }
});

// node_modules/pixi.js/lib/events/EventBoundary.mjs
var PROPAGATION_LIMIT, tempHitLocation, tempLocalMapping, EventBoundary;
var init_EventBoundary = __esm({
  "node_modules/pixi.js/lib/events/EventBoundary.mjs"() {
    init_eventemitter3();
    init_Point();
    init_warn();
    init_EventTicker();
    init_FederatedMouseEvent();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    PROPAGATION_LIMIT = 2048;
    tempHitLocation = new Point();
    tempLocalMapping = new Point();
    EventBoundary = class {
      /**
       * @param rootTarget - The holder of the event boundary.
       */
      constructor(rootTarget) {
        this.dispatch = new eventemitter3_default();
        this.moveOnAll = false;
        this.enableGlobalMoveEvents = true;
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this._allInteractiveElements = [];
        this._hitElements = [];
        this._isPointerMoveEvent = false;
        this.rootTarget = rootTarget;
        this.hitPruneFn = this.hitPruneFn.bind(this);
        this.hitTestFn = this.hitTestFn.bind(this);
        this.mapPointerDown = this.mapPointerDown.bind(this);
        this.mapPointerMove = this.mapPointerMove.bind(this);
        this.mapPointerOut = this.mapPointerOut.bind(this);
        this.mapPointerOver = this.mapPointerOver.bind(this);
        this.mapPointerUp = this.mapPointerUp.bind(this);
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
        this.mapWheel = this.mapWheel.bind(this);
        this.mappingTable = {};
        this.addEventMapping("pointerdown", this.mapPointerDown);
        this.addEventMapping("pointermove", this.mapPointerMove);
        this.addEventMapping("pointerout", this.mapPointerOut);
        this.addEventMapping("pointerleave", this.mapPointerOut);
        this.addEventMapping("pointerover", this.mapPointerOver);
        this.addEventMapping("pointerup", this.mapPointerUp);
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
        this.addEventMapping("wheel", this.mapWheel);
      }
      /**
       * Adds an event mapping for the event `type` handled by `fn`.
       *
       * Event mappings can be used to implement additional or custom events. They take an event
       * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events
       * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.
       *
       * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden
       * instead.
       * @param type - The type of upstream event to map.
       * @param fn - The mapping method. The context of this function must be bound manually, if desired.
       */
      addEventMapping(type2, fn) {
        if (!this.mappingTable[type2]) {
          this.mappingTable[type2] = [];
        }
        this.mappingTable[type2].push({
          fn,
          priority: 0
        });
        this.mappingTable[type2].sort((a3, b2) => a3.priority - b2.priority);
      }
      /**
       * Dispatches the given event
       * @param e - The event to dispatch.
       * @param type - The type of event to dispatch. Defaults to `e.type`.
       */
      dispatchEvent(e3, type2) {
        e3.propagationStopped = false;
        e3.propagationImmediatelyStopped = false;
        this.propagate(e3, type2);
        this.dispatch.emit(type2 || e3.type, e3);
      }
      /**
       * Maps the given upstream event through the event boundary and propagates it downstream.
       * @param e - The event to map.
       */
      mapEvent(e3) {
        if (!this.rootTarget) {
          return;
        }
        const mappers = this.mappingTable[e3.type];
        if (mappers) {
          for (let i2 = 0, j3 = mappers.length; i2 < j3; i2++) {
            mappers[i2].fn(e3);
          }
        } else {
          warn(`[EventBoundary]: Event mapping not defined for ${e3.type}`);
        }
      }
      /**
       * Finds the Container that is the target of a event at the given coordinates.
       *
       * The passed (x,y) coordinates are in the world space above this event boundary.
       * @param x - The x coordinate of the event.
       * @param y - The y coordinate of the event.
       */
      hitTest(x5, y4) {
        EventsTicker.pauseUpdate = true;
        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;
        const fn = useMove ? "hitTestMoveRecursive" : "hitTestRecursive";
        const invertedPath = this[fn](
          this.rootTarget,
          this.rootTarget.eventMode,
          tempHitLocation.set(x5, y4),
          this.hitTestFn,
          this.hitPruneFn
        );
        return invertedPath && invertedPath[0];
      }
      /**
       * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its
       * target {@code e.target}.
       * @param e - The event to propagate.
       * @param type - The type of event to propagate. Defaults to `e.type`.
       */
      propagate(e3, type2) {
        if (!e3.target) {
          return;
        }
        const composedPath = e3.composedPath();
        e3.eventPhase = e3.CAPTURING_PHASE;
        for (let i2 = 0, j3 = composedPath.length - 1; i2 < j3; i2++) {
          e3.currentTarget = composedPath[i2];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
        e3.eventPhase = e3.AT_TARGET;
        e3.currentTarget = e3.target;
        this.notifyTarget(e3, type2);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        for (let i2 = composedPath.length - 2; i2 >= 0; i2--) {
          e3.currentTarget = composedPath[i2];
          this.notifyTarget(e3, type2);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
      }
      /**
       * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.
       *
       * This is used in the `globalpointermove` event.
       * @param e - The emitted event.
       * @param type - The listeners to notify.
       * @param targets - The targets to notify.
       */
      all(e3, type2, targets = this._allInteractiveElements) {
        if (targets.length === 0)
          return;
        e3.eventPhase = e3.BUBBLING_PHASE;
        const events = Array.isArray(type2) ? type2 : [type2];
        for (let i2 = targets.length - 1; i2 >= 0; i2--) {
          events.forEach((event) => {
            e3.currentTarget = targets[i2];
            this.notifyTarget(e3, event);
          });
        }
      }
      /**
       * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed
       * {@code target}. The last element in the path is {@code target}.
       * @param target - The target to find the propagation path to.
       */
      propagationPath(target) {
        const propagationPath = [target];
        for (let i2 = 0; i2 < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i2++) {
          if (!target.parent) {
            throw new Error("Cannot find propagation path to disconnected target");
          }
          propagationPath.push(target.parent);
          target = target.parent;
        }
        propagationPath.reverse();
        return propagationPath;
      }
      hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {
        let shouldReturn = false;
        if (this._interactivePrune(currentTarget))
          return null;
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children2 = currentTarget.children;
          for (let i2 = children2.length - 1; i2 >= 0; i2--) {
            const child = children2[i2];
            const nestedHit = this.hitTestMoveRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              location,
              testFn,
              pruneFn,
              ignore || pruneFn(currentTarget, location)
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive) {
                if (isInteractive)
                  this._allInteractiveElements.push(currentTarget);
                nestedHit.push(currentTarget);
              }
              if (this._hitElements.length === 0)
                this._hitElements = nestedHit;
              shouldReturn = true;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveTarget && isInteractiveTarget)
          this._allInteractiveElements.push(currentTarget);
        if (ignore || this._hitElements.length > 0)
          return null;
        if (shouldReturn)
          return this._hitElements;
        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      /**
       * Recursive implementation for {@link EventBoundary.hitTest hitTest}.
       * @param currentTarget - The Container that is to be hit tested.
       * @param eventMode - The event mode for the `currentTarget` or one of its parents.
       * @param location - The location that is being tested for overlap.
       * @param testFn - Callback that determines whether the target passes hit testing. This callback
       *  can assume that `pruneFn` failed to prune the container.
       * @param pruneFn - Callback that determiness whether the target and all of its children
       *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees
       *  of the scene graph.
       * @returns An array holding the hit testing target and all its ancestors in order. The first element
       *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite
       *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.
       */
      hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
          return null;
        }
        if (currentTarget.eventMode === "dynamic" || eventMode === "dynamic") {
          EventsTicker.pauseUpdate = false;
        }
        if (currentTarget.interactiveChildren && currentTarget.children) {
          const children2 = currentTarget.children;
          const relativeLocation = location;
          for (let i2 = children2.length - 1; i2 >= 0; i2--) {
            const child = children2[i2];
            const nestedHit = this.hitTestRecursive(
              child,
              this._isInteractive(eventMode) ? eventMode : child.eventMode,
              relativeLocation,
              testFn,
              pruneFn
            );
            if (nestedHit) {
              if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {
                continue;
              }
              const isInteractive = currentTarget.isInteractive();
              if (nestedHit.length > 0 || isInteractive)
                nestedHit.push(currentTarget);
              return nestedHit;
            }
          }
        }
        const isInteractiveMode = this._isInteractive(eventMode);
        const isInteractiveTarget = currentTarget.isInteractive();
        if (isInteractiveMode && testFn(currentTarget, location)) {
          return isInteractiveTarget ? [currentTarget] : [];
        }
        return null;
      }
      _isInteractive(int) {
        return int === "static" || int === "dynamic";
      }
      _interactivePrune(container) {
        if (!container || !container.visible || !container.renderable || !container.includeInBuild || !container.measurable) {
          return true;
        }
        if (container.eventMode === "none") {
          return true;
        }
        if (container.eventMode === "passive" && !container.interactiveChildren) {
          return true;
        }
        return false;
      }
      /**
       * Checks whether the container or any of its children cannot pass the hit test at all.
       *
       * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}
       * and {@link Container._maskEffect} for pruning.
       * @param container - The container to prune.
       * @param location - The location to test for overlap.
       */
      hitPruneFn(container, location) {
        if (container.hitArea) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {
            return true;
          }
        }
        if (container.effects && container.effects.length) {
          for (let i2 = 0; i2 < container.effects.length; i2++) {
            const effect = container.effects[i2];
            if (effect.containsPoint) {
              const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);
              if (!effectContainsPoint) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the container passes hit testing for the given location.
       * @param container - The container to test.
       * @param location - The location to test for overlap.
       * @returns - Whether `container` passes hit testing for `location`.
       */
      hitTestFn(container, location) {
        if (container.hitArea) {
          return true;
        }
        if (container?.containsPoint) {
          container.worldTransform.applyInverse(location, tempLocalMapping);
          return container.containsPoint(tempLocalMapping);
        }
        return false;
      }
      /**
       * Notify all the listeners to the event's `currentTarget`.
       *
       * If the `currentTarget` contains the property `on<type>`, then it is called here,
       * simulating the behavior from version 6.x and prior.
       * @param e - The event passed to the target.
       * @param type - The type of event to notify. Defaults to `e.type`.
       */
      notifyTarget(e3, type2) {
        if (!e3.currentTarget.isInteractive()) {
          return;
        }
        type2 = type2 ?? e3.type;
        const handlerKey = `on${type2}`;
        e3.currentTarget[handlerKey]?.(e3);
        const key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? `${type2}capture` : type2;
        this._notifyListeners(e3, key);
        if (e3.eventPhase === e3.AT_TARGET) {
          this._notifyListeners(e3, type2);
        }
      }
      /**
       * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.
       *
       * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.
       * @param from - The upstream `pointerdown` event.
       */
      mapPointerDown(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerdown");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchstart");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
        }
        const trackingData = this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.
       *
       * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,
       * `mousemove`, and `touchmove` events are fired as well for specific pointer types.
       * @param from - The upstream `pointermove` event.
       */
      mapPointerMove(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = true;
        const e3 = this.createPointerEvent(from);
        this._isPointerMoveEvent = false;
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        const trackingData = this.trackingData(from.pointerId);
        const outTarget = this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets?.length > 0 && outTarget !== e3.target) {
          const outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          const outEvent = this.createPointerEvent(from, outType, outTarget);
          this.dispatchEvent(outEvent, "pointerout");
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          if (!e3.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              this.notifyTarget(leaveEvent);
              if (isMouse)
                this.notifyTarget(leaveEvent, "mouseleave");
              leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e3.target) {
          const overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          const overEvent = this.clonePointerEvent(e3, overType);
          this.dispatchEvent(overEvent, "pointerover");
          if (isMouse)
            this.dispatchEvent(overEvent, "mouseover");
          let overTargetAncestor = outTarget?.parent;
          while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {
            if (overTargetAncestor === e3.target)
              break;
            overTargetAncestor = overTargetAncestor.parent;
          }
          const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;
          if (didPointerEnter) {
            const enterEvent = this.clonePointerEvent(e3, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {
              enterEvent.currentTarget = enterEvent.target;
              this.notifyTarget(enterEvent);
              if (isMouse)
                this.notifyTarget(enterEvent, "mouseenter");
              enterEvent.target = enterEvent.target.parent;
            }
            this.freeEvent(enterEvent);
          }
          this.freeEvent(overEvent);
        }
        const allMethods = [];
        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;
        this.moveOnAll ? allMethods.push("pointermove") : this.dispatchEvent(e3, "pointermove");
        allowGlobalPointerEvents && allMethods.push("globalpointermove");
        if (e3.pointerType === "touch") {
          this.moveOnAll ? allMethods.splice(1, 0, "touchmove") : this.dispatchEvent(e3, "touchmove");
          allowGlobalPointerEvents && allMethods.push("globaltouchmove");
        }
        if (isMouse) {
          this.moveOnAll ? allMethods.splice(1, 0, "mousemove") : this.dispatchEvent(e3, "mousemove");
          allowGlobalPointerEvents && allMethods.push("globalmousemove");
          this.cursor = e3.target?.cursor;
        }
        if (allMethods.length > 0) {
          this.all(e3, allMethods);
        }
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.
       *
       * The tracking data for the specific pointer gets a new `overTarget`.
       * @param from - The upstream `pointerover` event.
       */
      mapPointerOver(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const e3 = this.createPointerEvent(from);
        const isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        this.dispatchEvent(e3, "pointerover");
        if (isMouse)
          this.dispatchEvent(e3, "mouseover");
        if (e3.pointerType === "mouse")
          this.cursor = e3.target?.cursor;
        const enterEvent = this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {
          enterEvent.currentTarget = enterEvent.target;
          this.notifyTarget(enterEvent);
          if (isMouse)
            this.notifyTarget(enterEvent, "mouseenter");
          enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = e3.composedPath();
        this.freeEvent(e3);
        this.freeEvent(enterEvent);
      }
      /**
       * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.
       *
       * The tracking data for the specific pointer is cleared of a `overTarget`.
       * @param from - The upstream `pointerout` event.
       */
      mapPointerOut(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          const outTarget = this.findMountedTarget(trackingData.overTargets);
          const outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          if (isMouse)
            this.dispatchEvent(outEvent, "mouseout");
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {
            leaveEvent.currentTarget = leaveEvent.target;
            this.notifyTarget(leaveEvent);
            if (isMouse)
              this.notifyTarget(leaveEvent, "mouseleave");
            leaveEvent.target = leaveEvent.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(leaveEvent);
        }
        this.cursor = null;
      }
      /**
       * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,
       * and `click`/`rightclick`/`pointertap` events, in that order.
       *
       * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific
       * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,
       * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for
       * specific pointer types.
       * @param from - The upstream `pointerup` event.
       */
      mapPointerUp(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const now2 = performance.now();
        const e3 = this.createPointerEvent(from);
        this.dispatchEvent(e3, "pointerup");
        if (e3.pointerType === "touch") {
          this.dispatchEvent(e3, "touchend");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          const isRightButton = e3.button === 2;
          this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        let clickTarget = pressTarget;
        if (pressTarget && !e3.composedPath().includes(pressTarget)) {
          let currentTarget = pressTarget;
          while (currentTarget && !e3.composedPath().includes(currentTarget)) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              const isRightButton = e3.button === 2;
              this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          const clickEvent = this.clonePointerEvent(e3, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = null;
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now2
            };
          }
          const clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now2 - clickHistory.timeStamp < 200) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now2;
          clickEvent.detail = clickHistory.clickCount;
          if (clickEvent.pointerType === "mouse") {
            const isRightButton = clickEvent.button === 2;
            this.dispatchEvent(clickEvent, isRightButton ? "rightclick" : "click");
          } else if (clickEvent.pointerType === "touch") {
            this.dispatchEvent(clickEvent, "tap");
          }
          this.dispatchEvent(clickEvent, "pointertap");
          this.freeEvent(clickEvent);
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original
       * `pointerdown` target to `rootTarget`.
       *
       * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the
       * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)
       *
       * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer
       * types. The tracking data for the specific pointer is cleared of a `pressTarget`.
       * @param from - The upstream `pointerupoutside` event.
       */
      mapPointerUpOutside(from) {
        if (!(from instanceof FederatedPointerEvent)) {
          warn("EventBoundary cannot map a non-pointer event as a pointer event");
          return;
        }
        const trackingData = this.trackingData(from.pointerId);
        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        const e3 = this.createPointerEvent(from);
        if (pressTarget) {
          let currentTarget = pressTarget;
          while (currentTarget) {
            e3.currentTarget = currentTarget;
            this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            currentTarget = currentTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e3);
      }
      /**
       * Maps the upstream `wheel` event to a downstream `wheel` event.
       * @param from - The upstream `wheel` event.
       */
      mapWheel(from) {
        if (!(from instanceof FederatedWheelEvent)) {
          warn("EventBoundary cannot map a non-wheel event as a wheel event");
          return;
        }
        const wheelEvent = this.createWheelEvent(from);
        this.dispatchEvent(wheelEvent);
        this.freeEvent(wheelEvent);
      }
      /**
       * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.
       *
       * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`
       * or `pointerover` target was unmounted from the scene graph.
       * @param propagationPath - The propagation path was valid in the past.
       * @returns - The most specific event-target still mounted at the same location in the scene graph.
       */
      findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        let currentTarget = propagationPath[0];
        for (let i2 = 1; i2 < propagationPath.length; i2++) {
          if (propagationPath[i2].parent === currentTarget) {
            currentTarget = propagationPath[i2];
          } else {
            break;
          }
        }
        return currentTarget;
      }
      /**
       * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The {@code originalEvent} for the returned event.
       * @param [type=from.type] - The type of the returned event.
       * @param target - The target of the returned event.
       */
      createPointerEvent(from, type2, target) {
        const event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];
        if (typeof type2 === "string") {
          event.type = type2;
        }
        return event;
      }
      /**
       * Creates a wheel event whose {@code originalEvent} is {@code from}.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The upstream wheel event.
       */
      createWheelEvent(from) {
        const event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        event.target = this.hitTest(event.global.x, event.global.y);
        return event;
      }
      /**
       * Clones the event {@code from}, with an optional {@code type} override.
       *
       * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.
       * @param from - The event to clone.
       * @param [type=from.type] - The type of the returned event.
       */
      clonePointerEvent(from, type2) {
        const event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type2 ?? event.type;
        return event;
      }
      /**
       * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + deltaMode
       * + deltaX
       * + deltaY
       * + deltaZ
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
      /**
       * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + pointerId
       * + width
       * + height
       * + isPrimary
       * + pointerType
       * + pressure
       * + tangentialPressure
       * + tiltX
       * + tiltY
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyPointerData(from, to) {
        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent))
          return;
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
      /**
       * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.
       *
       * The following properties are copied:
       * + altKey
       * + button
       * + buttons
       * + clientX
       * + clientY
       * + metaKey
       * + movementX
       * + movementY
       * + pageX
       * + pageY
       * + x
       * + y
       * + screen
       * + shiftKey
       * + global
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyMouseData(from, to) {
        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent))
          return;
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.client.copyFrom(from.client);
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.movement.copyFrom(from.movement);
        to.screen.copyFrom(from.screen);
        to.shiftKey = from.shiftKey;
        to.global.copyFrom(from.global);
      }
      /**
       * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.
       *
       * The following properties are copied:
       * + isTrusted
       * + srcElement
       * + timeStamp
       * + type
       * @param from - The event to copy data from.
       * @param to - The event to copy data into.
       */
      copyData(from, to) {
        to.isTrusted = from.isTrusted;
        to.srcElement = from.srcElement;
        to.timeStamp = performance.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.which = from.which;
        to.layer.copyFrom(from.layer);
        to.page.copyFrom(from.page);
      }
      /**
       * @param id - The pointer ID.
       * @returns The tracking data stored for the given pointer. If no data exists, a blank
       *  state will be created.
       */
      trackingData(id2) {
        if (!this.mappingState.trackingData[id2]) {
          this.mappingState.trackingData[id2] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id2];
      }
      /**
       * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.
       *
       * This allocation is constructor-agnostic, as long as it only takes one argument - this event
       * boundary.
       * @param constructor - The event's constructor.
       */
      allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        const event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = null;
        event.target = null;
        return event;
      }
      /**
       * Frees the event and puts it back into the event pool.
       *
       * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.
       *
       * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}
       * not be freed. This is because of the possibility that the same event is freed twice, which can cause
       * it to be allocated twice & result in overwriting.
       * @param event - The event to be freed.
       * @throws Error if the event is managed by another event boundary.
       */
      freeEvent(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
      /**
       * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag
       * is set on the event.
       * @param e - The event to call each listener with.
       * @param type - The event key.
       */
      _notifyListeners(e3, type2) {
        const listeners = e3.currentTarget._events[type2];
        if (!listeners)
          return;
        if ("fn" in listeners) {
          if (listeners.once)
            e3.currentTarget.removeListener(type2, listeners.fn, void 0, true);
          listeners.fn.call(listeners.context, e3);
        } else {
          for (let i2 = 0, j3 = listeners.length; i2 < j3 && !e3.propagationImmediatelyStopped; i2++) {
            if (listeners[i2].once)
              e3.currentTarget.removeListener(type2, listeners[i2].fn, void 0, true);
            listeners[i2].fn.call(listeners[i2].context, e3);
          }
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/events/EventSystem.mjs
var MOUSE_POINTER_ID, TOUCH_TO_POINTER, _EventSystem, EventSystem;
var init_EventSystem = __esm({
  "node_modules/pixi.js/lib/events/EventSystem.mjs"() {
    init_Extensions();
    init_EventBoundary();
    init_EventTicker();
    init_FederatedPointerEvent();
    init_FederatedWheelEvent();
    MOUSE_POINTER_ID = 1;
    TOUCH_TO_POINTER = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel"
    };
    _EventSystem = class _EventSystem2 {
      /**
       * @param {Renderer} renderer
       */
      constructor(renderer) {
        this.supportsTouchEvents = "ontouchstart" in globalThis;
        this.supportsPointerEvents = !!globalThis.PointerEvent;
        this.domElement = null;
        this.resolution = 1;
        this.renderer = renderer;
        this.rootBoundary = new EventBoundary(null);
        EventsTicker.init(this);
        this.autoPreventDefault = true;
        this._eventsAdded = false;
        this._rootPointerEvent = new FederatedPointerEvent(null);
        this._rootWheelEvent = new FederatedWheelEvent(null);
        this.cursorStyles = {
          default: "inherit",
          pointer: "pointer"
        };
        this.features = new Proxy({ ..._EventSystem2.defaultEventFeatures }, {
          set: (target, key, value) => {
            if (key === "globalMove") {
              this.rootBoundary.enableGlobalMoveEvents = value;
            }
            target[key] = value;
            return true;
          }
        });
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._onPointerUp = this._onPointerUp.bind(this);
        this._onPointerOverOut = this._onPointerOverOut.bind(this);
        this.onWheel = this.onWheel.bind(this);
      }
      /**
       * The default interaction mode for all display objects.
       * @see Container.eventMode
       * @type {EventMode}
       * @readonly
       * @since 7.2.0
       */
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      /**
       * Runner init called, view is available at this point.
       * @ignore
       */
      init(options) {
        const { canvas, resolution } = this.renderer;
        this.setTargetElement(canvas);
        this.resolution = resolution;
        _EventSystem2._defaultEventMode = options.eventMode ?? "passive";
        Object.assign(this.features, options.eventFeatures ?? {});
        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;
      }
      /**
       * Handle changing resolution.
       * @ignore
       */
      resolutionChange(resolution) {
        this.resolution = resolution;
      }
      /** Destroys all event listeners and detaches the renderer. */
      destroy() {
        this.setTargetElement(null);
        this.renderer = null;
        this._currentCursor = null;
      }
      /**
       * Sets the current cursor mode, handling any callbacks or CSS style changes.
       * @param mode - cursor mode, a key from the cursorStyles dictionary
       */
      setCursor(mode) {
        mode = mode || "default";
        let applyStyles = true;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas) {
          applyStyles = false;
        }
        if (this._currentCursor === mode) {
          return;
        }
        this._currentCursor = mode;
        const style = this.cursorStyles[mode];
        if (style) {
          switch (typeof style) {
            case "string":
              if (applyStyles) {
                this.domElement.style.cursor = style;
              }
              break;
            case "function":
              style(mode);
              break;
            case "object":
              if (applyStyles) {
                Object.assign(this.domElement.style, style);
              }
              break;
          }
        } else if (applyStyles && typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
          this.domElement.style.cursor = mode;
        }
      }
      /**
       * The global pointer event.
       * Useful for getting the pointer position without listening to events.
       * @since 7.2.0
       */
      get pointer() {
        return this._rootPointerEvent;
      }
      /**
       * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerDown(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const events = this._normalizeToPointerData(nativeEvent);
        if (this.autoPreventDefault && events[0].isNormalized) {
          const cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
          if (cancelable) {
            nativeEvent.preventDefault();
          }
        }
        for (let i2 = 0, j3 = events.length; i2 < j3; i2++) {
          const nativeEvent2 = events[i2];
          const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent2);
          this.rootBoundary.mapEvent(federatedEvent);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch events.
       */
      _onPointerMove(nativeEvent) {
        if (!this.features.move)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        EventsTicker.pointerMoved();
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerUp(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let target = nativeEvent.target;
        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0) {
          target = nativeEvent.composedPath()[0];
        }
        const outside = target !== this.domElement ? "outside" : "";
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          event.type += outside;
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.
       * @param nativeEvent - The native mouse/pointer/touch event.
       */
      _onPointerOverOut(nativeEvent) {
        if (!this.features.click)
          return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const normalizedEvents = this._normalizeToPointerData(nativeEvent);
        for (let i2 = 0, j3 = normalizedEvents.length; i2 < j3; i2++) {
          const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i2]);
          this.rootBoundary.mapEvent(event);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      /**
       * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.
       * @param nativeEvent - The native wheel event.
       */
      onWheel(nativeEvent) {
        if (!this.features.wheel)
          return;
        const wheelEvent = this.normalizeWheelEvent(nativeEvent);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        this.rootBoundary.mapEvent(wheelEvent);
      }
      /**
       * Sets the {@link EventSystem#domElement domElement} and binds event listeners.
       *
       * To deregister the current DOM element without setting a new one, pass {@code null}.
       * @param element - The new DOM element.
       */
      setTargetElement(element) {
        this._removeEvents();
        this.domElement = element;
        EventsTicker.domElement = element;
        this._addEvents();
      }
      /** Register event listeners on {@link Renderer#domElement this.domElement}. */
      _addEvents() {
        if (this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.addTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "none";
            style.msTouchAction = "none";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "none";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.addEventListener("pointermove", this._onPointerMove, true);
          this.domElement.addEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.addEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.addEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.addEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.addEventListener("mousemove", this._onPointerMove, true);
          this.domElement.addEventListener("mousedown", this._onPointerDown, true);
          this.domElement.addEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.addEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.addEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.addEventListener("touchstart", this._onPointerDown, true);
            this.domElement.addEventListener("touchend", this._onPointerUp, true);
            this.domElement.addEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: true,
          capture: true
        });
        this._eventsAdded = true;
      }
      /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) {
          return;
        }
        EventsTicker.removeTickerListener();
        const style = this.domElement.style;
        if (style) {
          if (globalThis.navigator.msPointerEnabled) {
            style.msContentZooming = "";
            style.msTouchAction = "";
          } else if (this.supportsPointerEvents) {
            style.touchAction = "";
          }
        }
        if (this.supportsPointerEvents) {
          globalThis.document.removeEventListener("pointermove", this._onPointerMove, true);
          this.domElement.removeEventListener("pointerdown", this._onPointerDown, true);
          this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, true);
          this.domElement.removeEventListener("pointerover", this._onPointerOverOut, true);
          globalThis.removeEventListener("pointerup", this._onPointerUp, true);
        } else {
          globalThis.document.removeEventListener("mousemove", this._onPointerMove, true);
          this.domElement.removeEventListener("mousedown", this._onPointerDown, true);
          this.domElement.removeEventListener("mouseout", this._onPointerOverOut, true);
          this.domElement.removeEventListener("mouseover", this._onPointerOverOut, true);
          globalThis.removeEventListener("mouseup", this._onPointerUp, true);
          if (this.supportsTouchEvents) {
            this.domElement.removeEventListener("touchstart", this._onPointerDown, true);
            this.domElement.removeEventListener("touchend", this._onPointerUp, true);
            this.domElement.removeEventListener("touchmove", this._onPointerMove, true);
          }
        }
        this.domElement.removeEventListener("wheel", this.onWheel, true);
        this.domElement = null;
        this._eventsAdded = false;
      }
      /**
       * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The
       * resulting value is stored in the point. This takes into account the fact that the DOM
       * element could be scaled and positioned anywhere on the screen.
       * @param  {PointData} point - the point that the result will be stored in
       * @param  {number} x - the x coord of the position to map
       * @param  {number} y - the y coord of the position to map
       */
      mapPositionToPoint(point, x5, y4) {
        const rect = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
          x: 0,
          y: 0,
          width: this.domElement.width,
          height: this.domElement.height,
          left: 0,
          top: 0
        };
        const resolutionMultiplier = 1 / this.resolution;
        point.x = (x5 - rect.left) * (this.domElement.width / rect.width) * resolutionMultiplier;
        point.y = (y4 - rect.top) * (this.domElement.height / rect.height) * resolutionMultiplier;
      }
      /**
       * Ensures that the original event object contains all data that a regular pointer event would have
       * @param event - The original event data from a touch or mouse event
       * @returns An array containing a single normalized pointer event, in the case of a pointer
       *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches
       */
      _normalizeToPointerData(event) {
        const normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
          for (let i2 = 0, li = event.changedTouches.length; i2 < li; i2++) {
            const touch = event.changedTouches[i2];
            if (typeof touch.button === "undefined")
              touch.button = 0;
            if (typeof touch.buttons === "undefined")
              touch.buttons = 1;
            if (typeof touch.isPrimary === "undefined") {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (typeof touch.width === "undefined")
              touch.width = touch.radiusX || 1;
            if (typeof touch.height === "undefined")
              touch.height = touch.radiusY || 1;
            if (typeof touch.tiltX === "undefined")
              touch.tiltX = 0;
            if (typeof touch.tiltY === "undefined")
              touch.tiltY = 0;
            if (typeof touch.pointerType === "undefined")
              touch.pointerType = "touch";
            if (typeof touch.pointerId === "undefined")
              touch.pointerId = touch.identifier || 0;
            if (typeof touch.pressure === "undefined")
              touch.pressure = touch.force || 0.5;
            if (typeof touch.twist === "undefined")
              touch.twist = 0;
            if (typeof touch.tangentialPressure === "undefined")
              touch.tangentialPressure = 0;
            if (typeof touch.layerX === "undefined")
              touch.layerX = touch.offsetX = touch.clientX;
            if (typeof touch.layerY === "undefined")
              touch.layerY = touch.offsetY = touch.clientY;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (!globalThis.MouseEvent || event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))) {
          const tempEvent = event;
          if (typeof tempEvent.isPrimary === "undefined")
            tempEvent.isPrimary = true;
          if (typeof tempEvent.width === "undefined")
            tempEvent.width = 1;
          if (typeof tempEvent.height === "undefined")
            tempEvent.height = 1;
          if (typeof tempEvent.tiltX === "undefined")
            tempEvent.tiltX = 0;
          if (typeof tempEvent.tiltY === "undefined")
            tempEvent.tiltY = 0;
          if (typeof tempEvent.pointerType === "undefined")
            tempEvent.pointerType = "mouse";
          if (typeof tempEvent.pointerId === "undefined")
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (typeof tempEvent.pressure === "undefined")
            tempEvent.pressure = 0.5;
          if (typeof tempEvent.twist === "undefined")
            tempEvent.twist = 0;
          if (typeof tempEvent.tangentialPressure === "undefined")
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
      /**
       * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.
       *
       * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across
       * multiple native wheel events.
       * @param nativeEvent - The native wheel event that occurred on the canvas.
       * @returns A federated wheel event.
       */
      normalizeWheelEvent(nativeEvent) {
        const event = this._rootWheelEvent;
        this._transferMouseData(event, nativeEvent);
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        event.deltaMode = nativeEvent.deltaMode;
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.
       * @param event
       * @param nativeEvent
       */
      _bootstrapEvent(event, nativeEvent) {
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = nativeEvent.pointerId;
        event.width = nativeEvent.width;
        event.height = nativeEvent.height;
        event.isPrimary = nativeEvent.isPrimary;
        event.pointerType = nativeEvent.pointerType;
        event.pressure = nativeEvent.pressure;
        event.tangentialPressure = nativeEvent.tangentialPressure;
        event.tiltX = nativeEvent.tiltX;
        event.tiltY = nativeEvent.tiltY;
        event.twist = nativeEvent.twist;
        this._transferMouseData(event, nativeEvent);
        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);
        event.global.copyFrom(event.screen);
        event.offset.copyFrom(event.screen);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
      /**
       * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.
       * @param event
       * @param nativeEvent
       */
      _transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.metaKey = nativeEvent.metaKey;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.relatedTarget = null;
        event.shiftKey = nativeEvent.shiftKey;
      }
    };
    _EventSystem.extension = {
      name: "events",
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.CanvasSystem,
        ExtensionType.WebGPUSystem
      ],
      priority: -1
    };
    _EventSystem.defaultEventFeatures = {
      /** Enables pointer events associated with pointer movement. */
      move: true,
      /** Enables global pointer move events. */
      globalMove: true,
      /** Enables pointer events associated with clicking. */
      click: true,
      /** Enables wheel events. */
      wheel: true
    };
    EventSystem = _EventSystem;
  }
});

// node_modules/pixi.js/lib/events/FederatedEventTarget.mjs
var FederatedContainer;
var init_FederatedEventTarget = __esm({
  "node_modules/pixi.js/lib/events/FederatedEventTarget.mjs"() {
    init_EventSystem();
    init_FederatedEvent();
    FederatedContainer = {
      /**
       * Property-based event handler for the `click` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onclick = (event) => {
       *  //some function here that happens on click
       * }
       */
      onclick: null,
      /**
       * Property-based event handler for the `mousedown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmousedown = (event) => {
       *  //some function here that happens on mousedown
       * }
       */
      onmousedown: null,
      /**
       * Property-based event handler for the `mouseenter` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseenter = (event) => {
       *  //some function here that happens on mouseenter
       * }
       */
      onmouseenter: null,
      /**
       * Property-based event handler for the `mouseleave` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseleave = (event) => {
       *  //some function here that happens on mouseleave
       * }
       */
      onmouseleave: null,
      /**
       * Property-based event handler for the `mousemove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmousemove = (event) => {
       *  //some function here that happens on mousemove
       * }
       */
      onmousemove: null,
      /**
       * Property-based event handler for the `globalmousemove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobalmousemove = (event) => {
       *  //some function here that happens on globalmousemove
       * }
       */
      onglobalmousemove: null,
      /**
       * Property-based event handler for the `mouseout` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseout = (event) => {
       *  //some function here that happens on mouseout
       * }
       */
      onmouseout: null,
      /**
       * Property-based event handler for the `mouseover` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseover = (event) => {
       *  //some function here that happens on mouseover
       * }
       */
      onmouseover: null,
      /**
       * Property-based event handler for the `mouseup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseup = (event) => {
       *  //some function here that happens on mouseup
       * }
       */
      onmouseup: null,
      /**
       * Property-based event handler for the `mouseupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onmouseupoutside = (event) => {
       *  //some function here that happens on mouseupoutside
       * }
       */
      onmouseupoutside: null,
      /**
       * Property-based event handler for the `pointercancel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointercancel = (event) => {
       *  //some function here that happens on pointercancel
       * }
       */
      onpointercancel: null,
      /**
       * Property-based event handler for the `pointerdown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerdown = (event) => {
       *  //some function here that happens on pointerdown
       * }
       */
      onpointerdown: null,
      /**
       * Property-based event handler for the `pointerenter` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerenter = (event) => {
       *  //some function here that happens on pointerenter
       * }
       */
      onpointerenter: null,
      /**
       * Property-based event handler for the `pointerleave` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerleave = (event) => {
       *  //some function here that happens on pointerleave
       * }
       */
      onpointerleave: null,
      /**
       * Property-based event handler for the `pointermove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointermove = (event) => {
       *  //some function here that happens on pointermove
       * }
       */
      onpointermove: null,
      /**
       * Property-based event handler for the `globalpointermove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobalpointermove = (event) => {
       *  //some function here that happens on globalpointermove
       * }
       */
      onglobalpointermove: null,
      /**
       * Property-based event handler for the `pointerout` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerout = (event) => {
       *  //some function here that happens on pointerout
       * }
       */
      onpointerout: null,
      /**
       * Property-based event handler for the `pointerover` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerover = (event) => {
       *  //some function here that happens on pointerover
       * }
       */
      onpointerover: null,
      /**
       * Property-based event handler for the `pointertap` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointertap = (event) => {
       *  //some function here that happens on pointertap
       * }
       */
      onpointertap: null,
      /**
       * Property-based event handler for the `pointerup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerup = (event) => {
       *  //some function here that happens on pointerup
       * }
       */
      onpointerup: null,
      /**
       * Property-based event handler for the `pointerupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onpointerupoutside = (event) => {
       *  //some function here that happens on pointerupoutside
       * }
       */
      onpointerupoutside: null,
      /**
       * Property-based event handler for the `rightclick` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightclick = (event) => {
       *  //some function here that happens on rightclick
       * }
       */
      onrightclick: null,
      /**
       * Property-based event handler for the `rightdown` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightdown = (event) => {
       *  //some function here that happens on rightdown
       * }
       */
      onrightdown: null,
      /**
       * Property-based event handler for the `rightup` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightup = (event) => {
       *  //some function here that happens on rightup
       * }
       */
      onrightup: null,
      /**
       * Property-based event handler for the `rightupoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onrightupoutside = (event) => {
       *  //some function here that happens on rightupoutside
       * }
       */
      onrightupoutside: null,
      /**
       * Property-based event handler for the `tap` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontap = (event) => {
       *  //some function here that happens on tap
       * }
       */
      ontap: null,
      /**
       * Property-based event handler for the `touchcancel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchcancel = (event) => {
       *  //some function here that happens on touchcancel
       * }
       */
      ontouchcancel: null,
      /**
       * Property-based event handler for the `touchend` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchend = (event) => {
       *  //some function here that happens on touchend
       * }
       */
      ontouchend: null,
      /**
       * Property-based event handler for the `touchendoutside` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchendoutside = (event) => {
       *  //some function here that happens on touchendoutside
       * }
       */
      ontouchendoutside: null,
      /**
       * Property-based event handler for the `touchmove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchmove = (event) => {
       *  //some function here that happens on touchmove
       * }
       */
      ontouchmove: null,
      /**
       * Property-based event handler for the `globaltouchmove` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onglobaltouchmove = (event) => {
       *  //some function here that happens on globaltouchmove
       * }
       */
      onglobaltouchmove: null,
      /**
       * Property-based event handler for the `touchstart` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.ontouchstart = (event) => {
       *  //some function here that happens on touchstart
       * }
       */
      ontouchstart: null,
      /**
       * Property-based event handler for the `wheel` event.
       * @memberof scene.Container#
       * @default null
       * @example
       * this.onwheel = (event) => {
       *  //some function here that happens on wheel
       * }
       */
      onwheel: null,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse
       * @memberof scene.Container#
       */
      get interactive() {
        return this.eventMode === "dynamic" || this.eventMode === "static";
      },
      set interactive(value) {
        this.eventMode = value ? "static" : "passive";
      },
      /**
       * @ignore
       */
      _internalEventMode: void 0,
      /**
       * Enable interaction events for the Container. Touch, pointer and mouse.
       * There are 5 types of interaction settings:
       * - `'none'`: Ignores all interaction events, even on its children.
       * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.
       * Interactive children will still emit events.
       * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7
       * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7
       * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to
       * allow for interaction when the mouse isn't moving
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.on('tap', (event) => {
       *     // Handle event
       * });
       * @memberof scene.Container#
       * @since 7.2.0
       */
      get eventMode() {
        return this._internalEventMode ?? EventSystem.defaultEventMode;
      },
      set eventMode(value) {
        this._internalEventMode = value;
      },
      /**
       * Determines if the container is interactive or not
       * @returns {boolean} Whether the container is interactive or not
       * @memberof scene.Container#
       * @since 7.2.0
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.eventMode = 'static';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'dynamic';
       * sprite.isInteractive(); // true
       *
       * sprite.eventMode = 'none';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'passive';
       * sprite.isInteractive(); // false
       *
       * sprite.eventMode = 'auto';
       * sprite.isInteractive(); // false
       */
      isInteractive() {
        return this.eventMode === "static" || this.eventMode === "dynamic";
      },
      /**
       * Determines if the children to the container can be clicked/touched
       * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
       * @memberof scene.Container#
       */
      interactiveChildren: true,
      /**
       * Interaction shape. Children will be hit first, then this shape will be checked.
       * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.
       * @example
       * import { Rectangle, Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite(texture);
       * sprite.interactive = true;
       * sprite.hitArea = new Rectangle(0, 0, 100, 100);
       * @member {IHitArea}
       * @memberof scene.Container#
       */
      hitArea: null,
      /**
       * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`
       * seeks to be compatible with the DOM's `addEventListener` with support for options.
       * @memberof scene.Container
       * @param type - The type of event to listen to.
       * @param listener - The listener callback or object.
       * @param options - Listener options, used for capture phase.
       * @example
       * // Tell the user whether they did a single, double, triple, or nth click.
       * button.addEventListener('click', {
       *     handleEvent(e): {
       *         let prefix;
       *
       *         switch (e.detail) {
       *             case 1: prefix = 'single'; break;
       *             case 2: prefix = 'double'; break;
       *             case 3: prefix = 'triple'; break;
       *             default: prefix = e.detail + 'th'; break;
       *         }
       *
       *         console.log('That was a ' + prefix + 'click');
       *     }
       * });
       *
       * // But skip the first click!
       * button.parent.addEventListener('click', function blockClickOnce(e) {
       *     e.stopImmediatePropagation();
       *     button.parent.removeEventListener('click', blockClickOnce, true);
       * }, {
       *     capture: true,
       * });
       */
      addEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const signal = typeof options === "object" ? options.signal : void 0;
        const once = typeof options === "object" ? options.once === true : false;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        const listenerFn = typeof listener === "function" ? listener : listener.handleEvent;
        const emitter = this;
        if (signal) {
          signal.addEventListener("abort", () => {
            emitter.off(type2, listenerFn, context2);
          });
        }
        if (once) {
          emitter.once(type2, listenerFn, context2);
        } else {
          emitter.on(type2, listenerFn, context2);
        }
      },
      /**
       * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`
       * seeks to be compatible with the DOM's `removeEventListener` with support for options.
       * @memberof scene.Container
       * @param type - The type of event the listener is bound to.
       * @param listener - The listener callback or object.
       * @param options - The original listener options. This is required to deregister a capture phase listener.
       */
      removeEventListener(type2, listener, options) {
        const capture = typeof options === "boolean" && options || typeof options === "object" && options.capture;
        const context2 = typeof listener === "function" ? void 0 : listener;
        type2 = capture ? `${type2}capture` : type2;
        listener = typeof listener === "function" ? listener : listener.handleEvent;
        this.off(type2, listener, context2);
      },
      /**
       * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.
       *
       * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.
       * @memberof scene.Container
       * @param e - The event to dispatch.
       * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.
       * @example
       * // Reuse a click event!
       * button.dispatchEvent(clickEvent);
       */
      dispatchEvent(e3) {
        if (!(e3 instanceof FederatedEvent)) {
          throw new Error("Container cannot propagate events outside of the Federated Events API");
        }
        e3.defaultPrevented = false;
        e3.path = null;
        e3.target = this;
        e3.manager.dispatchEvent(e3);
        return !e3.defaultPrevented;
      }
    };
  }
});

// node_modules/pixi.js/lib/events/init.mjs
var init_init3 = __esm({
  "node_modules/pixi.js/lib/events/init.mjs"() {
    init_Extensions();
    init_Container();
    init_EventSystem();
    init_FederatedEventTarget();
    extensions.add(EventSystem);
    Container.mixin(FederatedContainer);
  }
});

// node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs
var LoaderParserPriority;
var init_LoaderParser = __esm({
  "node_modules/pixi.js/lib/assets/loader/parsers/LoaderParser.mjs"() {
    "use strict";
    LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
      LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
      LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
      LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
      return LoaderParserPriority2;
    })(LoaderParserPriority || {});
  }
});

// node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs
var BrowserAdapter;
var init_BrowserAdapter = __esm({
  "node_modules/pixi.js/lib/environment-browser/BrowserAdapter.mjs"() {
    "use strict";
    BrowserAdapter = {
      createCanvas: (width, height) => {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      },
      getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
      getWebGLRenderingContext: () => WebGLRenderingContext,
      getNavigator: () => navigator,
      getBaseUrl: () => document.baseURI ?? window.location.href,
      getFontFaceSet: () => document.fonts,
      fetch: (url, options) => fetch(url, options),
      parseXML: (xml) => {
        const parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
      }
    };
  }
});

// node_modules/pixi.js/lib/environment/adapter.mjs
var currentAdapter, DOMAdapter;
var init_adapter = __esm({
  "node_modules/pixi.js/lib/environment/adapter.mjs"() {
    init_BrowserAdapter();
    currentAdapter = BrowserAdapter;
    DOMAdapter = {
      /**
       * Returns the current adapter.
       * @returns {environment.Adapter} The current adapter.
       */
      get() {
        return currentAdapter;
      },
      /**
       * Sets the current adapter.
       * @param adapter - The new adapter.
       */
      set(adapter) {
        currentAdapter = adapter;
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/path.mjs
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re2 = url.split("?")[0];
  return re2.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find3, replace) {
  return str.replace(new RegExp(escapeRegExp(find3), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
var path;
var init_path = __esm({
  "node_modules/pixi.js/lib/utils/path.mjs"() {
    init_adapter();
    path = {
      /**
       * Converts a path to posix format.
       * @param path - The path to convert to posix
       */
      toPosix(path2) {
        return replaceAll(path2, "\\", "/");
      },
      /**
       * Checks if the path is a URL e.g. http://, https://
       * @param path - The path to check
       */
      isUrl(path2) {
        return /^https?:/.test(this.toPosix(path2));
      },
      /**
       * Checks if the path is a data URL
       * @param path - The path to check
       */
      isDataUrl(path2) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
      },
      /**
       * Checks if the path is a blob URL
       * @param path - The path to check
       */
      isBlobUrl(path2) {
        return path2.startsWith("blob:");
      },
      /**
       * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
       * This will return true for windows file paths
       * @param path - The path to check
       */
      hasProtocol(path2) {
        return /^[^/:]+:/.test(this.toPosix(path2));
      },
      /**
       * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
       * @param path - The path to get the protocol from
       */
      getProtocol(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        const matchFile = /^file:\/\/\//.exec(path2);
        if (matchFile) {
          return matchFile[0];
        }
        const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
        if (matchProtocol) {
          return matchProtocol[0];
        }
        return "";
      },
      /**
       * Converts URL to an absolute path.
       * When loading from a Web Worker, we must use absolute paths.
       * If the URL is already absolute we return it as is
       * If it's not, we convert it
       * @param url - The URL to test
       * @param customBaseUrl - The base URL to use
       * @param customRootUrl - The root URL to use
       */
      toAbsolute(url, customBaseUrl, customRootUrl) {
        assertPath(url);
        if (this.isDataUrl(url) || this.isBlobUrl(url))
          return url;
        const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
        const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
        url = this.toPosix(url);
        if (url.startsWith("/")) {
          return path.join(rootUrl, url.slice(1));
        }
        const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
        return absolutePath;
      },
      /**
       * Normalizes the given path, resolving '..' and '.' segments
       * @param path - The path to normalize
       */
      normalize(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        if (this.isDataUrl(path2) || this.isBlobUrl(path2))
          return path2;
        path2 = this.toPosix(path2);
        let protocol = "";
        const isAbsolute = path2.startsWith("/");
        if (this.hasProtocol(path2)) {
          protocol = this.rootname(path2);
          path2 = path2.slice(protocol.length);
        }
        const trailingSeparator = path2.endsWith("/");
        path2 = normalizeStringPosix(path2, false);
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute)
          return `/${path2}`;
        return protocol + path2;
      },
      /**
       * Determines if path is an absolute path.
       * Absolute paths can be urls, data urls, or paths on disk
       * @param path - The path to test
       */
      isAbsolute(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        if (this.hasProtocol(path2))
          return true;
        return path2.startsWith("/");
      },
      /**
       * Joins all given path segments together using the platform-specific separator as a delimiter,
       * then normalizes the resulting path
       * @param segments - The segments of the path to join
       */
      join(...segments) {
        if (segments.length === 0) {
          return ".";
        }
        let joined;
        for (let i2 = 0; i2 < segments.length; ++i2) {
          const arg = segments[i2];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else {
              const prevArg = segments[i2 - 1] ?? "";
              if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
                joined += `/../${arg}`;
              } else {
                joined += `/${arg}`;
              }
            }
          }
        }
        if (joined === void 0) {
          return ".";
        }
        return this.normalize(joined);
      },
      /**
       * Returns the directory name of a path
       * @param path - The path to parse
       */
      dirname(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        path2 = this.toPosix(path2);
        let code = path2.charCodeAt(0);
        const hasRoot = code === 47;
        let end = -1;
        let matchedSlash = true;
        const proto = this.getProtocol(path2);
        const origpath = path2;
        path2 = path2.slice(proto.length);
        for (let i2 = path2.length - 1; i2 >= 1; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              end = i2;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
        if (hasRoot && end === 1)
          return "//";
        return proto + path2.slice(0, end);
      },
      /**
       * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
       * @param path - The path to parse
       */
      rootname(path2) {
        assertPath(path2);
        path2 = this.toPosix(path2);
        let root3 = "";
        if (path2.startsWith("/"))
          root3 = "/";
        else {
          root3 = this.getProtocol(path2);
        }
        if (this.isUrl(path2)) {
          const index2 = path2.indexOf("/", root3.length);
          if (index2 !== -1) {
            root3 = path2.slice(0, index2);
          } else
            root3 = path2;
          if (!root3.endsWith("/"))
            root3 += "/";
        }
        return root3;
      },
      /**
       * Returns the last portion of a path
       * @param path - The path to test
       * @param ext - Optional extension to remove
       */
      basename(path2, ext) {
        assertPath(path2);
        if (ext)
          assertPath(ext);
        path2 = removeUrlParams(this.toPosix(path2));
        let start2 = 0;
        let end = -1;
        let matchedSlash = true;
        let i2;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          let extIdx = ext.length - 1;
          let firstNonSlashEnd = -1;
          for (i2 = path2.length - 1; i2 >= 0; --i2) {
            const code = path2.charCodeAt(i2);
            if (code === 47) {
              if (!matchedSlash) {
                start2 = i2 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i2 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i2;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start2 === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start2, end);
        }
        for (i2 = path2.length - 1; i2 >= 0; --i2) {
          if (path2.charCodeAt(i2) === 47) {
            if (!matchedSlash) {
              start2 = i2 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
        }
        if (end === -1)
          return "";
        return path2.slice(start2, end);
      },
      /**
       * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
       * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
       * the first character of the basename of path, an empty string is returned.
       * @param path - The path to parse
       */
      extname(path2) {
        assertPath(path2);
        path2 = removeUrlParams(this.toPosix(path2));
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let preDotState = 0;
        for (let i2 = path2.length - 1; i2 >= 0; --i2) {
          const code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      /**
       * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
       * @param path - The path to parse
       */
      parse(path2) {
        assertPath(path2);
        const ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path2.length === 0)
          return ret;
        path2 = removeUrlParams(this.toPosix(path2));
        let code = path2.charCodeAt(0);
        const isAbsolute = this.isAbsolute(path2);
        let start2;
        const protocol = "";
        ret.root = this.rootname(path2);
        if (isAbsolute || this.hasProtocol(path2)) {
          start2 = 1;
        } else {
          start2 = 0;
        }
        let startDot = -1;
        let startPart = 0;
        let end = -1;
        let matchedSlash = true;
        let i2 = path2.length - 1;
        let preDotState = 0;
        for (; i2 >= start2; --i2) {
          code = path2.charCodeAt(i2);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i2 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i2 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i2;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        ret.dir = this.dirname(path2);
        if (protocol)
          ret.dir = protocol + ret.dir;
        return ret;
      },
      sep: "/",
      delimiter: ":",
      joinExtensions: [".html"]
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/convertToList.mjs
var convertToList;
var init_convertToList = __esm({
  "node_modules/pixi.js/lib/assets/utils/convertToList.mjs"() {
    "use strict";
    convertToList = (input, transform4, forceTransform = false) => {
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!transform4) {
        return input;
      }
      return input.map((item) => {
        if (typeof item === "string" || forceTransform) {
          return transform4(item);
        }
        return item;
      });
    };
  }
});

// node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs
function processX(base, ids, depth, result, tags) {
  const id2 = ids[depth];
  for (let i2 = 0; i2 < id2.length; i2++) {
    const value = id2[i2];
    if (depth < ids.length - 1) {
      processX(base.replace(result[depth], value), ids, depth + 1, result, tags);
    } else {
      tags.push(base.replace(result[depth], value));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags);
  } else {
    tags.push(string);
  }
  return tags;
}
var init_createStringVariations = __esm({
  "node_modules/pixi.js/lib/assets/utils/createStringVariations.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs
var isSingleItem;
var init_isSingleItem = __esm({
  "node_modules/pixi.js/lib/assets/utils/isSingleItem.mjs"() {
    "use strict";
    isSingleItem = (item) => !Array.isArray(item);
  }
});

// node_modules/pixi.js/lib/assets/resolver/Resolver.mjs
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}
var Resolver;
var init_Resolver = __esm({
  "node_modules/pixi.js/lib/assets/resolver/Resolver.mjs"() {
    init_warn();
    init_path();
    init_convertToList();
    init_createStringVariations();
    init_isSingleItem();
    Resolver = class {
      constructor() {
        this._defaultBundleIdentifierOptions = {
          connector: "-",
          createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
          extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
        };
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
        this._assetMap = {};
        this._preferredOrder = [];
        this._parsers = [];
        this._resolverHash = {};
        this._bundles = {};
      }
      /**
       * Override how the resolver deals with generating bundle ids.
       * must be called before any bundles are added
       * @param bundleIdentifier - the bundle identifier options
       */
      setBundleIdentifier(bundleIdentifier) {
        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
        if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
          throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
        }
      }
      /**
       * Let the resolver know which assets you prefer to use when resolving assets.
       * Multiple prefer user defined rules can be added.
       * @example
       * resolver.prefer({
       *     // first look for something with the correct format, and then then correct resolution
       *     priority: ['format', 'resolution'],
       *     params:{
       *         format:'webp', // prefer webp images
       *         resolution: 2, // prefer a resolution of 2
       *     }
       * })
       * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
       * resolver.resolveUrl('foo') // => 'bar@2x.webp'
       * @param preferOrders - the prefer options
       */
      prefer(...preferOrders) {
        preferOrders.forEach((prefer) => {
          this._preferredOrder.push(prefer);
          if (!prefer.priority) {
            prefer.priority = Object.keys(prefer.params);
          }
        });
        this._resolverHash = {};
      }
      /**
       * Set the base path to prepend to all urls when resolving
       * @example
       * resolver.basePath = 'https://home.com/';
       * resolver.add('foo', 'bar.ong');
       * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
       * @param basePath - the base path to use
       */
      set basePath(basePath) {
        this._basePath = basePath;
      }
      get basePath() {
        return this._basePath;
      }
      /**
       * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
       * default value for browsers is `window.location.origin`
       * @example
       * // Application hosted on https://home.com/some-path/index.html
       * resolver.basePath = 'https://home.com/some-path/';
       * resolver.rootPath = 'https://home.com/';
       * resolver.add('foo', '/bar.png');
       * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
       * @param rootPath - the root path to use
       */
      set rootPath(rootPath) {
        this._rootPath = rootPath;
      }
      get rootPath() {
        return this._rootPath;
      }
      /**
       * All the active URL parsers that help the parser to extract information and create
       * an asset object-based on parsing the URL itself.
       *
       * Can be added using the extensions API
       * @example
       * resolver.add('foo', [
       *     {
       *         resolution: 2,
       *         format: 'png',
       *         src: 'image@2x.png',
       *     },
       *     {
       *         resolution:1,
       *         format:'png',
       *         src: 'image.png',
       *     },
       * ]);
       *
       * // With a url parser the information such as resolution and file format could extracted from the url itself:
       * extensions.add({
       *     extension: ExtensionType.ResolveParser,
       *     test: loadTextures.test, // test if url ends in an image
       *     parse: (value: string) =>
       *     ({
       *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
       *         format: value.split('.').pop(),
       *         src: value,
       *     }),
       * });
       *
       * // Now resolution and format can be extracted from the url
       * resolver.add('foo', [
       *     'image@2x.png',
       *     'image.png',
       * ]);
       */
      get parsers() {
        return this._parsers;
      }
      /** Used for testing, this resets the resolver to its initial state */
      reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
        this._assetMap = {};
        this._preferredOrder = [];
        this._resolverHash = {};
        this._rootPath = null;
        this._basePath = null;
        this._manifest = null;
        this._bundles = {};
        this._defaultSearchParams = null;
      }
      /**
       * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
       * @param searchParams - the default url parameters to append when resolving urls
       */
      setDefaultSearchParams(searchParams) {
        if (typeof searchParams === "string") {
          this._defaultSearchParams = searchParams;
        } else {
          const queryValues = searchParams;
          this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join("&");
        }
      }
      /**
       * Returns the aliases for a given asset
       * @param asset - the asset to get the aliases for
       */
      getAlias(asset) {
        const { alias, src } = asset;
        const aliasesToUse = convertToList(
          alias || src,
          (value) => {
            if (typeof value === "string")
              return value;
            if (Array.isArray(value))
              return value.map((v3) => v3?.src ?? v3);
            if (value?.src)
              return value.src;
            return value;
          },
          true
        );
        return aliasesToUse;
      }
      /**
       * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
       * generally a manifest would be built using a tool.
       * @param manifest - the manifest to add to the resolver
       */
      addManifest(manifest) {
        if (this._manifest) {
          warn("[Resolver] Manifest already exists, this will be overwritten");
        }
        this._manifest = manifest;
        manifest.bundles.forEach((bundle) => {
          this.addBundle(bundle.name, bundle.assets);
        });
      }
      /**
       * This adds a bundle of assets in one go so that you can resolve them as a group.
       * For example you could add a bundle for each screen in you pixi app
       * @example
       * resolver.addBundle('animals', [
       *  { alias: 'bunny', src: 'bunny.png' },
       *  { alias: 'chicken', src: 'chicken.png' },
       *  { alias: 'thumper', src: 'thumper.png' },
       * ]);
       * // or
       * resolver.addBundle('animals', {
       *     bunny: 'bunny.png',
       *     chicken: 'chicken.png',
       *     thumper: 'thumper.png',
       * });
       *
       * const resolvedAssets = await resolver.resolveBundle('animals');
       * @param bundleId - The id of the bundle to add
       * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
       */
      addBundle(bundleId, assets) {
        const assetNames = [];
        let convertedAssets = assets;
        if (!Array.isArray(assets)) {
          convertedAssets = Object.entries(assets).map(([alias, src]) => {
            if (typeof src === "string" || Array.isArray(src)) {
              return { alias, src };
            }
            return { alias, ...src };
          });
        }
        convertedAssets.forEach((asset) => {
          const srcs = asset.src;
          const aliases = asset.alias;
          let ids;
          if (typeof aliases === "string") {
            const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
            assetNames.push(bundleAssetId);
            ids = [aliases, bundleAssetId];
          } else {
            const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));
            assetNames.push(...bundleIds);
            ids = [...aliases, ...bundleIds];
          }
          this.add({
            ...asset,
            ...{
              alias: ids,
              src: srcs
            }
          });
        });
        this._bundles[bundleId] = assetNames;
      }
      /**
       * Tells the resolver what keys are associated with witch asset.
       * The most important thing the resolver does
       * @example
       * // Single key, single asset:
       * resolver.add({alias: 'foo', src: 'bar.png');
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Multiple keys, single asset:
       * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
       * resolver.resolveUrl('foo') // => 'bar.png'
       * resolver.resolveUrl('boo') // => 'bar.png'
       *
       * // Multiple keys, multiple assets:
       * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
       * resolver.resolveUrl('foo') // => 'bar.png'
       *
       * // Add custom data attached to the resolver
       * Resolver.add({
       *     alias: 'bunnyBooBooSmooth',
       *     src: 'bunny{png,webp}',
       *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
       * });
       *
       * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
       * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
       */
      add(aliases) {
        const assets = [];
        if (Array.isArray(aliases)) {
          assets.push(...aliases);
        } else {
          assets.push(aliases);
        }
        let keyCheck;
        keyCheck = (key) => {
          if (this.hasKey(key)) {
            warn(`[Resolver] already has key: ${key} overwriting`);
          }
        };
        const assetArray = convertToList(assets);
        assetArray.forEach((asset) => {
          const { src } = asset;
          let { data, format: format2, loadParser } = asset;
          const srcsToUse = convertToList(src).map((src2) => {
            if (typeof src2 === "string") {
              return createStringVariations(src2);
            }
            return Array.isArray(src2) ? src2 : [src2];
          });
          const aliasesToUse = this.getAlias(asset);
          Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
          const resolvedAssets = [];
          srcsToUse.forEach((srcs) => {
            srcs.forEach((src2) => {
              let formattedAsset = {};
              if (typeof src2 !== "object") {
                formattedAsset.src = src2;
                for (let i2 = 0; i2 < this._parsers.length; i2++) {
                  const parser = this._parsers[i2];
                  if (parser.test(src2)) {
                    formattedAsset = parser.parse(src2);
                    break;
                  }
                }
              } else {
                data = src2.data ?? data;
                format2 = src2.format ?? format2;
                loadParser = src2.loadParser ?? loadParser;
                formattedAsset = {
                  ...formattedAsset,
                  ...src2
                };
              }
              if (!aliasesToUse) {
                throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
              }
              formattedAsset = this._buildResolvedAsset(formattedAsset, {
                aliases: aliasesToUse,
                data,
                format: format2,
                loadParser
              });
              resolvedAssets.push(formattedAsset);
            });
          });
          aliasesToUse.forEach((alias) => {
            this._assetMap[alias] = resolvedAssets;
          });
        });
      }
      // TODO: this needs an overload like load did in Assets
      /**
       * If the resolver has had a manifest set via setManifest, this will return the assets urls for
       * a given bundleId or bundleIds.
       * @example
       * // Manifest Example
       * const manifest = {
       *     bundles: [
       *         {
       *             name: 'load-screen',
       *             assets: [
       *                 {
       *                     alias: 'background',
       *                     src: 'sunset.png',
       *                 },
       *                 {
       *                     alias: 'bar',
       *                     src: 'load-bar.{png,webp}',
       *                 },
       *             ],
       *         },
       *         {
       *             name: 'game-screen',
       *             assets: [
       *                 {
       *                     alias: 'character',
       *                     src: 'robot.png',
       *                 },
       *                 {
       *                     alias: 'enemy',
       *                     src: 'bad-guy.png',
       *                 },
       *             ],
       *         },
       *     ]
       * };
       *
       * resolver.setManifest(manifest);
       * const resolved = resolver.resolveBundle('load-screen');
       * @param bundleIds - The bundle ids to resolve
       * @returns All the bundles assets or a hash of assets for each bundle specified
       */
      resolveBundle(bundleIds) {
        const singleAsset = isSingleItem(bundleIds);
        bundleIds = convertToList(bundleIds);
        const out2 = {};
        bundleIds.forEach((bundleId) => {
          const assetNames = this._bundles[bundleId];
          if (assetNames) {
            const results = this.resolve(assetNames);
            const assets = {};
            for (const key in results) {
              const asset = results[key];
              assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
            }
            out2[bundleId] = assets;
          }
        });
        return singleAsset ? out2[bundleIds[0]] : out2;
      }
      /**
       * Does exactly what resolve does, but returns just the URL rather than the whole asset object
       * @param key - The key or keys to resolve
       * @returns - The URLs associated with the key(s)
       */
      resolveUrl(key) {
        const result = this.resolve(key);
        if (typeof key !== "string") {
          const out2 = {};
          for (const i2 in result) {
            out2[i2] = result[i2].src;
          }
          return out2;
        }
        return result.src;
      }
      resolve(keys2) {
        const singleAsset = isSingleItem(keys2);
        keys2 = convertToList(keys2);
        const result = {};
        keys2.forEach((key) => {
          if (!this._resolverHash[key]) {
            if (this._assetMap[key]) {
              let assets = this._assetMap[key];
              const preferredOrder = this._getPreferredOrder(assets);
              preferredOrder?.priority.forEach((priorityKey) => {
                preferredOrder.params[priorityKey].forEach((value) => {
                  const filteredAssets = assets.filter((asset) => {
                    if (asset[priorityKey]) {
                      return asset[priorityKey] === value;
                    }
                    return false;
                  });
                  if (filteredAssets.length) {
                    assets = filteredAssets;
                  }
                });
              });
              this._resolverHash[key] = assets[0];
            } else {
              this._resolverHash[key] = this._buildResolvedAsset({
                alias: [key],
                src: key
              }, {});
            }
          }
          result[key] = this._resolverHash[key];
        });
        return singleAsset ? result[keys2[0]] : result;
      }
      /**
       * Checks if an asset with a given key exists in the resolver
       * @param key - The key of the asset
       */
      hasKey(key) {
        return !!this._assetMap[key];
      }
      /**
       * Checks if a bundle with the given key exists in the resolver
       * @param key - The key of the bundle
       */
      hasBundle(key) {
        return !!this._bundles[key];
      }
      /**
       * Internal function for figuring out what prefer criteria an asset should use.
       * @param assets
       */
      _getPreferredOrder(assets) {
        for (let i2 = 0; i2 < assets.length; i2++) {
          const asset = assets[0];
          const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
          if (preferred) {
            return preferred;
          }
        }
        return this._preferredOrder[0];
      }
      /**
       * Appends the default url parameters to the url
       * @param url - The url to append the default parameters to
       * @returns - The url with the default parameters appended
       */
      _appendDefaultSearchParams(url) {
        if (!this._defaultSearchParams)
          return url;
        const paramConnector = /\?/.test(url) ? "&" : "?";
        return `${url}${paramConnector}${this._defaultSearchParams}`;
      }
      _buildResolvedAsset(formattedAsset, data) {
        const { aliases, data: assetData, loadParser, format: format2 } = data;
        if (this._basePath || this._rootPath) {
          formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
        }
        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
        formattedAsset.format = format2 ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
        return formattedAsset;
      }
    };
    Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  }
});

// node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs
var copySearchParams;
var init_copySearchParams = __esm({
  "node_modules/pixi.js/lib/assets/utils/copySearchParams.mjs"() {
    "use strict";
    copySearchParams = (targetUrl, sourceUrl) => {
      const searchParams = sourceUrl.split("?")[1];
      if (searchParams) {
        targetUrl += `?${searchParams}`;
      }
      return targetUrl;
    };
  }
});

// node_modules/pixi.js/lib/maths/matrix/groupD8.mjs
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j3 = 0; j3 < 16; j3++) {
      const _ux = signum(ux[i2] * ux[j3] + vx[i2] * uy[j3]);
      const _uy = signum(uy[i2] * ux[j3] + vy[i2] * uy[j3]);
      const _vx = signum(ux[i2] * vx[j3] + vx[i2] * vy[j3]);
      const _vy = signum(uy[i2] * vx[j3] + vy[i2] * vy[j3]);
      for (let k3 = 0; k3 < 16; k3++) {
        if (ux[k3] === _ux && uy[k3] === _uy && vx[k3] === _vx && vy[k3] === _vy) {
          row.push(k3);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
var ux, uy, vx, vy, rotationCayley, rotationMatrices, signum, groupD8;
var init_groupD8 = __esm({
  "node_modules/pixi.js/lib/maths/matrix/groupD8.mjs"() {
    init_Matrix();
    ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
    uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
    vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
    vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
    rotationCayley = [];
    rotationMatrices = [];
    signum = Math.sign;
    init();
    groupD8 = {
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 0°       | East      |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      E: 0,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 45°↻     | Southeast |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      SE: 1,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 90°↻     | South     |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      S: 2,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 135°↻    | Southwest |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      SW: 3,
      /**
       * | Rotation | Direction |
       * |----------|-----------|
       * | 180°     | West      |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      W: 4,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -135°/225°↻ | Northwest    |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      NW: 5,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -90°/270°↻  | North        |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      N: 6,
      /**
       * | Rotation    | Direction    |
       * |-------------|--------------|
       * | -45°/315°↻  | Northeast    |
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      NE: 7,
      /**
       * Reflection about Y-axis.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_VERTICAL: 8,
      /**
       * Reflection about the main diagonal.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MAIN_DIAGONAL: 10,
      /**
       * Reflection about X-axis.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      MIRROR_HORIZONTAL: 12,
      /**
       * Reflection about reverse diagonal.
       * @memberof maths.groupD8
       * @constant {GD8Symmetry}
       */
      REVERSE_DIAGONAL: 14,
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the U-axis
       *    after rotating the axes.
       */
      uX: (ind) => ux[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the U-axis
       *    after rotating the axes.
       */
      uY: (ind) => uy[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The X-component of the V-axis
       *    after rotating the axes.
       */
      vX: (ind) => vx[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} ind - sprite rotation angle.
       * @returns {GD8Symmetry} The Y-component of the V-axis
       *    after rotating the axes.
       */
      vY: (ind) => vy[ind],
      /**
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotation - symmetry whose opposite
       *   is needed. Only rotations have opposite symmetries while
       *   reflections don't.
       * @returns {GD8Symmetry} The opposite symmetry of `rotation`
       */
      inv: (rotation) => {
        if (rotation & 8) {
          return rotation & 15;
        }
        return -rotation & 7;
      },
      /**
       * Composes the two D8 operations.
       *
       * Taking `^` as reflection:
       *
       * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
       * |-------|-----|-----|-----|-----|------|-------|-------|-------|
       * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
       * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
       * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
       * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
       * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
       * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
       * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
       * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
       *
       * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation, which
       *   is the row in the above cayley table.
       * @param {GD8Symmetry} rotationFirst - First operation, which
       *   is the column in the above cayley table.
       * @returns {GD8Symmetry} Composed operation
       */
      add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
      /**
       * Reverse of `add`.
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotationSecond - Second operation
       * @param {GD8Symmetry} rotationFirst - First operation
       * @returns {GD8Symmetry} Result
       */
      sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
      /**
       * Adds 180 degrees to rotation, which is a commutative
       * operation.
       * @memberof maths.groupD8
       * @param {number} rotation - The number to rotate.
       * @returns {number} Rotated number
       */
      rotate180: (rotation) => rotation ^ 4,
      /**
       * Checks if the rotation angle is vertical, i.e. south
       * or north. It doesn't work for reflections.
       * @memberof maths.groupD8
       * @param {GD8Symmetry} rotation - The number to check.
       * @returns {boolean} Whether or not the direction is vertical
       */
      isVertical: (rotation) => (rotation & 3) === 2,
      // rotation % 4 === 2
      /**
       * Approximates the vector `V(dx,dy)` into one of the
       * eight directions provided by `groupD8`.
       * @memberof maths.groupD8
       * @param {number} dx - X-component of the vector
       * @param {number} dy - Y-component of the vector
       * @returns {GD8Symmetry} Approximation of the vector into
       *  one of the eight symmetries.
       */
      byDirection: (dx, dy) => {
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
          if (dy >= 0) {
            return groupD8.S;
          }
          return groupD8.N;
        } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
          if (dx > 0) {
            return groupD8.E;
          }
          return groupD8.W;
        } else if (dy > 0) {
          if (dx > 0) {
            return groupD8.SE;
          }
          return groupD8.SW;
        } else if (dx > 0) {
          return groupD8.NE;
        }
        return groupD8.NW;
      },
      /**
       * Helps sprite to compensate texture packer rotation.
       * @memberof maths.groupD8
       * @param {Matrix} matrix - sprite world matrix
       * @param {GD8Symmetry} rotation - The rotation factor to use.
       * @param {number} tx - sprite anchoring
       * @param {number} ty - sprite anchoring
       */
      matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
        const mat = rotationMatrices[groupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
      }
    };
  }
});

// node_modules/pixi.js/lib/utils/misc/NOOP.mjs
var NOOP;
var init_NOOP = __esm({
  "node_modules/pixi.js/lib/utils/misc/NOOP.mjs"() {
    "use strict";
    NOOP = () => {
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/pow2.mjs
function nextPow2(v3) {
  v3 += v3 === 0 ? 1 : 0;
  --v3;
  v3 |= v3 >>> 1;
  v3 |= v3 >>> 2;
  v3 |= v3 >>> 4;
  v3 |= v3 >>> 8;
  v3 |= v3 >>> 16;
  return v3 + 1;
}
function isPow2(v3) {
  return !(v3 & v3 - 1) && !!v3;
}
var init_pow2 = __esm({
  "node_modules/pixi.js/lib/maths/misc/pow2.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs
function definedProps(obj) {
  const result = {};
  for (const key in obj) {
    if (obj[key] !== void 0) {
      result[key] = obj[key];
    }
  }
  return result;
}
var init_definedProps = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/definedProps.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs
function createResourceIdFromString(value) {
  const id2 = idHash[value];
  if (id2 === void 0) {
    idHash[value] = uid("resource");
  }
  return id2;
}
var idHash, _TextureStyle, TextureStyle;
var init_TextureStyle = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs"() {
    init_eventemitter3();
    init_uid();
    init_deprecation();
    idHash = /* @__PURE__ */ Object.create(null);
    _TextureStyle = class _TextureStyle2 extends eventemitter3_default {
      /**
       * @param options - options for the style
       */
      constructor(options = {}) {
        super();
        this._resourceType = "textureSampler";
        this._touched = 0;
        this._maxAnisotropy = 1;
        this.destroyed = false;
        options = { ..._TextureStyle2.defaultOptions, ...options };
        this.addressMode = options.addressMode;
        this.addressModeU = options.addressModeU ?? this.addressModeU;
        this.addressModeV = options.addressModeV ?? this.addressModeV;
        this.addressModeW = options.addressModeW ?? this.addressModeW;
        this.scaleMode = options.scaleMode;
        this.magFilter = options.magFilter ?? this.magFilter;
        this.minFilter = options.minFilter ?? this.minFilter;
        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
        this.lodMinClamp = options.lodMinClamp;
        this.lodMaxClamp = options.lodMaxClamp;
        this.compare = options.compare;
        this.maxAnisotropy = options.maxAnisotropy ?? 1;
      }
      set addressMode(value) {
        this.addressModeU = value;
        this.addressModeV = value;
        this.addressModeW = value;
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this.addressModeU;
      }
      set wrapMode(value) {
        deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
        this.addressMode = value;
      }
      get wrapMode() {
        return this.addressMode;
      }
      set scaleMode(value) {
        this.magFilter = value;
        this.minFilter = value;
        this.mipmapFilter = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this.magFilter;
      }
      /** Specifies the maximum anisotropy value clamp used by the sampler. */
      set maxAnisotropy(value) {
        this._maxAnisotropy = Math.min(value, 16);
        if (this._maxAnisotropy > 1) {
          this.scaleMode = "linear";
        }
      }
      get maxAnisotropy() {
        return this._maxAnisotropy;
      }
      // TODO - move this to WebGL?
      get _resourceId() {
        return this._sharedResourceId || this._generateResourceId();
      }
      update() {
        this.emit("change", this);
        this._sharedResourceId = null;
      }
      _generateResourceId() {
        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        this._sharedResourceId = createResourceIdFromString(bigKey);
        return this._resourceId;
      }
      /** Destroys the style */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this.removeAllListeners();
      }
    };
    _TextureStyle.defaultOptions = {
      addressMode: "clamp-to-edge",
      scaleMode: "linear"
    };
    TextureStyle = _TextureStyle;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs
var _TextureSource, TextureSource;
var init_TextureSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs"() {
    init_eventemitter3();
    init_pow2();
    init_definedProps();
    init_uid();
    init_TextureStyle();
    _TextureSource = class _TextureSource2 extends eventemitter3_default {
      /**
       * @param options - options for creating a new TextureSource
       */
      constructor(options = {}) {
        super();
        this.options = options;
        this.uid = uid("textureSource");
        this._resourceType = "textureSource";
        this._resourceId = uid("resource");
        this.uploadMethodId = "unknown";
        this._resolution = 1;
        this.pixelWidth = 1;
        this.pixelHeight = 1;
        this.width = 1;
        this.height = 1;
        this.sampleCount = 1;
        this.mipLevelCount = 1;
        this.autoGenerateMipmaps = false;
        this.format = "rgba8unorm";
        this.dimension = "2d";
        this.antialias = false;
        this._touched = 0;
        this._batchTick = -1;
        this._textureBindLocation = -1;
        options = { ..._TextureSource2.defaultOptions, ...options };
        this.label = options.label ?? "";
        this.resource = options.resource;
        this.autoGarbageCollect = options.autoGarbageCollect;
        this._resolution = options.resolution;
        if (options.width) {
          this.pixelWidth = options.width * this._resolution;
        } else {
          this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
        }
        if (options.height) {
          this.pixelHeight = options.height * this._resolution;
        } else {
          this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
        }
        this.width = this.pixelWidth / this._resolution;
        this.height = this.pixelHeight / this._resolution;
        this.format = options.format;
        this.dimension = options.dimensions;
        this.mipLevelCount = options.mipLevelCount;
        this.autoGenerateMipmaps = options.autoGenerateMipmaps;
        this.sampleCount = options.sampleCount;
        this.antialias = options.antialias;
        this.alphaMode = options.alphaMode;
        this.style = new TextureStyle(definedProps(options));
        this.destroyed = false;
        this._refreshPOT();
      }
      /** returns itself */
      get source() {
        return this;
      }
      /** the style of the texture */
      get style() {
        return this._style;
      }
      set style(value) {
        if (this.style === value)
          return;
        this._style?.off("change", this._onStyleChange, this);
        this._style = value;
        this._style?.on("change", this._onStyleChange, this);
        this._onStyleChange();
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get addressMode() {
        return this._style.addressMode;
      }
      set addressMode(value) {
        this._style.addressMode = value;
      }
      /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
      get repeatMode() {
        return this._style.addressMode;
      }
      set repeatMode(value) {
        this._style.addressMode = value;
      }
      /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
      get magFilter() {
        return this._style.magFilter;
      }
      set magFilter(value) {
        this._style.magFilter = value;
      }
      /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
      get minFilter() {
        return this._style.minFilter;
      }
      set minFilter(value) {
        this._style.minFilter = value;
      }
      /** Specifies behavior for sampling between mipmap levels. */
      get mipmapFilter() {
        return this._style.mipmapFilter;
      }
      set mipmapFilter(value) {
        this._style.mipmapFilter = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMinClamp() {
        return this._style.lodMinClamp;
      }
      set lodMinClamp(value) {
        this._style.lodMinClamp = value;
      }
      /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
      get lodMaxClamp() {
        return this._style.lodMaxClamp;
      }
      set lodMaxClamp(value) {
        this._style.lodMaxClamp = value;
      }
      _onStyleChange() {
        this.emit("styleChange", this);
      }
      /** call this if you have modified the texture outside of the constructor */
      update() {
        if (this.resource) {
          const resolution = this._resolution;
          const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);
          if (didResize)
            return;
        }
        this.emit("update", this);
      }
      /** Destroys this texture source */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        if (this._style) {
          this._style.destroy();
          this._style = null;
        }
        this.uploadMethodId = null;
        this.resource = null;
        this.removeAllListeners();
      }
      /**
       * This will unload the Texture source from the GPU. This will free up the GPU memory
       * As soon as it is required fore rendering, it will be re-uploaded.
       */
      unload() {
        this._resourceId = uid("resource");
        this.emit("change", this);
        this.emit("unload", this);
      }
      /** the width of the resource. This is the REAL pure number, not accounting resolution   */
      get resourceWidth() {
        const { resource } = this;
        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
      }
      /** the height of the resource. This is the REAL pure number, not accounting resolution */
      get resourceHeight() {
        const { resource } = this;
        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
      }
      /**
       * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
       * but will the size of the texture when rendered.
       *
       * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
       * density will have increased)
       */
      get resolution() {
        return this._resolution;
      }
      set resolution(resolution) {
        if (this._resolution === resolution)
          return;
        this._resolution = resolution;
        this.width = this.pixelWidth / resolution;
        this.height = this.pixelHeight / resolution;
      }
      /**
       * Resize the texture, this is handy if you want to use the texture as a render texture
       * @param width - the new width of the texture
       * @param height - the new height of the texture
       * @param resolution - the new resolution of the texture
       * @returns - if the texture was resized
       */
      resize(width, height, resolution) {
        resolution = resolution || this._resolution;
        width = width || this.width;
        height = height || this.height;
        const newPixelWidth = Math.round(width * resolution);
        const newPixelHeight = Math.round(height * resolution);
        this.width = newPixelWidth / resolution;
        this.height = newPixelHeight / resolution;
        this._resolution = resolution;
        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
          return false;
        }
        this._refreshPOT();
        this.pixelWidth = newPixelWidth;
        this.pixelHeight = newPixelHeight;
        this.emit("resize", this);
        this._resourceId = uid("resource");
        this.emit("change", this);
        return true;
      }
      /**
       * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
       * This is only important for RenderTexture instances, as standard Texture instances will have their
       * mipmaps generated on upload. You should call this method after you make any change to the texture
       *
       * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
       * We want you, the developer to specify when this action should happen.
       *
       * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
       */
      updateMipmaps() {
        if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
          this.emit("updateMipmaps", this);
        }
      }
      set wrapMode(value) {
        this._style.wrapMode = value;
      }
      get wrapMode() {
        return this._style.wrapMode;
      }
      set scaleMode(value) {
        this._style.scaleMode = value;
      }
      /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
      get scaleMode() {
        return this._style.scaleMode;
      }
      /**
       * Refresh check for isPowerOfTwo texture based on size
       * @private
       */
      _refreshPOT() {
        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
      }
      static test(_resource) {
        throw new Error("Unimplemented");
      }
    };
    _TextureSource.defaultOptions = {
      resolution: 1,
      format: "bgra8unorm",
      alphaMode: "premultiply-alpha-on-upload",
      dimensions: "2d",
      mipLevelCount: 1,
      autoGenerateMipmaps: false,
      sampleCount: 1,
      antialias: false,
      autoGarbageCollect: false
    };
    TextureSource = _TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs
var BufferImageSource;
var init_BufferImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs"() {
    init_Extensions();
    init_TextureSource();
    BufferImageSource = class extends TextureSource {
      constructor(options) {
        const buffer = options.resource || new Float32Array(options.width * options.height * 4);
        let format2 = options.format;
        if (!format2) {
          if (buffer instanceof Float32Array) {
            format2 = "rgba32float";
          } else if (buffer instanceof Int32Array) {
            format2 = "rgba32uint";
          } else if (buffer instanceof Uint32Array) {
            format2 = "rgba32uint";
          } else if (buffer instanceof Int16Array) {
            format2 = "rgba16uint";
          } else if (buffer instanceof Uint16Array) {
            format2 = "rgba16uint";
          } else if (buffer instanceof Int8Array) {
            format2 = "bgra8unorm";
          } else {
            format2 = "bgra8unorm";
          }
        }
        super({
          ...options,
          resource: buffer,
          format: format2
        });
        this.uploadMethodId = "buffer";
      }
      static test(resource) {
        return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
      }
    };
    BufferImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs
var tempMat, TextureMatrix;
var init_TextureMatrix = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs"() {
    init_Matrix();
    tempMat = new Matrix();
    TextureMatrix = class {
      /**
       * @param texture - observed texture
       * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
       */
      constructor(texture, clampMargin) {
        this.mapCoord = new Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        this._textureID = -1;
        this._updateID = 0;
        this.clampOffset = 0;
        if (typeof clampMargin === "undefined") {
          this.clampMargin = texture.width < 10 ? 0 : 0.5;
        } else {
          this.clampMargin = clampMargin;
        }
        this.isSimple = false;
        this.texture = texture;
      }
      /** Texture property. */
      get texture() {
        return this._texture;
      }
      set texture(value) {
        if (this.texture === value)
          return;
        this._texture?.removeListener("update", this.update, this);
        this._texture = value;
        this._texture.addListener("update", this.update, this);
        this.update();
      }
      /**
       * Multiplies uvs array to transform
       * @param uvs - mesh uvs
       * @param [out=uvs] - output
       * @returns - output
       */
      multiplyUvs(uvs, out2) {
        if (out2 === void 0) {
          out2 = uvs;
        }
        const mat = this.mapCoord;
        for (let i2 = 0; i2 < uvs.length; i2 += 2) {
          const x5 = uvs[i2];
          const y4 = uvs[i2 + 1];
          out2[i2] = x5 * mat.a + y4 * mat.c + mat.tx;
          out2[i2 + 1] = x5 * mat.b + y4 * mat.d + mat.ty;
        }
        return out2;
      }
      /**
       * Updates matrices if texture was changed
       * @returns - whether or not it was updated
       */
      update() {
        const tex = this._texture;
        this._updateID++;
        const uvs = tex.uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        const orig = tex.orig;
        const trim = tex.trim;
        if (trim) {
          tempMat.set(
            orig.width / trim.width,
            0,
            0,
            orig.height / trim.height,
            -trim.x / trim.width,
            -trim.y / trim.height
          );
          this.mapCoord.append(tempMat);
        }
        const texBase = tex.source;
        const frame2 = this.uClampFrame;
        const margin = this.clampMargin / texBase._resolution;
        const offset = this.clampOffset / texBase._resolution;
        frame2[0] = (tex.frame.x + margin + offset) / texBase.width;
        frame2[1] = (tex.frame.y + margin + offset) / texBase.height;
        frame2[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
        frame2[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
        this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
        return true;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs
var Texture;
var init_Texture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs"() {
    init_eventemitter3();
    init_groupD8();
    init_Rectangle();
    init_uid();
    init_deprecation();
    init_NOOP();
    init_BufferImageSource();
    init_TextureSource();
    init_TextureMatrix();
    Texture = class extends eventemitter3_default {
      /**
       * @param {rendering.TextureOptions} options - Options for the texture
       */
      constructor({
        source: source2,
        label,
        frame: frame2,
        orig,
        trim,
        defaultAnchor,
        defaultBorders,
        rotate,
        dynamic
      } = {}) {
        super();
        this.uid = uid("texture");
        this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
        this.frame = new Rectangle();
        this.noFrame = false;
        this.dynamic = false;
        this.isTexture = true;
        this.label = label;
        this.source = source2?.source ?? new TextureSource();
        this.noFrame = !frame2;
        if (frame2) {
          this.frame.copyFrom(frame2);
        } else {
          const { width, height } = this._source;
          this.frame.width = width;
          this.frame.height = height;
        }
        this.orig = orig || this.frame;
        this.trim = trim;
        this.rotate = rotate ?? 0;
        this.defaultAnchor = defaultAnchor;
        this.defaultBorders = defaultBorders;
        this.destroyed = false;
        this.dynamic = dynamic || false;
        this.updateUvs();
      }
      set source(value) {
        if (this._source) {
          this._source.off("resize", this.update, this);
        }
        this._source = value;
        value.on("resize", this.update, this);
        this.emit("update", this);
      }
      /** the underlying source of the texture (equivalent of baseTexture in v7) */
      get source() {
        return this._source;
      }
      /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
      get textureMatrix() {
        if (!this._textureMatrix) {
          this._textureMatrix = new TextureMatrix(this);
        }
        return this._textureMatrix;
      }
      /** The width of the Texture in pixels. */
      get width() {
        return this.orig.width;
      }
      /** The height of the Texture in pixels. */
      get height() {
        return this.orig.height;
      }
      /** Call this function when you have modified the frame of this texture. */
      updateUvs() {
        const { uvs, frame: frame2 } = this;
        const { width, height } = this._source;
        const nX = frame2.x / width;
        const nY = frame2.y / height;
        const nW = frame2.width / width;
        const nH = frame2.height / height;
        let rotate = this.rotate;
        if (rotate) {
          const w2 = nW / 2;
          const h2 = nH / 2;
          const cX = nX + w2;
          const cY = nY + h2;
          rotate = groupD8.add(rotate, groupD8.NW);
          uvs.x0 = cX + w2 * groupD8.uX(rotate);
          uvs.y0 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x1 = cX + w2 * groupD8.uX(rotate);
          uvs.y1 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x2 = cX + w2 * groupD8.uX(rotate);
          uvs.y2 = cY + h2 * groupD8.uY(rotate);
          rotate = groupD8.add(rotate, 2);
          uvs.x3 = cX + w2 * groupD8.uX(rotate);
          uvs.y3 = cY + h2 * groupD8.uY(rotate);
        } else {
          uvs.x0 = nX;
          uvs.y0 = nY;
          uvs.x1 = nX + nW;
          uvs.y1 = nY;
          uvs.x2 = nX + nW;
          uvs.y2 = nY + nH;
          uvs.x3 = nX;
          uvs.y3 = nY + nH;
        }
      }
      /**
       * Destroys this texture
       * @param destroySource - Destroy the source when the texture is destroyed.
       */
      destroy(destroySource = false) {
        if (this._source) {
          if (destroySource) {
            this._source.destroy();
            this._source = null;
          }
        }
        this._textureMatrix = null;
        this.destroyed = true;
        this.emit("destroy", this);
        this.removeAllListeners();
      }
      /** call this if you have modified the `texture outside` of the constructor */
      update() {
        if (this.noFrame) {
          this.frame.width = this._source.width;
          this.frame.height = this._source.height;
        }
        this.updateUvs();
        this.emit("update", this);
      }
      /** @deprecated since 8.0.0 */
      get baseTexture() {
        deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
        return this._source;
      }
    };
    Texture.EMPTY = new Texture({
      label: "EMPTY",
      source: new TextureSource({
        label: "EMPTY"
      })
    });
    Texture.EMPTY.destroy = NOOP;
    Texture.WHITE = new Texture({
      source: new BufferImageSource({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE"
      }),
      label: "WHITE"
    });
    Texture.WHITE.destroy = NOOP;
  }
});

// node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs
var _Spritesheet, Spritesheet;
var init_Spritesheet = __esm({
  "node_modules/pixi.js/lib/spritesheet/Spritesheet.mjs"() {
    init_Rectangle();
    init_Texture();
    _Spritesheet = class _Spritesheet2 {
      /**
       * @param texture - Reference to the source BaseTexture object.
       * @param {object} data - Spritesheet image data.
       */
      constructor(texture, data) {
        this.linkedSheets = [];
        this._texture = texture instanceof Texture ? texture : null;
        this.textureSource = texture.source;
        this.textures = {};
        this.animations = {};
        this.data = data;
        const metaResolution = parseFloat(data.meta.scale);
        if (metaResolution) {
          this.resolution = metaResolution;
          texture.source.resolution = this.resolution;
        } else {
          this.resolution = texture.source._resolution;
        }
        this._frames = this.data.frames;
        this._frameKeys = Object.keys(this._frames);
        this._batchIndex = 0;
        this._callback = null;
      }
      /**
       * Parser spritesheet from loaded data. This is done asynchronously
       * to prevent creating too many Texture within a single process.
       */
      parse() {
        return new Promise((resolve) => {
          this._callback = resolve;
          this._batchIndex = 0;
          if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
          } else {
            this._nextBatch();
          }
        });
      }
      /**
       * Process a batch of frames
       * @param initialFrameIndex - The index of frame to start.
       */
      _processFrames(initialFrameIndex) {
        let frameIndex = initialFrameIndex;
        const maxFrames = _Spritesheet2.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
          const i2 = this._frameKeys[frameIndex];
          const data = this._frames[i2];
          const rect = data.frame;
          if (rect) {
            let frame2 = null;
            let trim = null;
            const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
            const orig = new Rectangle(
              0,
              0,
              Math.floor(sourceSize.w) / this.resolution,
              Math.floor(sourceSize.h) / this.resolution
            );
            if (data.rotated) {
              frame2 = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.h) / this.resolution,
                Math.floor(rect.w) / this.resolution
              );
            } else {
              frame2 = new Rectangle(
                Math.floor(rect.x) / this.resolution,
                Math.floor(rect.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            if (data.trimmed !== false && data.spriteSourceSize) {
              trim = new Rectangle(
                Math.floor(data.spriteSourceSize.x) / this.resolution,
                Math.floor(data.spriteSourceSize.y) / this.resolution,
                Math.floor(rect.w) / this.resolution,
                Math.floor(rect.h) / this.resolution
              );
            }
            this.textures[i2] = new Texture({
              source: this.textureSource,
              frame: frame2,
              orig,
              trim,
              rotate: data.rotated ? 2 : 0,
              defaultAnchor: data.anchor,
              defaultBorders: data.borders,
              label: i2.toString()
            });
          }
          frameIndex++;
        }
      }
      /** Parse animations config. */
      _processAnimations() {
        const animations = this.data.animations || {};
        for (const animName in animations) {
          this.animations[animName] = [];
          for (let i2 = 0; i2 < animations[animName].length; i2++) {
            const frameName = animations[animName][i2];
            this.animations[animName].push(this.textures[frameName]);
          }
        }
      }
      /** The parse has completed. */
      _parseComplete() {
        const callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
      }
      /** Begin the next batch of textures. */
      _nextBatch() {
        this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(() => {
          if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
            this._nextBatch();
          } else {
            this._processAnimations();
            this._parseComplete();
          }
        }, 0);
      }
      /**
       * Destroy Spritesheet and don't use after this.
       * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
       */
      destroy(destroyBase = false) {
        for (const i2 in this.textures) {
          this.textures[i2].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
          this._texture?.destroy();
          this.textureSource.destroy();
        }
        this._texture = null;
        this.textureSource = null;
        this.linkedSheets = [];
      }
    };
    _Spritesheet.BATCH_SIZE = 1e3;
    Spritesheet = _Spritesheet;
  }
});

// node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs
function getCacheableAssets(keys2, asset, ignoreMultiPack) {
  const out2 = {};
  keys2.forEach((key) => {
    out2[key] = asset;
  });
  Object.keys(asset.textures).forEach((key) => {
    out2[key] = asset.textures[key];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys2[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
var validImages, spritesheetAsset;
var init_spritesheetAsset = __esm({
  "node_modules/pixi.js/lib/spritesheet/spritesheetAsset.mjs"() {
    init_LoaderParser();
    init_Resolver();
    init_copySearchParams();
    init_Extensions();
    init_Texture();
    init_path();
    init_Spritesheet();
    validImages = [
      "jpg",
      "png",
      "jpeg",
      "avif",
      "webp",
      "basis",
      "etc2",
      "bc7",
      "bc6h",
      "bc5",
      "bc4",
      "bc3",
      "bc2",
      "bc1",
      "eac",
      "astc"
    ];
    spritesheetAsset = {
      extension: ExtensionType.Asset,
      /** Handle the caching of the related Spritesheet Textures */
      cache: {
        test: (asset) => asset instanceof Spritesheet,
        getCacheableAssets: (keys2, asset) => getCacheableAssets(keys2, asset, false)
      },
      /** Resolve the resolution of the asset. */
      resolver: {
        extension: {
          type: ExtensionType.ResolveParser,
          name: "resolveSpritesheet"
        },
        test: (value) => {
          const tempURL = value.split("?")[0];
          const split = tempURL.split(".");
          const extension = split.pop();
          const format2 = split.pop();
          return extension === "json" && validImages.includes(format2);
        },
        parse: (value) => {
          const split = value.split(".");
          return {
            resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"),
            format: split[split.length - 2],
            src: value
          };
        }
      },
      /**
       * Loader plugin that parses sprite sheets!
       * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
       * If it is, we load the spritesheets image and parse the data into Spritesheet
       * All textures in the sprite sheet are then added to the cache
       */
      loader: {
        name: "spritesheetLoader",
        extension: {
          type: ExtensionType.LoadParser,
          priority: LoaderParserPriority.Normal,
          name: "spritesheetLoader"
        },
        async testParse(asset, options) {
          return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
        },
        async parse(asset, options, loader) {
          const {
            texture: imageTexture,
            // if user need to use preloaded texture
            imageFilename
            // if user need to use custom filename (not from jsonFile.meta.image)
          } = options?.data ?? {};
          let basePath = path.dirname(options.src);
          if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
            basePath += "/";
          }
          let texture;
          if (imageTexture instanceof Texture) {
            texture = imageTexture;
          } else {
            const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
            const assets = await loader.load([imagePath]);
            texture = assets[imagePath];
          }
          const spritesheet = new Spritesheet(
            texture.source,
            asset
          );
          await spritesheet.parse();
          const multiPacks = asset?.meta?.related_multi_packs;
          if (Array.isArray(multiPacks)) {
            const promises = [];
            for (const item of multiPacks) {
              if (typeof item !== "string") {
                continue;
              }
              let itemUrl = basePath + item;
              if (options.data?.ignoreMultiPack) {
                continue;
              }
              itemUrl = copySearchParams(itemUrl, options.src);
              promises.push(loader.load({
                src: itemUrl,
                data: {
                  ignoreMultiPack: true
                }
              }));
            }
            const res = await Promise.all(promises);
            spritesheet.linkedSheets = res;
            res.forEach((item) => {
              item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
            });
          }
          return spritesheet;
        },
        async unload(spritesheet, _resolvedAsset, loader) {
          await loader.unload(spritesheet.textureSource._sourceOrigin);
          spritesheet.destroy(false);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/spritesheet/init.mjs
var init_init4 = __esm({
  "node_modules/pixi.js/lib/spritesheet/init.mjs"() {
    init_Extensions();
    init_spritesheetAsset();
    extensions.add(spritesheetAsset);
  }
});

// node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs
function updateQuadBounds(bounds, anchor, texture, padding) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor._x * width - padding;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor._y * height - padding;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor._x * width - padding;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height - padding;
    bounds.maxY = bounds.minY + height;
  }
  return;
}
var init_updateQuadBounds = __esm({
  "node_modules/pixi.js/lib/utils/data/updateQuadBounds.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/view/View.mjs
var ViewContainer;
var init_View = __esm({
  "node_modules/pixi.js/lib/scene/view/View.mjs"() {
    init_Bounds();
    init_Container();
    ViewContainer = class extends Container {
      constructor() {
        super(...arguments);
        this.canBundle = true;
        this.allowChildren = false;
        this._roundPixels = 0;
        this._lastUsed = 0;
        this._lastInstructionTick = -1;
        this._bounds = new Bounds(0, 1, 0, 0);
        this._boundsDirty = true;
      }
      /** @private */
      _updateBounds() {
      }
      /**
       * Whether or not to round the x/y position of the sprite.
       * @type {boolean}
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      set roundPixels(value) {
        this._roundPixels = value ? 1 : 0;
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const bounds = this.bounds;
        const { x: x5, y: y4 } = point;
        return x5 >= bounds.minX && x5 <= bounds.maxX && y4 >= bounds.minY && y4 <= bounds.maxY;
      }
      destroy(options) {
        super.destroy(options);
        this._bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite/Sprite.mjs
var Sprite;
var init_Sprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/Sprite.mjs"() {
    init_ObservablePoint();
    init_Texture();
    init_updateQuadBounds();
    init_View();
    Sprite = class _Sprite extends ViewContainer {
      /**
       * @param options - The options for creating the sprite.
       */
      constructor(options = Texture.EMPTY) {
        if (options instanceof Texture) {
          options = { texture: options };
        }
        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;
        super({
          label: "Sprite",
          ...rest
        });
        this.renderPipeId = "sprite";
        this.batched = true;
        this._didSpriteUpdate = false;
        this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        this._sourceBoundsDirty = true;
        this._anchor = new ObservablePoint(
          {
            _onUpdate: () => {
              this.onViewUpdate();
            }
          }
        );
        if (anchor) {
          this.anchor = anchor;
        } else if (texture.defaultAnchor) {
          this.anchor = texture.defaultAnchor;
        }
        this.texture = texture;
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
        if (width !== void 0)
          this.width = width;
        if (height !== void 0)
          this.height = height;
      }
      /**
       * Helper function that creates a new sprite based on the source you provide.
       * The source can be - frame id, image, video, canvas element, video element, texture
       * @param source - Source to create texture from
       * @param [skipCache] - Whether to skip the cache or not
       * @returns The newly created sprite
       */
      static from(source2, skipCache = false) {
        if (source2 instanceof Texture) {
          return new _Sprite(source2);
        }
        return new _Sprite(Texture.from(source2, skipCache));
      }
      set texture(value) {
        value || (value = Texture.EMPTY);
        const currentTexture = this._texture;
        if (currentTexture === value)
          return;
        if (currentTexture && currentTexture.dynamic)
          currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic)
          value.on("update", this.onViewUpdate, this);
        this._texture = value;
        if (this._width) {
          this._setWidth(this._width, this._texture.orig.width);
        }
        if (this._height) {
          this._setHeight(this._height, this._texture.orig.height);
        }
        this.onViewUpdate();
      }
      /** The texture that the sprite is using. */
      get texture() {
        return this._texture;
      }
      /**
       * The local bounds of the sprite.
       * @type {rendering.Bounds}
       */
      get bounds() {
        if (this._boundsDirty) {
          this._updateBounds();
          this._boundsDirty = false;
        }
        return this._bounds;
      }
      /**
       * The bounds of the sprite, taking the texture's trim into account.
       * @type {rendering.Bounds}
       */
      get sourceBounds() {
        if (this._sourceBoundsDirty) {
          this._updateSourceBounds();
          this._sourceBoundsDirty = false;
        }
        return this._sourceBounds;
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        const bounds = this.sourceBounds;
        if (point.x >= bounds.maxX && point.x <= bounds.minX) {
          if (point.y >= bounds.maxY && point.y <= bounds.minY) {
            return true;
          }
        }
        return false;
      }
      /**
       * Adds the bounds of this object to the bounds object.
       * @param bounds - The output bounds object.
       */
      addBounds(bounds) {
        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;
        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);
      }
      onViewUpdate() {
        this._didViewChangeTick++;
        this._didSpriteUpdate = true;
        this._sourceBoundsDirty = this._boundsDirty = true;
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.onChildViewUpdate(this);
        }
      }
      _updateBounds() {
        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);
      }
      _updateSourceBounds() {
        const anchor = this._anchor;
        const texture = this._texture;
        const sourceBounds = this._sourceBounds;
        const { width, height } = texture.orig;
        sourceBounds.maxX = -anchor._x * width;
        sourceBounds.minX = sourceBounds.maxX + width;
        sourceBounds.maxY = -anchor._y * height;
        sourceBounds.minY = sourceBounds.maxY + height;
      }
      /**
       * Destroys this sprite renderable and optionally its texture.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
       */
      destroy(options = false) {
        super.destroy(options);
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          this._texture.destroy(destroyTextureSource);
        }
        this._texture = null;
        this._bounds = null;
        this._sourceBounds = null;
        this._anchor = null;
      }
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * import { Sprite } from 'pixi.js';
       *
       * const sprite = new Sprite({texture: Texture.WHITE});
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        this._setWidth(value, this._texture.orig.width);
        this._width = value;
      }
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        this._setHeight(value, this._texture.orig.height);
        this._height = value;
      }
      /**
       * Retrieves the size of the Sprite as a [Size]{@link Size} object.
       * This is faster than get the width and height separately.
       * @param out - Optional object to store the size in.
       * @returns - The size of the Sprite.
       */
      getSize(out2) {
        out2 || (out2 = {});
        out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
        out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
        return out2;
      }
      /**
       * Sets the size of the Sprite to the specified width and height.
       * This is faster than setting the width and height separately.
       * @param value - This can be either a number or a [Size]{@link Size} object.
       * @param height - The height to set. Defaults to the value of `width` if not provided.
       */
      setSize(value, height) {
        if (typeof value === "object") {
          height = value.height ?? value.width;
          value = value.width;
        } else {
          height ?? (height = value);
        }
        value !== void 0 && this._setWidth(value, this._texture.orig.width);
        height !== void 0 && this._setHeight(height, this._texture.orig.height);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
var tempBounds;
var init_addMaskBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs"() {
    init_Bounds();
    init_getGlobalBounds();
    tempBounds = new Bounds();
  }
});

// node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix6 = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix6);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix6);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root3, matrix) {
  if (!target) {
    warn("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root3) {
    getMatrixRelativeToParent(target.parent, root3, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}
var init_addMaskLocalBounds = __esm({
  "node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs"() {
    init_getLocalBounds();
    init_matrixAndBoundsPool();
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs
var AlphaMask;
var init_AlphaMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs"() {
    init_Extensions();
    init_Sprite();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    AlphaMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "alphaMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.renderMaskToTexture = !(mask instanceof Sprite);
        this.mask.renderable = this.renderMaskToTexture;
        this.mask.includeInBuild = !this.renderMaskToTexture;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Sprite;
      }
    };
    AlphaMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs
var ColorMask;
var init_ColorMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs"() {
    init_Extensions();
    ColorMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "colorMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
      }
      destroy() {
      }
      static test(mask) {
        return typeof mask === "number";
      }
    };
    ColorMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs
var StencilMask;
var init_StencilMask = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs"() {
    init_Extensions();
    init_Container();
    init_addMaskBounds();
    init_addMaskLocalBounds();
    StencilMask = class {
      constructor(options) {
        this.priority = 0;
        this.pipe = "stencilMask";
        if (options?.mask) {
          this.init(options.mask);
        }
      }
      init(mask) {
        this.mask = mask;
        this.mask.includeInBuild = false;
        this.mask.measurable = false;
      }
      reset() {
        this.mask.measurable = true;
        this.mask.includeInBuild = true;
        this.mask = null;
      }
      addBounds(bounds, skipUpdateTransform) {
        addMaskBounds(this.mask, bounds, skipUpdateTransform);
      }
      addLocalBounds(bounds, localRoot) {
        addMaskLocalBounds(this.mask, bounds, localRoot);
      }
      containsPoint(point, hitTestFn) {
        const mask = this.mask;
        return hitTestFn(mask, point);
      }
      destroy() {
        this.reset();
      }
      static test(mask) {
        return mask instanceof Container;
      }
    };
    StencilMask.extension = ExtensionType.MaskEffect;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs
var CanvasSource;
var init_CanvasSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs"() {
    init_adapter();
    init_Extensions();
    init_TextureSource();
    CanvasSource = class extends TextureSource {
      constructor(options) {
        if (!options.resource) {
          options.resource = DOMAdapter.get().createCanvas();
        }
        if (!options.width) {
          options.width = options.resource.width;
          if (!options.autoDensity) {
            options.width /= options.resolution;
          }
        }
        if (!options.height) {
          options.height = options.resource.height;
          if (!options.autoDensity) {
            options.height /= options.resolution;
          }
        }
        super(options);
        this.uploadMethodId = "image";
        this.autoDensity = options.autoDensity;
        const canvas = options.resource;
        if (this.pixelWidth !== canvas.width || this.pixelWidth !== canvas.height) {
          this.resizeCanvas();
        }
        this.transparent = !!options.transparent;
      }
      resizeCanvas() {
        if (this.autoDensity) {
          this.resource.style.width = `${this.width}px`;
          this.resource.style.height = `${this.height}px`;
        }
        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
          this.resource.width = this.pixelWidth;
          this.resource.height = this.pixelHeight;
        }
      }
      resize(width = this.width, height = this.height, resolution = this._resolution) {
        const didResize = super.resize(width, height, resolution);
        if (didResize) {
          this.resizeCanvas();
        }
        return didResize;
      }
      static test(resource) {
        return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
      }
    };
    CanvasSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs
var ImageSource;
var init_ImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs"() {
    init_adapter();
    init_Extensions();
    init_warn();
    init_TextureSource();
    ImageSource = class extends TextureSource {
      constructor(options) {
        if (options.resource && (globalThis.HTMLImageElement && options.resource instanceof HTMLImageElement)) {
          const canvas = DOMAdapter.get().createCanvas(options.resource.width, options.resource.height);
          const context2 = canvas.getContext("2d");
          context2.drawImage(options.resource, 0, 0, options.resource.width, options.resource.height);
          options.resource = canvas;
          warn("ImageSource: Image element passed, converting to canvas. Use CanvasSource instead.");
        }
        super(options);
        this.uploadMethodId = "image";
        this.autoGarbageCollect = true;
      }
      static test(resource) {
        return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
      }
    };
    ImageSource.extension = ExtensionType.TextureSource;
  }
});

// node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    gl.getExtension("WEBGL_lose_context")?.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
var promise;
var init_detectVideoAlphaMode = __esm({
  "node_modules/pixi.js/lib/utils/browser/detectVideoAlphaMode.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs
var _VideoSource, VideoSource;
var init_VideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs"() {
    init_Extensions();
    init_Ticker();
    init_detectVideoAlphaMode();
    init_TextureSource();
    _VideoSource = class _VideoSource2 extends TextureSource {
      constructor(options) {
        super(options);
        this.isReady = false;
        this.uploadMethodId = "video";
        options = {
          ..._VideoSource2.defaultOptions,
          ...options
        };
        this._autoUpdate = true;
        this._isConnectedToTicker = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        this.autoPlay = options.autoPlay !== false;
        this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
        this._videoFrameRequestCallbackHandle = null;
        this._load = null;
        this._resolve = null;
        this._reject = null;
        this._onCanPlay = this._onCanPlay.bind(this);
        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
        this._onError = this._onError.bind(this);
        this._onPlayStart = this._onPlayStart.bind(this);
        this._onPlayStop = this._onPlayStop.bind(this);
        this._onSeeked = this._onSeeked.bind(this);
        if (options.autoLoad !== false) {
          void this.load();
        }
      }
      /** Update the video frame if the source is not destroyed and meets certain conditions. */
      updateFrame() {
        if (this.destroyed) {
          return;
        }
        if (this._updateFPS) {
          const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
        }
        if (!this._updateFPS || this._msToNextUpdate <= 0) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        if (this.isValid) {
          this.update();
        }
      }
      /** Callback to update the video frame and potentially request the next frame update. */
      _videoFrameRequestCallback() {
        this.updateFrame();
        if (this.destroyed) {
          this._videoFrameRequestCallbackHandle = null;
        } else {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      }
      /**
       * Checks if the resource has valid dimensions.
       * @returns {boolean} True if width and height are set, otherwise false.
       */
      get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight;
      }
      /**
       * Start preloading the video resource.
       * @returns {Promise<this>} Handle the validate event
       */
      async load() {
        if (this._load) {
          return this._load;
        }
        const source2 = this.resource;
        const options = this.options;
        if ((source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height) {
          source2.complete = true;
        }
        source2.addEventListener("play", this._onPlayStart);
        source2.addEventListener("pause", this._onPlayStop);
        source2.addEventListener("seeked", this._onSeeked);
        if (!this._isSourceReady()) {
          if (!options.preload) {
            source2.addEventListener("canplay", this._onCanPlay);
          }
          source2.addEventListener("canplaythrough", this._onCanPlayThrough);
          source2.addEventListener("error", this._onError, true);
        } else {
          this._mediaReady();
        }
        this.alphaMode = await detectVideoAlphaMode();
        this._load = new Promise((resolve, reject) => {
          if (this.isValid) {
            resolve(this);
          } else {
            this._resolve = resolve;
            this._reject = reject;
            if (options.preloadTimeoutMs !== void 0) {
              this._preloadTimeout = setTimeout(() => {
                this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
              });
            }
            source2.load();
          }
        });
        return this._load;
      }
      /**
       * Handle video error events.
       * @param event - The error event
       */
      _onError(event) {
        this.resource.removeEventListener("error", this._onError, true);
        this.emit("error", event);
        if (this._reject) {
          this._reject(event);
          this._reject = null;
          this._resolve = null;
        }
      }
      /**
       * Checks if the underlying source is playing.
       * @returns True if playing.
       */
      _isSourcePlaying() {
        const source2 = this.resource;
        return !source2.paused && !source2.ended;
      }
      /**
       * Checks if the underlying source is ready for playing.
       * @returns True if ready.
       */
      _isSourceReady() {
        const source2 = this.resource;
        return source2.readyState > 2;
      }
      /** Runs the update loop when the video is ready to play. */
      _onPlayStart() {
        if (!this.isValid) {
          this._mediaReady();
        }
        this._configureAutoUpdate();
      }
      /** Stops the update loop when a pause event is triggered. */
      _onPlayStop() {
        this._configureAutoUpdate();
      }
      /** Handles behavior when the video completes seeking to the current playback position. */
      _onSeeked() {
        if (this._autoUpdate && !this._isSourcePlaying()) {
          this._msToNextUpdate = 0;
          this.updateFrame();
          this._msToNextUpdate = 0;
        }
      }
      _onCanPlay() {
        const source2 = this.resource;
        source2.removeEventListener("canplay", this._onCanPlay);
        this._mediaReady();
      }
      _onCanPlayThrough() {
        const source2 = this.resource;
        source2.removeEventListener("canplaythrough", this._onCanPlay);
        if (this._preloadTimeout) {
          clearTimeout(this._preloadTimeout);
          this._preloadTimeout = void 0;
        }
        this._mediaReady();
      }
      /** Fired when the video is loaded and ready to play. */
      _mediaReady() {
        const source2 = this.resource;
        if (this.isValid) {
          this.isReady = true;
          this.resize(source2.videoWidth, source2.videoHeight);
        }
        this._msToNextUpdate = 0;
        this.updateFrame();
        this._msToNextUpdate = 0;
        if (this._resolve) {
          this._resolve(this);
          this._resolve = null;
          this._reject = null;
        }
        if (this._isSourcePlaying()) {
          this._onPlayStart();
        } else if (this.autoPlay) {
          void this.resource.play();
        }
      }
      /** Cleans up resources and event listeners associated with this texture. */
      destroy() {
        this._configureAutoUpdate();
        const source2 = this.resource;
        if (source2) {
          source2.removeEventListener("play", this._onPlayStart);
          source2.removeEventListener("pause", this._onPlayStop);
          source2.removeEventListener("seeked", this._onSeeked);
          source2.removeEventListener("canplay", this._onCanPlay);
          source2.removeEventListener("canplaythrough", this._onCanPlayThrough);
          source2.removeEventListener("error", this._onError, true);
          source2.pause();
          source2.src = "";
          source2.load();
        }
        super.destroy();
      }
      /** Should the base texture automatically update itself, set to true by default. */
      get autoUpdate() {
        return this._autoUpdate;
      }
      set autoUpdate(value) {
        if (value !== this._autoUpdate) {
          this._autoUpdate = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * How many times a second to update the texture from the video.
       * Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get updateFPS() {
        return this._updateFPS;
      }
      set updateFPS(value) {
        if (value !== this._updateFPS) {
          this._updateFPS = value;
          this._configureAutoUpdate();
        }
      }
      /**
       * Configures the updating mechanism based on the current state and settings.
       *
       * This method decides between using the browser's native video frame callback or a custom ticker
       * for updating the video frame. It ensures optimal performance and responsiveness
       * based on the video's state, playback status, and the desired frames-per-second setting.
       *
       * - If `_autoUpdate` is enabled and the video source is playing:
       *   - It will prefer the native video frame callback if available and no specific FPS is set.
       *   - Otherwise, it will use a custom ticker for manual updates.
       * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
       */
      _configureAutoUpdate() {
        if (this._autoUpdate && this._isSourcePlaying()) {
          if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
            if (this._isConnectedToTicker) {
              Ticker.shared.remove(this.updateFrame, this);
              this._isConnectedToTicker = false;
              this._msToNextUpdate = 0;
            }
            if (this._videoFrameRequestCallbackHandle === null) {
              this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              );
            }
          } else {
            if (this._videoFrameRequestCallbackHandle !== null) {
              this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
              this._videoFrameRequestCallbackHandle = null;
            }
            if (!this._isConnectedToTicker) {
              Ticker.shared.add(this.updateFrame, this);
              this._isConnectedToTicker = true;
              this._msToNextUpdate = 0;
            }
          }
        } else {
          if (this._videoFrameRequestCallbackHandle !== null) {
            this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
            this._videoFrameRequestCallbackHandle = null;
          }
          if (this._isConnectedToTicker) {
            Ticker.shared.remove(this.updateFrame, this);
            this._isConnectedToTicker = false;
            this._msToNextUpdate = 0;
          }
        }
      }
      static test(resource) {
        return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
      }
    };
    _VideoSource.extension = ExtensionType.TextureSource;
    _VideoSource.defaultOptions = {
      ...TextureSource.defaultOptions,
      /** If true, the video will start loading immediately. */
      autoLoad: true,
      /** If true, the video will start playing as soon as it is loaded. */
      autoPlay: true,
      /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
      updateFPS: 0,
      /** If true, the video will be loaded with the `crossorigin` attribute. */
      crossorigin: true,
      /** If true, the video will loop when it ends. */
      loop: false,
      /** If true, the video will be muted. */
      muted: true,
      /** If true, the video will play inline. */
      playsinline: true,
      /** If true, the video will be preloaded. */
      preload: false
    };
    _VideoSource.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    };
    VideoSource = _VideoSource;
  }
});

// node_modules/pixi.js/lib/assets/cache/Cache.mjs
var CacheClass, Cache;
var init_Cache = __esm({
  "node_modules/pixi.js/lib/assets/cache/Cache.mjs"() {
    init_warn();
    init_convertToList();
    CacheClass = class {
      constructor() {
        this._parsers = [];
        this._cache = /* @__PURE__ */ new Map();
        this._cacheMap = /* @__PURE__ */ new Map();
      }
      /** Clear all entries. */
      reset() {
        this._cacheMap.clear();
        this._cache.clear();
      }
      /**
       * Check if the key exists
       * @param key - The key to check
       */
      has(key) {
        return this._cache.has(key);
      }
      /**
       * Fetch entry by key
       * @param key - The key of the entry to get
       */
      get(key) {
        const result = this._cache.get(key);
        if (!result) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
        }
        return result;
      }
      /**
       * Set a value by key or keys name
       * @param key - The key or keys to set
       * @param value - The value to store in the cache or from which cacheable assets will be derived.
       */
      set(key, value) {
        const keys2 = convertToList(key);
        let cacheableAssets;
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parser = this.parsers[i2];
          if (parser.test(value)) {
            cacheableAssets = parser.getCacheableAssets(keys2, value);
            break;
          }
        }
        const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
        if (!cacheableAssets) {
          keys2.forEach((key2) => {
            cacheableMap.set(key2, value);
          });
        }
        const cacheKeys = [...cacheableMap.keys()];
        const cachedAssets = {
          cacheKeys,
          keys: keys2
        };
        keys2.forEach((key2) => {
          this._cacheMap.set(key2, cachedAssets);
        });
        cacheKeys.forEach((key2) => {
          const val = cacheableAssets ? cacheableAssets[key2] : value;
          if (this._cache.has(key2) && this._cache.get(key2) !== val) {
            warn("[Cache] already has key:", key2);
          }
          this._cache.set(key2, cacheableMap.get(key2));
        });
      }
      /**
       * Remove entry by key
       *
       * This function will also remove any associated alias from the cache also.
       * @param key - The key of the entry to remove
       */
      remove(key) {
        if (!this._cacheMap.has(key)) {
          warn(`[Assets] Asset id ${key} was not found in the Cache`);
          return;
        }
        const cacheMap2 = this._cacheMap.get(key);
        const cacheKeys = cacheMap2.cacheKeys;
        cacheKeys.forEach((key2) => {
          this._cache.delete(key2);
        });
        cacheMap2.keys.forEach((key2) => {
          this._cacheMap.delete(key2);
        });
      }
      /** All loader parsers registered */
      get parsers() {
        return this._parsers;
      }
    };
    Cache = new CacheClass();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i2 = 0; i2 < sources.length; i2++) {
    const Source = sources[i2];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id2, skipCache = false) {
  if (typeof id2 === "string") {
    return Cache.get(id2);
  } else if (id2 instanceof TextureSource) {
    return new Texture({ source: id2 });
  }
  return resourceToTexture(id2, skipCache);
}
var sources;
var init_textureFrom = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs"() {
    init_Cache();
    init_Extensions();
    init_TextureSource();
    init_Texture();
    sources = [];
    extensions.handleByList(ExtensionType.TextureSource, sources);
    Texture.from = textureFrom;
    TextureSource.from = textureSourceFrom;
  }
});

// node_modules/pixi.js/lib/rendering/init.mjs
var init_init5 = __esm({
  "node_modules/pixi.js/lib/rendering/init.mjs"() {
    init_Extensions();
    init_AlphaMask();
    init_ColorMask();
    init_StencilMask();
    init_BufferImageSource();
    init_CanvasSource();
    init_ImageSource();
    init_VideoSource();
    init_textureFrom();
    extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs
var BindGroup;
var init_BindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs"() {
    "use strict";
    BindGroup = class {
      /**
       * Create a new instance eof the Bind Group.
       * @param resources - The resources that are bound together for use by a shader.
       */
      constructor(resources) {
        this.resources = /* @__PURE__ */ Object.create(null);
        this._dirty = true;
        let index2 = 0;
        for (const i2 in resources) {
          const resource = resources[i2];
          this.setResource(resource, index2++);
        }
        this._updateKey();
      }
      /**
       * Updates the key if its flagged as dirty. This is used internally to
       * match this bind group to a WebGPU BindGroup.
       * @internal
       * @ignore
       */
      _updateKey() {
        if (!this._dirty)
          return;
        this._dirty = false;
        const keyParts = [];
        let index2 = 0;
        for (const i2 in this.resources) {
          keyParts[index2++] = this.resources[i2]._resourceId;
        }
        this._key = keyParts.join("|");
      }
      /**
       * Set a resource at a given index. this function will
       * ensure that listeners will be removed from the current resource
       * and added to the new resource.
       * @param resource - The resource to set.
       * @param index - The index to set the resource at.
       */
      setResource(resource, index2) {
        const currentResource = this.resources[index2];
        if (resource === currentResource)
          return;
        if (currentResource) {
          resource.off?.("change", this.onResourceChange, this);
        }
        resource.on?.("change", this.onResourceChange, this);
        this.resources[index2] = resource;
        this._dirty = true;
      }
      /**
       * Returns the resource at the current specified index.
       * @param index - The index of the resource to get.
       * @returns - The resource at the specified index.
       */
      getResource(index2) {
        return this.resources[index2];
      }
      /**
       * Used internally to 'touch' each resource, to ensure that the GC
       * knows that all resources in this bind group are still being used.
       * @param tick - The current tick.
       * @internal
       * @ignore
       */
      _touch(tick) {
        const resources = this.resources;
        for (const i2 in resources) {
          resources[i2]._touched = tick;
        }
      }
      /** Destroys this bind group and removes all listeners. */
      destroy() {
        const resources = this.resources;
        for (const i2 in resources) {
          const resource = resources[i2];
          resource.off?.("change", this.onResourceChange, this);
        }
        this.resources = null;
      }
      onResourceChange(resource) {
        this._dirty = true;
        if (resource.destroyed) {
          const resources = this.resources;
          for (const i2 in resources) {
            if (resources[i2] === resource) {
              resources[i2] = null;
            }
          }
        } else {
          this._updateKey();
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs
function getTestContext() {
  if (!context || context?.isContextLost()) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}
var context;
var init_getTestContext = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}
var fragTemplate;
var init_checkMaxIfStatementsInShader = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs"() {
    "use strict";
    fragTemplate = [
      "precision mediump float;",
      "void main(void){",
      "float test = 0.1;",
      "%forloop%",
      "gl_FragColor = vec4(0.0);",
      "}"
    ].join("\n");
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs
function getMaxTexturesPerBatch() {
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
    maxTexturesPerBatchCache,
    gl
  );
  gl.getExtension("WEBGL_lose_context")?.loseContext();
  return maxTexturesPerBatchCache;
}
var maxTexturesPerBatchCache;
var init_maxRecommendedTextures = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs"() {
    init_getTestContext();
    init_checkMaxIfStatementsInShader();
    maxTexturesPerBatchCache = null;
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs
function getTextureBatchBindGroup(textures, size) {
  let uid3 = 2166136261;
  for (let i2 = 0; i2 < size; i2++) {
    uid3 ^= textures[i2].uid;
    uid3 = Math.imul(uid3, 16777619);
    uid3 >>>= 0;
  }
  return cachedGroups[uid3] || generateTextureBatchBindGroup(textures, size, uid3);
}
function generateTextureBatchBindGroup(textures, size, key) {
  const bindGroupResources = {};
  let bindIndex2 = 0;
  if (!maxTextures)
    maxTextures = getMaxTexturesPerBatch();
  for (let i2 = 0; i2 < maxTextures; i2++) {
    const texture = i2 < size ? textures[i2] : Texture.EMPTY.source;
    bindGroupResources[bindIndex2++] = texture.source;
    bindGroupResources[bindIndex2++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key] = bindGroup;
  return bindGroup;
}
var cachedGroups, maxTextures;
var init_getTextureBatchBindGroup = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs"() {
    init_BindGroup();
    init_Texture();
    init_maxRecommendedTextures();
    cachedGroups = {};
    maxTextures = 0;
  }
});

// node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs
var ViewableBuffer;
var init_ViewableBuffer = __esm({
  "node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs"() {
    "use strict";
    ViewableBuffer = class {
      constructor(sizeOrBuffer) {
        if (typeof sizeOrBuffer === "number") {
          this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
        } else if (sizeOrBuffer instanceof Uint8Array) {
          this.rawBinaryData = sizeOrBuffer.buffer;
        } else {
          this.rawBinaryData = sizeOrBuffer;
        }
        this.uint32View = new Uint32Array(this.rawBinaryData);
        this.float32View = new Float32Array(this.rawBinaryData);
        this.size = this.rawBinaryData.byteLength;
      }
      /** View on the raw binary data as a `Int8Array`. */
      get int8View() {
        if (!this._int8View) {
          this._int8View = new Int8Array(this.rawBinaryData);
        }
        return this._int8View;
      }
      /** View on the raw binary data as a `Uint8Array`. */
      get uint8View() {
        if (!this._uint8View) {
          this._uint8View = new Uint8Array(this.rawBinaryData);
        }
        return this._uint8View;
      }
      /**  View on the raw binary data as a `Int16Array`. */
      get int16View() {
        if (!this._int16View) {
          this._int16View = new Int16Array(this.rawBinaryData);
        }
        return this._int16View;
      }
      /** View on the raw binary data as a `Int32Array`. */
      get int32View() {
        if (!this._int32View) {
          this._int32View = new Int32Array(this.rawBinaryData);
        }
        return this._int32View;
      }
      /** View on the raw binary data as a `Float64Array`. */
      get float64View() {
        if (!this._float64Array) {
          this._float64Array = new Float64Array(this.rawBinaryData);
        }
        return this._float64Array;
      }
      /** View on the raw binary data as a `BigUint64Array`. */
      get bigUint64View() {
        if (!this._bigUint64Array) {
          this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
        }
        return this._bigUint64Array;
      }
      /**
       * Returns the view of the given type.
       * @param type - One of `int8`, `uint8`, `int16`,
       *    `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - typed array of given type
       */
      view(type2) {
        return this[`${type2}View`];
      }
      /** Destroys all buffer references. Do not use after calling this. */
      destroy() {
        this.rawBinaryData = null;
        this._int8View = null;
        this._uint8View = null;
        this._int16View = null;
        this.uint16View = null;
        this._int32View = null;
        this.uint32View = null;
        this.float32View = null;
      }
      /**
       * Returns the size of the given type in bytes.
       * @param type - One of `int8`, `uint8`, `int16`,
       *   `uint16`, `int32`, `uint32`, and `float32`.
       * @returns - size of the type in bytes
       */
      static sizeOf(type2) {
        switch (type2) {
          case "int8":
          case "uint8":
            return 1;
          case "int16":
          case "uint16":
            return 2;
          case "int32":
          case "uint32":
          case "float32":
            return 4;
          default:
            throw new Error(`${type2} isn't a valid view type`);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}
var init_fastCopy = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs
var BLEND_TO_NPM, STENCIL_MODES;
var init_const3 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs"() {
    "use strict";
    BLEND_TO_NPM = {
      normal: "normal-npm",
      add: "add-npm",
      screen: "screen-npm"
    };
    STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
      STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
      STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
      STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 3] = "RENDERING_MASK_REMOVE";
      STENCIL_MODES2[STENCIL_MODES2["NONE"] = 4] = "NONE";
      return STENCIL_MODES2;
    })(STENCIL_MODES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}
var init_getAdjustedBlendModeBlend = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs"() {
    init_const3();
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs
var BatchTextureArray;
var init_BatchTextureArray = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs"() {
    "use strict";
    BatchTextureArray = class {
      constructor() {
        this.ids = /* @__PURE__ */ Object.create(null);
        this.textures = [];
        this.count = 0;
      }
      /** Clear the textures and their locations. */
      clear() {
        for (let i2 = 0; i2 < this.count; i2++) {
          const t2 = this.textures[i2];
          this.textures[i2] = null;
          this.ids[t2.uid] = null;
        }
        this.count = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
var Batch, batchPool, batchPoolIndex, BATCH_TICK, _Batcher, Batcher;
var init_Batcher = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs"() {
    init_uid();
    init_ViewableBuffer();
    init_fastCopy();
    init_getAdjustedBlendModeBlend();
    init_maxRecommendedTextures();
    init_BatchTextureArray();
    Batch = class {
      constructor() {
        this.renderPipeId = "batch";
        this.action = "startBatch";
        this.start = 0;
        this.size = 0;
        this.textures = new BatchTextureArray();
        this.blendMode = "normal";
        this.canBundle = true;
      }
      destroy() {
        this.textures = null;
        this.gpuBindGroup = null;
        this.bindGroup = null;
        this.batcher = null;
      }
    };
    batchPool = [];
    batchPoolIndex = 0;
    BATCH_TICK = 0;
    _Batcher = class _Batcher2 {
      constructor(options = {}) {
        this.uid = uid("batcher");
        this.dirty = true;
        this.batchIndex = 0;
        this.batches = [];
        this._vertexSize = 6;
        this._elements = [];
        _Batcher2.defaultOptions.maxTextures = _Batcher2.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();
        options = { ..._Batcher2.defaultOptions, ...options };
        const { vertexSize, indexSize, maxTextures: maxTextures2 } = options;
        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);
        this.indexBuffer = new Uint16Array(indexSize);
        this.maxTextures = maxTextures2;
      }
      begin() {
        this.elementSize = 0;
        this.elementStart = 0;
        this.indexSize = 0;
        this.attributeSize = 0;
        for (let i2 = 0; i2 < this.batchIndex; i2++) {
          returnBatchToPool(this.batches[i2]);
        }
        this.batchIndex = 0;
        this._batchIndexStart = 0;
        this._batchIndexSize = 0;
        this.dirty = true;
      }
      add(batchableObject) {
        this._elements[this.elementSize++] = batchableObject;
        batchableObject.indexStart = this.indexSize;
        batchableObject.location = this.attributeSize;
        batchableObject.batcher = this;
        this.indexSize += batchableObject.indexSize;
        this.attributeSize += batchableObject.vertexSize * this._vertexSize;
      }
      checkAndUpdateTexture(batchableObject, texture) {
        const textureId = batchableObject.batch.textures.ids[texture._source.uid];
        if (!textureId && textureId !== 0)
          return false;
        batchableObject.textureId = textureId;
        batchableObject.texture = texture;
        return true;
      }
      updateElement(batchableObject) {
        this.dirty = true;
        batchableObject.packAttributes(
          this.attributeBuffer.float32View,
          this.attributeBuffer.uint32View,
          batchableObject.location,
          batchableObject.textureId
        );
      }
      /**
       * breaks the batcher. This happens when a batch gets too big,
       * or we need to switch to a different type of rendering (a filter for example)
       * @param instructionSet
       */
      break(instructionSet) {
        const elements = this._elements;
        if (!elements[this.elementStart])
          return;
        let batch = getBatchFromPool();
        let textureBatch = batch.textures;
        textureBatch.clear();
        const firstElement = elements[this.elementStart];
        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
        if (this.attributeSize * 4 > this.attributeBuffer.size) {
          this._resizeAttributeBuffer(this.attributeSize * 4);
        }
        if (this.indexSize > this.indexBuffer.length) {
          this._resizeIndexBuffer(this.indexSize);
        }
        const f32 = this.attributeBuffer.float32View;
        const u32 = this.attributeBuffer.uint32View;
        const iBuffer = this.indexBuffer;
        let size = this._batchIndexSize;
        let start2 = this._batchIndexStart;
        let action = "startBatch";
        const maxTextures2 = this.maxTextures;
        for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
          const element = elements[i2];
          elements[i2] = null;
          const texture = element.texture;
          const source2 = texture._source;
          const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source2);
          const blendModeChange = blendMode !== adjustedBlendMode;
          if (source2._batchTick === BATCH_TICK && !blendModeChange) {
            element.textureId = source2._textureBindLocation;
            size += element.indexSize;
            element.packAttributes(f32, u32, element.location, element.textureId);
            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
            element.batch = batch;
            continue;
          }
          source2._batchTick = BATCH_TICK;
          if (textureBatch.count >= maxTextures2 || blendModeChange) {
            this._finishBatch(
              batch,
              start2,
              size - start2,
              textureBatch,
              blendMode,
              instructionSet,
              action
            );
            action = "renderBatch";
            start2 = size;
            blendMode = adjustedBlendMode;
            batch = getBatchFromPool();
            textureBatch = batch.textures;
            textureBatch.clear();
            ++BATCH_TICK;
          }
          element.textureId = source2._textureBindLocation = textureBatch.count;
          textureBatch.ids[source2.uid] = textureBatch.count;
          textureBatch.textures[textureBatch.count++] = source2;
          element.batch = batch;
          size += element.indexSize;
          element.packAttributes(f32, u32, element.location, element.textureId);
          element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);
        }
        if (textureBatch.count > 0) {
          this._finishBatch(
            batch,
            start2,
            size - start2,
            textureBatch,
            blendMode,
            instructionSet,
            action
          );
          start2 = size;
          ++BATCH_TICK;
        }
        this.elementStart = this.elementSize;
        this._batchIndexStart = start2;
        this._batchIndexSize = size;
      }
      _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {
        batch.gpuBindGroup = null;
        batch.bindGroup = null;
        batch.action = action;
        batch.batcher = this;
        batch.textures = textureBatch;
        batch.blendMode = blendMode;
        batch.start = indexStart;
        batch.size = indexSize;
        ++BATCH_TICK;
        this.batches[this.batchIndex++] = batch;
        instructionSet.add(batch);
      }
      finish(instructionSet) {
        this.break(instructionSet);
      }
      /**
       * Resizes the attribute buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureAttributeBuffer(size) {
        if (size * 4 <= this.attributeBuffer.size)
          return;
        this._resizeAttributeBuffer(size * 4);
      }
      /**
       * Resizes the index buffer to the given size (1 = 1 float32)
       * @param size - the size in vertices to ensure (not bytes!)
       */
      ensureIndexBuffer(size) {
        if (size <= this.indexBuffer.length)
          return;
        this._resizeIndexBuffer(size);
      }
      _resizeAttributeBuffer(size) {
        const newSize = Math.max(size, this.attributeBuffer.size * 2);
        const newArrayBuffer = new ViewableBuffer(newSize);
        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
        this.attributeBuffer = newArrayBuffer;
      }
      _resizeIndexBuffer(size) {
        const indexBuffer = this.indexBuffer;
        let newSize = Math.max(size, indexBuffer.length * 1.5);
        newSize += newSize % 2;
        const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
          for (let i2 = 0; i2 < indexBuffer.length; i2++) {
            newIndexBuffer[i2] = indexBuffer[i2];
          }
        } else {
          fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
        }
        this.indexBuffer = newIndexBuffer;
      }
      destroy() {
        for (let i2 = 0; i2 < this.batches.length; i2++) {
          returnBatchToPool(this.batches[i2]);
        }
        this.batches = null;
        for (let i2 = 0; i2 < this._elements.length; i2++) {
          this._elements[i2].batch = null;
        }
        this._elements = null;
        this.indexBuffer = null;
        this.attributeBuffer.destroy();
        this.attributeBuffer = null;
      }
    };
    _Batcher.defaultOptions = {
      vertexSize: 4,
      indexSize: 6,
      maxTextures: null
    };
    Batcher = _Batcher;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs
var BufferUsage;
var init_const4 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs"() {
    "use strict";
    BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
      BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
      BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
      BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
      BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
      BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
      BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
      BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
      BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
      BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
      BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
      BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
      return BufferUsage2;
    })(BufferUsage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs
var Buffer2;
var init_Buffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs"() {
    init_eventemitter3();
    init_uid();
    init_const4();
    Buffer2 = class extends eventemitter3_default {
      /**
       * Creates a new Buffer with the given options
       * @param options - the options for the buffer
       */
      constructor(options) {
        let { data, size } = options;
        const { usage, label, shrinkToFit } = options;
        super();
        this.uid = uid("buffer");
        this._resourceType = "buffer";
        this._resourceId = uid("resource");
        this._touched = 0;
        this._updateID = 1;
        this.shrinkToFit = true;
        this.destroyed = false;
        if (data instanceof Array) {
          data = new Float32Array(data);
        }
        this._data = data;
        size = size ?? data?.byteLength;
        const mappedAtCreation = !!data;
        this.descriptor = {
          size,
          usage,
          mappedAtCreation,
          label
        };
        this.shrinkToFit = shrinkToFit ?? true;
      }
      /** the data in the buffer */
      get data() {
        return this._data;
      }
      set data(value) {
        this.setDataWithSize(value, value.length, true);
      }
      /** whether the buffer is static or not */
      get static() {
        return !!(this.descriptor.usage & BufferUsage.STATIC);
      }
      set static(value) {
        if (value) {
          this.descriptor.usage |= BufferUsage.STATIC;
        } else {
          this.descriptor.usage &= ~BufferUsage.STATIC;
        }
      }
      /**
       * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
       * If you only want to update a subset of the buffer, you can pass in the size of the data.
       * @param value - the data to set
       * @param size - the size of the data in bytes
       * @param syncGPU - should the buffer be updated on the GPU immediately?
       */
      setDataWithSize(value, size, syncGPU) {
        this._updateID++;
        this._updateSize = size * value.BYTES_PER_ELEMENT;
        if (this._data === value) {
          if (syncGPU)
            this.emit("update", this);
          return;
        }
        const oldData = this._data;
        this._data = value;
        if (oldData.length !== value.length) {
          if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {
            if (syncGPU)
              this.emit("update", this);
          } else {
            this.descriptor.size = value.byteLength;
            this._resourceId = uid("resource");
            this.emit("change", this);
          }
          return;
        }
        if (syncGPU)
          this.emit("update", this);
      }
      /**
       * updates the buffer on the GPU to reflect the data in the buffer.
       * By default it will update the entire buffer. If you only want to update a subset of the buffer,
       * you can pass in the size of the buffer to update.
       * @param sizeInBytes - the new size of the buffer in bytes
       */
      update(sizeInBytes) {
        this._updateSize = sizeInBytes ?? this._updateSize;
        this._updateID++;
        this.emit("update", this);
      }
      /** Destroys the buffer */
      destroy() {
        this.destroyed = true;
        this.emit("destroy", this);
        this.emit("change", this);
        this._data = null;
        this.descriptor = null;
        this.removeAllListeners();
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs
function ensureIsBuffer(buffer, index2) {
  if (!(buffer instanceof Buffer2)) {
    let usage = index2 ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer instanceof Array) {
      if (index2) {
        buffer = new Uint32Array(buffer);
        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer = new Float32Array(buffer);
        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer = new Buffer2({
      data: buffer,
      label: index2 ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage
    });
  }
  return buffer;
}
var init_ensureIsBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs"() {
    init_Buffer();
    init_const4();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs
function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i2 = offset; i2 < data.length; i2 += stride) {
    const x5 = data[i2];
    const y4 = data[i2 + 1];
    if (x5 > maxX)
      maxX = x5;
    if (y4 > maxY)
      maxY = y4;
    if (x5 < minX)
      minX = x5;
    if (y4 < minY)
      minY = y4;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}
var init_getGeometryBounds = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs
function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
var Geometry;
var init_Geometry = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs"() {
    init_eventemitter3();
    init_Bounds();
    init_uid();
    init_Buffer();
    init_ensureIsBuffer();
    init_getGeometryBounds();
    Geometry = class extends eventemitter3_default {
      /**
       * Create a new instance of a geometry
       * @param options - The options for the geometry.
       */
      constructor(options) {
        const { attributes, indexBuffer, topology } = options;
        super();
        this.uid = uid("geometry");
        this._layoutKey = 0;
        this.instanceCount = 1;
        this._bounds = new Bounds();
        this._boundsDirty = true;
        this.attributes = attributes;
        this.buffers = [];
        this.instanceCount = options.instanceCount || 1;
        for (const i2 in attributes) {
          const attribute = attributes[i2] = ensureIsAttribute(attributes[i2]);
          const bufferIndex = this.buffers.indexOf(attribute.buffer);
          if (bufferIndex === -1) {
            this.buffers.push(attribute.buffer);
            attribute.buffer.on("update", this.onBufferUpdate, this);
            attribute.buffer.on("change", this.onBufferUpdate, this);
          }
        }
        if (indexBuffer) {
          this.indexBuffer = ensureIsBuffer(indexBuffer, true);
          this.buffers.push(this.indexBuffer);
        }
        this.topology = topology || "triangle-list";
      }
      onBufferUpdate() {
        this._boundsDirty = true;
        this.emit("update", this);
      }
      /**
       * Returns the requested attribute.
       * @param id - The name of the attribute required
       * @returns - The attribute requested.
       */
      getAttribute(id2) {
        return this.attributes[id2];
      }
      /**
       * Returns the index buffer
       * @returns - The index buffer.
       */
      getIndex() {
        return this.indexBuffer;
      }
      /**
       * Returns the requested buffer.
       * @param id - The name of the buffer required.
       * @returns - The buffer requested.
       */
      getBuffer(id2) {
        return this.getAttribute(id2).buffer;
      }
      /**
       * Used to figure out how many vertices there are in this geometry
       * @returns the number of vertices in the geometry
       */
      getSize() {
        for (const i2 in this.attributes) {
          const attribute = this.attributes[i2];
          const buffer = attribute.buffer;
          return buffer.data.length / (attribute.stride / 4 || attribute.size);
        }
        return 0;
      }
      /** Returns the bounds of the geometry. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        this._boundsDirty = false;
        return getGeometryBounds(this, "aPosition", this._bounds);
      }
      /**
       * destroys the geometry.
       * @param destroyBuffers - destroy the buffers associated with this geometry
       */
      destroy(destroyBuffers = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        if (destroyBuffers) {
          this.buffers.forEach((buffer) => buffer.destroy());
        }
        this.attributes = null;
        this.buffers = null;
        this.indexBuffer = null;
        this._bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs
var placeHolderBufferData, placeHolderIndexData, BatchGeometry;
var init_BatchGeometry = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs"() {
    init_Buffer();
    init_const4();
    init_Geometry();
    placeHolderBufferData = new Float32Array(1);
    placeHolderIndexData = new Uint32Array(1);
    BatchGeometry = class extends Geometry {
      constructor() {
        const vertexSize = 6;
        const attributeBuffer = new Buffer2({
          data: placeHolderBufferData,
          label: "attribute-batch-buffer",
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
          shrinkToFit: false
        });
        const indexBuffer = new Buffer2({
          data: placeHolderIndexData,
          label: "index-batch-buffer",
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
          // | BufferUsage.STATIC,
          shrinkToFit: false
        });
        const stride = vertexSize * 4;
        super({
          attributes: {
            aPosition: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 0
            },
            aUV: {
              buffer: attributeBuffer,
              format: "float32x2",
              stride,
              offset: 2 * 4
            },
            aColor: {
              buffer: attributeBuffer,
              format: "unorm8x4",
              stride,
              offset: 4 * 4
            },
            aTextureIdAndRound: {
              buffer: attributeBuffer,
              format: "uint16x2",
              stride,
              offset: 5 * 4
            }
          },
          indexBuffer
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size, matrix = null) {
  let index2 = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a3 = matrix.a;
  const b2 = matrix.b;
  const c3 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index2 < size) {
    const x5 = vertices[verticesOffset];
    const y4 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a3 * x5 + c3 * y4 + tx;
    uvs[uvsOffset + 1] = b2 * x5 + d3 * y4 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index2++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size) {
  let index2 = 0;
  uvsOffset *= uvsStride;
  while (index2 < size) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index2++;
  }
}
var init_buildUvs = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs
function transformVertices(vertices, m4, offset, stride, size) {
  const a3 = m4.a;
  const b2 = m4.b;
  const c3 = m4.c;
  const d3 = m4.d;
  const tx = m4.tx;
  const ty = m4.ty;
  offset = offset || 0;
  stride = stride || 2;
  size = size || vertices.length / stride - offset;
  let index2 = offset * stride;
  for (let i2 = 0; i2 < size; i2++) {
    const x5 = vertices[index2];
    const y4 = vertices[index2 + 1];
    vertices[index2] = a3 * x5 + c3 * y4 + tx;
    vertices[index2 + 1] = b2 * x5 + d3 * y4 + ty;
    index2 += stride;
  }
}
var init_transformVertices = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs
function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 * r2 / 255;
  const g3 = g1 * g2 / 255;
  const b3 = b1 * b2 / 255;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_multiplyHexColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/multiplyHexColors.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs
var BatchableGraphics;
var init_BatchableGraphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/BatchableGraphics.mjs"() {
    init_multiplyHexColors();
    BatchableGraphics = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.applyTransform = true;
        this.roundPixels = 0;
      }
      get blendMode() {
        if (this.applyTransform) {
          return this.renderable.groupBlendMode;
        }
        return "normal";
      }
      packIndex(indexBuffer, index2, indicesOffset) {
        const indices = this.geometryData.indices;
        for (let i2 = 0; i2 < this.indexSize; i2++) {
          indexBuffer[index2++] = indices[i2 + this.indexOffset] + indicesOffset - this.vertexOffset;
        }
      }
      packAttributes(float32View, uint32View, index2, textureId) {
        const geometry = this.geometryData;
        const graphics = this.renderable;
        const positions = geometry.vertices;
        const uvs = geometry.uvs;
        const offset = this.vertexOffset * 2;
        const vertSize = (this.vertexOffset + this.vertexSize) * 2;
        const rgb2 = this.color;
        const bgr = rgb2 >> 16 | rgb2 & 65280 | (rgb2 & 255) << 16;
        if (this.applyTransform) {
          const argb = multiplyHexColors(bgr, graphics.groupColor) + (this.alpha * graphics.groupAlpha * 255 << 24);
          const wt = graphics.groupTransform;
          const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
          const a3 = wt.a;
          const b2 = wt.b;
          const c3 = wt.c;
          const d3 = wt.d;
          const tx = wt.tx;
          const ty = wt.ty;
          for (let i2 = offset; i2 < vertSize; i2 += 2) {
            const x5 = positions[i2];
            const y4 = positions[i2 + 1];
            float32View[index2] = a3 * x5 + c3 * y4 + tx;
            float32View[index2 + 1] = b2 * x5 + d3 * y4 + ty;
            float32View[index2 + 2] = uvs[i2];
            float32View[index2 + 3] = uvs[i2 + 1];
            uint32View[index2 + 4] = argb;
            uint32View[index2 + 5] = textureIdAndRound;
            index2 += 6;
          }
        } else {
          const argb = bgr + (this.alpha * 255 << 24);
          for (let i2 = offset; i2 < vertSize; i2 += 2) {
            float32View[index2] = positions[i2];
            float32View[index2 + 1] = positions[i2 + 1];
            float32View[index2 + 2] = uvs[i2];
            float32View[index2 + 3] = uvs[i2 + 1];
            uint32View[index2 + 4] = argb;
            uint32View[index2 + 5] = textureId << 16;
            index2 += 6;
          }
        }
      }
      // TODO rename to vertexSize
      get vertSize() {
        return this.vertexSize;
      }
      copyTo(gpuBuffer) {
        gpuBuffer.indexOffset = this.indexOffset;
        gpuBuffer.indexSize = this.indexSize;
        gpuBuffer.vertexOffset = this.vertexOffset;
        gpuBuffer.vertexSize = this.vertexSize;
        gpuBuffer.color = this.color;
        gpuBuffer.alpha = this.alpha;
        gpuBuffer.texture = this.texture;
        gpuBuffer.geometryData = this.geometryData;
      }
      reset() {
        this.applyTransform = true;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs
var buildCircle, buildEllipse, buildRoundedRectangle;
var init_buildCircle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildCircle.mjs"() {
    init_Extensions();
    buildCircle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "circle"
      },
      build(shape, points) {
        let x5;
        let y4;
        let dx;
        let dy;
        let rx;
        let ry;
        if (shape.type === "circle") {
          const circle = shape;
          x5 = circle.x;
          y4 = circle.y;
          rx = ry = circle.radius;
          dx = dy = 0;
        } else if (shape.type === "ellipse") {
          const ellipse = shape;
          x5 = ellipse.x;
          y4 = ellipse.y;
          rx = ellipse.halfWidth;
          ry = ellipse.halfHeight;
          dx = dy = 0;
        } else {
          const roundedRect = shape;
          const halfWidth = roundedRect.width / 2;
          const halfHeight = roundedRect.height / 2;
          x5 = roundedRect.x + halfWidth;
          y4 = roundedRect.y + halfHeight;
          rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
          dx = halfWidth - rx;
          dy = halfHeight - ry;
        }
        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {
          return points;
        }
        const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
        const m4 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
        if (m4 === 0) {
          return points;
        }
        if (n2 === 0) {
          points[0] = points[6] = x5 + dx;
          points[1] = points[3] = y4 + dy;
          points[2] = points[4] = x5 - dx;
          points[5] = points[7] = y4 - dy;
          return points;
        }
        let j1 = 0;
        let j22 = n2 * 4 + (dx ? 2 : 0) + 2;
        let j3 = j22;
        let j4 = m4;
        let x0 = dx + rx;
        let y0 = dy;
        let x1 = x5 + x0;
        let x22 = x5 - x0;
        let y1 = y4 + y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j22] = y1;
        points[--j22] = x22;
        if (dy) {
          const y222 = y4 - y0;
          points[j3++] = x22;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x1;
        }
        for (let i2 = 1; i2 < n2; i2++) {
          const a3 = Math.PI / 2 * (i2 / n2);
          const x02 = dx + Math.cos(a3) * rx;
          const y02 = dy + Math.sin(a3) * ry;
          const x12 = x5 + x02;
          const x222 = x5 - x02;
          const y12 = y4 + y02;
          const y222 = y4 - y02;
          points[j1++] = x12;
          points[j1++] = y12;
          points[--j22] = y12;
          points[--j22] = x222;
          points[j3++] = x222;
          points[j3++] = y222;
          points[--j4] = y222;
          points[--j4] = x12;
        }
        x0 = dx;
        y0 = dy + ry;
        x1 = x5 + x0;
        x22 = x5 - x0;
        y1 = y4 + y0;
        const y22 = y4 - y0;
        points[j1++] = x1;
        points[j1++] = y1;
        points[--j4] = y22;
        points[--j4] = x1;
        if (dx) {
          points[j1++] = x22;
          points[j1++] = y1;
          points[--j4] = y22;
          points[--j4] = x22;
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        if (points.length === 0) {
          return;
        }
        let centerX = 0;
        let centerY = 0;
        for (let i2 = 0; i2 < points.length; i2 += 2) {
          centerX += points[i2];
          centerY += points[i2 + 1];
        }
        centerX /= points.length / 2;
        centerY /= points.length / 2;
        let count2 = verticesOffset;
        vertices[count2 * verticesStride] = centerX;
        vertices[count2 * verticesStride + 1] = centerY;
        const centerIndex = count2++;
        for (let i2 = 0; i2 < points.length; i2 += 2) {
          vertices[count2 * verticesStride] = points[i2];
          vertices[count2 * verticesStride + 1] = points[i2 + 1];
          if (i2 > 0) {
            indices[indicesOffset++] = count2;
            indices[indicesOffset++] = centerIndex;
            indices[indicesOffset++] = count2 - 1;
          }
          count2++;
        }
        indices[indicesOffset++] = centerIndex + 1;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count2 - 1;
      }
    };
    buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
    buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/const.mjs
var closePointEps, curveEps;
var init_const5 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/const.mjs"() {
    "use strict";
    closePointEps = 1e-4;
    curveEps = 1e-4;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs
function getOrientationOfPoints(points) {
  const m4 = points.length;
  if (m4 < 6) {
    return 1;
  }
  let area = 0;
  for (let i2 = 0, x1 = points[m4 - 2], y1 = points[m4 - 1]; i2 < m4; i2 += 2) {
    const x22 = points[i2];
    const y22 = points[i2 + 1];
    area += (x22 - x1) * (y22 + y1);
    x1 = x22;
    y1 = y22;
  }
  if (area < 0) {
    return -1;
  }
  return 1;
}
var init_getOrientationOfPoints = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/getOrientationOfPoints.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs
function square(x5, y4, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x5 - nx * innerWeight;
  const iy = y4 - ny * innerWeight;
  const ox = x5 + nx * outerWeight;
  const oy = y4 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, _verticesStride, _verticesOffset, indices, _indicesOffset) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    if (flipAlignment)
      orientation *= -1;
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x22 = 0;
  let y22 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i2 = 1; i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x22 = points[(i2 + 1) * 2];
    y22 = points[(i2 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y22);
    perp1y = x1 - x22;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x22;
    const dy1 = y22 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c22 = (-perp1x + x22) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y22);
    const px = (dx0 * c22 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c22) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x22 = verts[(i2 + 2) * 2];
    y22 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y22) + x1 * (y22 - y0) + x22 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i2, i2 + 1, i2 + 2);
  }
}
var init_buildLine = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildLine.mjs"() {
    init_Point();
    init_const5();
    init_getOrientationOfPoints();
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports2, module2) {
    "use strict";
    module2.exports = earcut2;
    module2.exports.default = earcut2;
    function earcut2(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x5, y4, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i2 = dim; i2 < outerLen; i2 += dim) {
          x5 = data[i2];
          y4 = data[i2 + 1];
          if (x5 < minX) minX = x5;
          if (y4 < minY) minY = y4;
          if (x5 > maxX) maxX = x5;
          if (y4 > maxY) maxY = y4;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start2, end, dim, clockwise) {
      var i2, last2;
      if (clockwise === signedArea(data, start2, end, dim) > 0) {
        for (i2 = start2; i2 < end; i2 += dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
      } else {
        for (i2 = end - dim; i2 >= start2; i2 -= dim) last2 = insertNode(i2, data[i2], data[i2 + 1], last2);
      }
      if (last2 && equals(last2, last2.next)) {
        removeNode(last2);
        last2 = last2.next;
      }
      return last2;
    }
    function filterPoints(start2, end) {
      if (!start2) return start2;
      if (!end) end = start2;
      var p2 = start2, again;
      do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
          removeNode(p2);
          p2 = end = p2.prev;
          if (p2 === p2.next) break;
          again = true;
        } else {
          p2 = p2.next;
        }
      } while (again || p2 !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear) return;
      if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a3 = ear.prev, b2 = ear, c3 = ear.next;
      if (area(a3, b2, c3) >= 0) return false;
      var ax = a3.x, bx = b2.x, cx = c3.x, ay = a3.y, by = b2.y, cy = c3.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p2 = c3.next;
      while (p2 !== a3) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a3 = ear.prev, b2 = ear, c3 = ear.next;
      if (area(a3, b2, c3) >= 0) return false;
      var ax = a3.x, bx = b2.x, cx = c3.x, ay = a3.y, by = b2.y, cy = c3.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p2 = ear.prevZ, n2 = ear.nextZ;
      while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      while (p2 && p2.z >= minZ) {
        if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a3 && p2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
      }
      while (n2 && n2.z <= maxZ) {
        if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a3 && n2 !== c3 && pointInTriangle(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
        n2 = n2.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start2, triangles, dim) {
      var p2 = start2;
      do {
        var a3 = p2.prev, b2 = p2.next.next;
        if (!equals(a3, b2) && intersects(a3, p2, p2.next, b2) && locallyInside(a3, b2) && locallyInside(b2, a3)) {
          triangles.push(a3.i / dim | 0);
          triangles.push(p2.i / dim | 0);
          triangles.push(b2.i / dim | 0);
          removeNode(p2);
          removeNode(p2.next);
          p2 = start2 = b2;
        }
        p2 = p2.next;
      } while (p2 !== start2);
      return filterPoints(p2);
    }
    function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
      var a3 = start2;
      do {
        var b2 = a3.next.next;
        while (b2 !== a3.prev) {
          if (a3.i !== b2.i && isValidDiagonal(a3, b2)) {
            var c3 = splitPolygon(a3, b2);
            a3 = filterPoints(a3, a3.next);
            c3 = filterPoints(c3, c3.next);
            earcutLinked(a3, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c3, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b2 = b2.next;
        }
        a3 = a3.next;
      } while (a3 !== start2);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i2, len, start2, end, list;
      for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
        start2 = holeIndices[i2] * dim;
        end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
        list = linkedList(data, start2, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i2 = 0; i2 < queue.length; i2++) {
        outerNode = eliminateHole(queue[i2], outerNode);
      }
      return outerNode;
    }
    function compareX(a3, b2) {
      return a3.x - b2.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m4;
      do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
          var x5 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
          if (x5 <= hx && x5 > qx) {
            qx = x5;
            m4 = p2.x < p2.next.x ? p2 : p2.next;
            if (x5 === hx) return m4;
          }
        }
        p2 = p2.next;
      } while (p2 !== outerNode);
      if (!m4) return null;
      var stop = m4, mx = m4.x, my = m4.y, tanMin = Infinity, tan;
      p2 = m4;
      do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
          tan = Math.abs(hy - p2.y) / (hx - p2.x);
          if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m4.x || p2.x === m4.x && sectorContainsSector(m4, p2)))) {
            m4 = p2;
            tanMin = tan;
          }
        }
        p2 = p2.next;
      } while (p2 !== stop);
      return m4;
    }
    function sectorContainsSector(m4, p2) {
      return area(m4.prev, m4, p2.prev) < 0 && area(p2.next, m4, m4.next) < 0;
    }
    function indexCurve(start2, minX, minY, invSize) {
      var p2 = start2;
      do {
        if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
      } while (p2 !== start2);
      p2.prevZ.nextZ = null;
      p2.prevZ = null;
      sortLinked(p2);
    }
    function sortLinked(list) {
      var i2, p2, q2, e3, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p2) {
          numMerges++;
          q2 = p2;
          pSize = 0;
          for (i2 = 0; i2 < inSize; i2++) {
            pSize++;
            q2 = q2.nextZ;
            if (!q2) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q2) {
            if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
              e3 = p2;
              p2 = p2.nextZ;
              pSize--;
            } else {
              e3 = q2;
              q2 = q2.nextZ;
              qSize--;
            }
            if (tail) tail.nextZ = e3;
            else list = e3;
            e3.prevZ = tail;
            tail = e3;
          }
          p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x5, y4, minX, minY, invSize) {
      x5 = (x5 - minX) * invSize | 0;
      y4 = (y4 - minY) * invSize | 0;
      x5 = (x5 | x5 << 8) & 16711935;
      x5 = (x5 | x5 << 4) & 252645135;
      x5 = (x5 | x5 << 2) & 858993459;
      x5 = (x5 | x5 << 1) & 1431655765;
      y4 = (y4 | y4 << 8) & 16711935;
      y4 = (y4 | y4 << 4) & 252645135;
      y4 = (y4 | y4 << 2) & 858993459;
      y4 = (y4 | y4 << 1) & 1431655765;
      return x5 | y4 << 1;
    }
    function getLeftmost(start2) {
      var p2 = start2, leftmost = start2;
      do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
        p2 = p2.next;
      } while (p2 !== start2);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a3, b2) {
      return a3.next.i !== b2.i && a3.prev.i !== b2.i && !intersectsPolygon(a3, b2) && // dones't intersect other edges
      (locallyInside(a3, b2) && locallyInside(b2, a3) && middleInside(a3, b2) && // locally visible
      (area(a3.prev, a3, b2.prev) || area(a3, b2.prev, b2)) || // does not create opposite-facing sectors
      equals(a3, b2) && area(a3.prev, a3, a3.next) > 0 && area(b2.prev, b2, b2.next) > 0);
    }
    function area(p2, q2, r2) {
      return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4) return true;
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;
      return false;
    }
    function onSegment(p2, q2, r2) {
      return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a3, b2) {
      var p2 = a3;
      do {
        if (p2.i !== a3.i && p2.next.i !== a3.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a3, b2)) return true;
        p2 = p2.next;
      } while (p2 !== a3);
      return false;
    }
    function locallyInside(a3, b2) {
      return area(a3.prev, a3, a3.next) < 0 ? area(a3, b2, a3.next) >= 0 && area(a3, a3.prev, b2) >= 0 : area(a3, b2, a3.prev) < 0 || area(a3, a3.next, b2) < 0;
    }
    function middleInside(a3, b2) {
      var p2 = a3, inside = false, px = (a3.x + b2.x) / 2, py = (a3.y + b2.y) / 2;
      do {
        if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
          inside = !inside;
        p2 = p2.next;
      } while (p2 !== a3);
      return inside;
    }
    function splitPolygon(a3, b2) {
      var a22 = new Node(a3.i, a3.x, a3.y), b22 = new Node(b2.i, b2.x, b2.y), an = a3.next, bp = b2.prev;
      a3.next = b2;
      b2.prev = a3;
      a22.next = an;
      an.prev = a22;
      b22.next = a22;
      a22.prev = b22;
      bp.next = b22;
      b22.prev = bp;
      return b22;
    }
    function insertNode(i2, x5, y4, last2) {
      var p2 = new Node(i2, x5, y4);
      if (!last2) {
        p2.prev = p2;
        p2.next = p2;
      } else {
        p2.next = last2.next;
        p2.prev = last2;
        last2.next.prev = p2;
        last2.next = p2;
      }
      return p2;
    }
    function removeNode(p2) {
      p2.next.prev = p2.prev;
      p2.prev.next = p2.next;
      if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
      if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
    }
    function Node(i2, x5, y4) {
      this.i = i2;
      this.x = x5;
      this.y = y4;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut2.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i2 = 0, len = holeIndices.length; i2 < len; i2++) {
          var start2 = holeIndices[i2] * dim;
          var end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start2, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i2 = 0; i2 < triangles.length; i2 += 3) {
        var a3 = triangles[i2] * dim;
        var b2 = triangles[i2 + 1] * dim;
        var c3 = triangles[i2 + 2] * dim;
        trianglesArea += Math.abs(
          (data[a3] - data[c3]) * (data[b2 + 1] - data[a3 + 1]) - (data[a3] - data[b2]) * (data[c3 + 1] - data[a3 + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start2, end, dim) {
      var sum = 0;
      for (var i2 = start2, j3 = end - dim; i2 < end; i2 += dim) {
        sum += (data[j3] - data[i2]) * (data[i2 + 1] + data[j3 + 1]);
        j3 = i2;
      }
      return sum;
    }
    earcut2.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i2 = 0; i2 < data.length; i2++) {
        for (var j3 = 0; j3 < data[i2].length; j3++) {
          for (var d3 = 0; d3 < dim; d3++) result.vertices.push(data[i2][j3][d3]);
        }
        if (i2 > 0) {
          holeIndex += data[i2 - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = (0, import_earcut.default)(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    indices[indicesOffset++] = triangles[i2] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
  }
  let index2 = verticesOffset * verticesStride;
  for (let i2 = 0; i2 < points.length; i2 += 2) {
    vertices[index2] = points[i2];
    vertices[index2 + 1] = points[i2 + 1];
    index2 += verticesStride;
  }
}
var import_earcut;
var init_triangulateWithHoles = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/triangulateWithHoles.mjs"() {
    import_earcut = __toESM(require_earcut(), 1);
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs
var emptyArray, buildPolygon;
var init_buildPolygon = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildPolygon.mjs"() {
    init_Extensions();
    init_triangulateWithHoles();
    emptyArray = [];
    buildPolygon = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "polygon"
      },
      build(shape, points) {
        for (let i2 = 0; i2 < shape.points.length; i2++) {
          points[i2] = shape.points[i2];
        }
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs
var buildRectangle;
var init_buildRectangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildRectangle.mjs"() {
    init_Extensions();
    buildRectangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "rectangle"
      },
      build(shape, points) {
        const rectData = shape;
        const x5 = rectData.x;
        const y4 = rectData.y;
        const width = rectData.width;
        const height = rectData.height;
        if (!(width >= 0 && height >= 0)) {
          return points;
        }
        points[0] = x5;
        points[1] = y4;
        points[2] = x5 + width;
        points[3] = y4;
        points[4] = x5 + width;
        points[5] = y4 + height;
        points[6] = x5;
        points[7] = y4 + height;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[6];
        vertices[verticesOffset + count2 + 1] = points[7];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        count2 += verticesStride;
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 3;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs
var buildTriangle;
var init_buildTriangle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildTriangle.mjs"() {
    init_Extensions();
    buildTriangle = {
      extension: {
        type: ExtensionType.ShapeBuilder,
        name: "triangle"
      },
      build(shape, points) {
        points[0] = shape.x;
        points[1] = shape.y;
        points[2] = shape.x2;
        points[3] = shape.y2;
        points[4] = shape.x3;
        points[5] = shape.y3;
        return points;
      },
      triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
        let count2 = 0;
        verticesOffset *= verticesStride;
        vertices[verticesOffset + count2] = points[0];
        vertices[verticesOffset + count2 + 1] = points[1];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[2];
        vertices[verticesOffset + count2 + 1] = points[3];
        count2 += verticesStride;
        vertices[verticesOffset + count2] = points[4];
        vertices[verticesOffset + count2 + 1] = points[5];
        const verticesIndex = verticesOffset / verticesStride;
        indices[indicesOffset++] = verticesIndex;
        indices[indicesOffset++] = verticesIndex + 1;
        indices[indicesOffset++] = verticesIndex + 2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs
function buildContextBatches(context2, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i2 = 0; i2 < context2.instructions.length; i2++) {
    const instruction = context2.instructions[i2];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);
      }
      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect;
  const texture = data.image;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  build.build(rect, points);
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.vertexOffset = vertOffset;
  graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
  graphicsBatch.color = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  const lastIndex = shapePath.shapePrimitives.length - 1;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i2) => {
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    const points = [];
    const build = shapeBuilders[shape.type];
    build.build(shape, points);
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (hole && lastIndex === i2) {
        if (lastIndex !== 0) {
          console.warn("[Pixi Graphics] only the last shape have be cut out");
        }
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(hole.shapePath);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = style.matrix;
      if (textureMatrix) {
        if (matrix) {
          textureMatrix.append(matrix.clone().invert());
        }
        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
      }
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.vertexOffset = vertOffset;
    graphicsBatch.vertexSize = vertices.length / 2 - vertOffset;
    graphicsBatch.color = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(shape) {
  if (!shape)
    return [];
  const holePrimitives = shape.shapePrimitives;
  const holeArrays = [];
  for (let k3 = 0; k3 < holePrimitives.length; k3++) {
    const holePrimitive = holePrimitives[k3].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    holeBuilder.build(holePrimitive, holePoints);
    holeArrays.push(holePoints);
  }
  return holeArrays;
}
var shapeBuilders, tempRect;
var init_buildContextBatches = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/buildContextBatches.mjs"() {
    init_Extensions();
    init_Rectangle();
    init_buildUvs();
    init_transformVertices();
    init_Texture();
    init_PoolGroup();
    init_BatchableGraphics();
    init_buildCircle();
    init_buildLine();
    init_buildPolygon();
    init_buildRectangle();
    init_buildTriangle();
    init_triangulateWithHoles();
    shapeBuilders = {};
    extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
    extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
    tempRect = new Rectangle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs
var GpuGraphicsContext, GraphicsContextRenderData, _GraphicsContextSystem, GraphicsContextSystem;
var init_GraphicsContextSystem = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContextSystem.mjs"() {
    init_Extensions();
    init_getTextureBatchBindGroup();
    init_Batcher();
    init_BatchGeometry();
    init_InstructionSet();
    init_PoolGroup();
    init_buildContextBatches();
    GpuGraphicsContext = class {
      constructor() {
        this.batcher = new Batcher();
        this.batches = [];
        this.geometryData = {
          vertices: [],
          uvs: [],
          indices: []
        };
      }
    };
    GraphicsContextRenderData = class {
      constructor() {
        this.geometry = new BatchGeometry();
        this.instructions = new InstructionSet();
      }
      init() {
        this.instructions.reset();
      }
    };
    _GraphicsContextSystem = class _GraphicsContextSystem2 {
      constructor() {
        this._gpuContextHash = {};
        this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Runner init called, update the default options
       * @ignore
       */
      init(options) {
        _GraphicsContextSystem2.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
      }
      getContextRenderData(context2) {
        return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
      }
      // Context management functions
      updateGpuContext(context2) {
        let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
        if (context2.dirty) {
          if (gpuContext) {
            this._cleanGraphicsContextData(context2);
          } else {
            gpuContext = this._initContext(context2);
          }
          buildContextBatches(context2, gpuContext);
          const batchMode = context2.batchMode;
          if (context2.customShader || batchMode === "no-batch") {
            gpuContext.isBatchable = false;
          } else if (batchMode === "auto") {
            gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
          }
          context2.dirty = false;
        }
        return gpuContext;
      }
      getGpuContext(context2) {
        return this._gpuContextHash[context2.uid] || this._initContext(context2);
      }
      _initContextRenderData(context2) {
        const graphicsData = BigPool.get(GraphicsContextRenderData);
        const { batches, geometryData, batcher } = this._gpuContextHash[context2.uid];
        const vertexSize = geometryData.vertices.length;
        const indexSize = geometryData.indices.length;
        for (let i2 = 0; i2 < batches.length; i2++) {
          batches[i2].applyTransform = false;
        }
        batcher.ensureAttributeBuffer(vertexSize);
        batcher.ensureIndexBuffer(indexSize);
        batcher.begin();
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batcher.add(batch);
        }
        batcher.finish(graphicsData.instructions);
        const geometry = graphicsData.geometry;
        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
        const drawBatches = batcher.batches;
        for (let i2 = 0; i2 < drawBatches.length; i2++) {
          const batch = drawBatches[i2];
          batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);
        }
        this._graphicsDataContextHash[context2.uid] = graphicsData;
        return graphicsData;
      }
      _initContext(context2) {
        const gpuContext = new GpuGraphicsContext();
        gpuContext.context = context2;
        this._gpuContextHash[context2.uid] = gpuContext;
        context2.on("destroy", this.onGraphicsContextDestroy, this);
        return this._gpuContextHash[context2.uid];
      }
      onGraphicsContextDestroy(context2) {
        this._cleanGraphicsContextData(context2);
        context2.off("destroy", this.onGraphicsContextDestroy, this);
        this._gpuContextHash[context2.uid] = null;
      }
      _cleanGraphicsContextData(context2) {
        const gpuContext = this._gpuContextHash[context2.uid];
        if (!gpuContext.isBatchable) {
          if (this._graphicsDataContextHash[context2.uid]) {
            BigPool.return(this.getContextRenderData(context2));
            this._graphicsDataContextHash[context2.uid] = null;
          }
        }
        if (gpuContext.batches) {
          gpuContext.batches.forEach((batch) => {
            BigPool.return(batch);
          });
        }
      }
      destroy() {
        for (const i2 in this._gpuContextHash) {
          if (this._gpuContextHash[i2]) {
            this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
          }
        }
      }
    };
    _GraphicsContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "graphicsContext"
    };
    _GraphicsContextSystem.defaultOptions = {
      /**
       * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
       * @default 0.5
       */
      bezierSmoothness: 0.5
    };
    GraphicsContextSystem = _GraphicsContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs
var blendModeIds, BLEND, OFFSET, CULLING, DEPTH_TEST, WINDING, DEPTH_MASK, _State, State;
var init_State = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs"() {
    "use strict";
    blendModeIds = {
      normal: 0,
      add: 1,
      multiply: 2,
      screen: 3,
      overlay: 4,
      erase: 5,
      "normal-npm": 6,
      "add-npm": 7,
      "screen-npm": 8,
      min: 9,
      max: 10
    };
    BLEND = 0;
    OFFSET = 1;
    CULLING = 2;
    DEPTH_TEST = 3;
    WINDING = 4;
    DEPTH_MASK = 5;
    _State = class _State2 {
      constructor() {
        this.data = 0;
        this.blendMode = "normal";
        this.polygonOffset = 0;
        this.blend = true;
        this.depthMask = true;
      }
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get blend() {
        return !!(this.data & 1 << BLEND);
      }
      set blend(value) {
        if (!!(this.data & 1 << BLEND) !== value) {
          this.data ^= 1 << BLEND;
        }
      }
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get offsets() {
        return !!(this.data & 1 << OFFSET);
      }
      set offsets(value) {
        if (!!(this.data & 1 << OFFSET) !== value) {
          this.data ^= 1 << OFFSET;
        }
      }
      /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
      set cullMode(value) {
        if (value === "none") {
          this.culling = false;
          return;
        }
        this.culling = true;
        this.clockwiseFrontFace = value === "front";
      }
      get cullMode() {
        if (!this.culling) {
          return "none";
        }
        return this.clockwiseFrontFace ? "front" : "back";
      }
      /**
       * Activates culling of polygons.
       * @default false
       */
      get culling() {
        return !!(this.data & 1 << CULLING);
      }
      set culling(value) {
        if (!!(this.data & 1 << CULLING) !== value) {
          this.data ^= 1 << CULLING;
        }
      }
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get depthTest() {
        return !!(this.data & 1 << DEPTH_TEST);
      }
      set depthTest(value) {
        if (!!(this.data & 1 << DEPTH_TEST) !== value) {
          this.data ^= 1 << DEPTH_TEST;
        }
      }
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get depthMask() {
        return !!(this.data & 1 << DEPTH_MASK);
      }
      set depthMask(value) {
        if (!!(this.data & 1 << DEPTH_MASK) !== value) {
          this.data ^= 1 << DEPTH_MASK;
        }
      }
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get clockwiseFrontFace() {
        return !!(this.data & 1 << WINDING);
      }
      set clockwiseFrontFace(value) {
        if (!!(this.data & 1 << WINDING) !== value) {
          this.data ^= 1 << WINDING;
        }
      }
      /**
       * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default 'normal'
       */
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(value) {
        this.blend = value !== "none";
        this._blendMode = value;
        this._blendModeId = blendModeIds[value] || 0;
      }
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
      }
      toString() {
        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      /**
       * A quickly getting an instance of a State that is configured for 2d rendering.
       * @returns a new State with values set for 2d rendering
       */
      static for2d() {
        const state = new _State2();
        state.depthTest = false;
        state.blend = true;
        return state;
      }
    };
    _State.default2d = _State.for2d();
    State = _State;
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs
function color32BitToUniform(abgr, out2, offset) {
  const alpha = (abgr >> 24 & 255) / 255;
  out2[offset++] = (abgr & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 8 & 255) / 255 * alpha;
  out2[offset++] = (abgr >> 16 & 255) / 255 * alpha;
  out2[offset++] = alpha;
}
var init_colorToUniform = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs
var GraphicsPipe;
var init_GraphicsPipe = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs"() {
    init_Extensions();
    init_State();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableGraphics();
    GraphicsPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._graphicsBatchesHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(graphics) {
        const context2 = graphics.context;
        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context2);
        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable) {
          return true;
        }
        return false;
      }
      addRenderable(graphics, instructionSet) {
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (graphics._didGraphicsUpdate) {
          graphics._didGraphicsUpdate = false;
          this._rebuild(graphics);
        }
        if (gpuContext.isBatchable) {
          this._addToBatcher(graphics);
        } else {
          this.renderer.renderPipes.batch.break(instructionSet);
          instructionSet.add(graphics);
        }
      }
      updateRenderable(graphics) {
        const batches = this._graphicsBatchesHash[graphics.uid];
        if (batches) {
          for (let i2 = 0; i2 < batches.length; i2++) {
            const batch = batches[i2];
            batch.batcher.updateElement(batch);
          }
        }
      }
      destroyRenderable(graphics) {
        if (this._graphicsBatchesHash[graphics.uid]) {
          this._removeBatchForRenderable(graphics.uid);
        }
        graphics.off("destroyed", this._destroyRenderableBound);
      }
      execute(graphics) {
        if (!graphics.isRenderable)
          return;
        const renderer = this.renderer;
        const context2 = graphics.context;
        const contextSystem = renderer.graphicsContext;
        if (!contextSystem.getGpuContext(context2).batches.length) {
          return;
        }
        const shader = context2.customShader || this._adaptor.shader;
        this.state.blendMode = graphics.groupBlendMode;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = graphics.groupTransform;
        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;
        color32BitToUniform(
          graphics.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._adaptor.execute(this, graphics);
      }
      _rebuild(graphics) {
        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
        if (wasBatched) {
          this._removeBatchForRenderable(graphics.uid);
        }
        if (gpuContext.isBatchable) {
          this._initBatchesForRenderable(graphics);
        }
        graphics.batched = gpuContext.isBatchable;
      }
      _addToBatcher(graphics) {
        const batchPipe = this.renderer.renderPipes.batch;
        const batches = this._getBatchesForRenderable(graphics);
        for (let i2 = 0; i2 < batches.length; i2++) {
          const batch = batches[i2];
          batchPipe.addToBatch(batch);
        }
      }
      _getBatchesForRenderable(graphics) {
        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
      }
      _initBatchesForRenderable(graphics) {
        const context2 = graphics.context;
        const gpuContext = this.renderer.graphicsContext.getGpuContext(context2);
        const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
        const batches = gpuContext.batches.map((batch) => {
          const batchClone = BigPool.get(BatchableGraphics);
          batch.copyTo(batchClone);
          batchClone.renderable = graphics;
          batchClone.roundPixels = roundPixels;
          return batchClone;
        });
        if (this._graphicsBatchesHash[graphics.uid] === void 0) {
          graphics.on("destroyed", this._destroyRenderableBound);
        }
        this._graphicsBatchesHash[graphics.uid] = batches;
        return batches;
      }
      _removeBatchForRenderable(graphicsUid) {
        this._graphicsBatchesHash[graphicsUid].forEach((batch) => {
          BigPool.return(batch);
        });
        this._graphicsBatchesHash[graphicsUid] = null;
      }
      destroy() {
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.state = null;
        for (const i2 in this._graphicsBatchesHash) {
          this._removeBatchForRenderable(i2);
        }
        this._graphicsBatchesHash = null;
      }
    };
    GraphicsPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/init.mjs
var init_init6 = __esm({
  "node_modules/pixi.js/lib/scene/graphics/init.mjs"() {
    init_Extensions();
    init_GraphicsContextSystem();
    init_GraphicsPipe();
    extensions.add(GraphicsPipe);
    extensions.add(GraphicsContextSystem);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs
function createIdFromString(value, groupId) {
  let id2 = idHash2[value];
  if (id2 === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash2[value] = id2 = idCounts[groupId]++;
  }
  return id2;
}
var idCounts, idHash2;
var init_createIdFromString = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs"() {
    "use strict";
    idCounts = /* @__PURE__ */ Object.create(null);
    idHash2 = /* @__PURE__ */ Object.create(null);
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs
var UNIFORM_TYPES_VALUES, UNIFORM_TYPES_MAP;
var init_types = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs"() {
    "use strict";
    UNIFORM_TYPES_VALUES = [
      "f32",
      "i32",
      "vec2<f32>",
      "vec3<f32>",
      "vec4<f32>",
      "mat2x2<f32>",
      "mat3x3<f32>",
      "mat4x4<f32>",
      "mat3x2<f32>",
      "mat4x2<f32>",
      "mat2x3<f32>",
      "mat4x3<f32>",
      "mat2x4<f32>",
      "mat3x4<f32>"
    ];
    UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type2) => {
      acc[type2] = true;
      return acc;
    }, {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs
function getDefaultUniformValue(type2, size) {
  switch (type2) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size);
    case "vec3<f32>":
      return new Float32Array(3 * size);
    case "vec4<f32>":
      return new Float32Array(4 * size);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_getDefaultUniformValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs
var _UniformGroup, UniformGroup;
var init_UniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs"() {
    init_uid();
    init_createIdFromString();
    init_types();
    init_getDefaultUniformValue();
    _UniformGroup = class _UniformGroup2 {
      /**
       * Create a new Uniform group
       * @param uniformStructures - The structures of the uniform group
       * @param options - The optional parameters of this uniform group
       */
      constructor(uniformStructures, options) {
        this._touched = 0;
        this.uid = uid("uniform");
        this._resourceType = "uniformGroup";
        this._resourceId = uid("resource");
        this.isUniformGroup = true;
        this._dirtyId = 0;
        this.destroyed = false;
        options = { ..._UniformGroup2.defaultOptions, ...options };
        this.uniformStructures = uniformStructures;
        const uniforms = {};
        for (const i2 in uniformStructures) {
          const uniformData = uniformStructures[i2];
          uniformData.name = i2;
          uniformData.size = uniformData.size ?? 1;
          if (!UNIFORM_TYPES_MAP[uniformData.type]) {
            throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
          }
          uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
          uniforms[i2] = uniformData.value;
        }
        this.uniforms = uniforms;
        this._dirtyId = 1;
        this.ubo = options.ubo;
        this.isStatic = options.isStatic;
        this._signature = createIdFromString(Object.keys(uniforms).map(
          (i2) => `${i2}-${uniformStructures[i2].type}`
        ).join("-"), "uniform-group");
      }
      /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
      update() {
        this._dirtyId++;
      }
    };
    _UniformGroup.defaultOptions = {
      /** if true the UniformGroup is handled as an Uniform buffer object. */
      ubo: false,
      /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
      isStatic: false
    };
    UniformGroup = _UniformGroup;
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs
var BatchableMesh;
var init_BatchableMesh = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs"() {
    "use strict";
    BatchableMesh = class {
      constructor() {
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
        this._uvUpdateId = -1;
        this._textureMatrixUpdateId = -1;
      }
      get blendMode() {
        return this.mesh.groupBlendMode;
      }
      reset() {
        this.mesh = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
        this.geometry = null;
        this._uvUpdateId = -1;
        this._textureMatrixUpdateId = -1;
      }
      packIndex(indexBuffer, index2, indicesOffset) {
        const indices = this.geometry.indices;
        for (let i2 = 0; i2 < indices.length; i2++) {
          indexBuffer[index2++] = indices[i2] + indicesOffset;
        }
      }
      packAttributes(float32View, uint32View, index2, textureId) {
        const mesh = this.mesh;
        const geometry = this.geometry;
        const wt = mesh.groupTransform;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        const a3 = wt.a;
        const b2 = wt.b;
        const c3 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const positions = geometry.positions;
        const uvBuffer = geometry.getBuffer("aUV");
        const uvs = uvBuffer.data;
        let transformedUvs = uvs;
        const textureMatrix = this.texture.textureMatrix;
        if (!textureMatrix.isSimple) {
          transformedUvs = this._transformedUvs;
          if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {
            if (!transformedUvs || transformedUvs.length < uvs.length) {
              transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
            }
            this._textureMatrixUpdateId = textureMatrix._updateID;
            this._uvUpdateId = uvBuffer._updateID;
            textureMatrix.multiplyUvs(uvs, transformedUvs);
          }
        }
        const abgr = mesh.groupColorAlpha;
        for (let i2 = 0; i2 < positions.length; i2 += 2) {
          const x5 = positions[i2];
          const y4 = positions[i2 + 1];
          float32View[index2] = a3 * x5 + c3 * y4 + tx;
          float32View[index2 + 1] = b2 * x5 + d3 * y4 + ty;
          float32View[index2 + 2] = transformedUvs[i2];
          float32View[index2 + 3] = transformedUvs[i2 + 1];
          uint32View[index2 + 4] = abgr;
          uint32View[index2 + 5] = textureIdAndRound;
          index2 += 6;
        }
      }
      get vertexSize() {
        return this.geometry.positions.length / 2;
      }
      get indexSize() {
        return this.geometry.indices.length;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs
var MeshPipe;
var init_MeshPipe = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs"() {
    init_Extensions();
    init_Matrix();
    init_BindGroup();
    init_UniformGroup();
    init_getAdjustedBlendModeBlend();
    init_PoolGroup();
    init_colorToUniform();
    init_BatchableMesh();
    MeshPipe = class {
      constructor(renderer, adaptor) {
        this.localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        this.localUniformsBindGroup = new BindGroup({
          0: this.localUniforms
        });
        this._meshDataHash = /* @__PURE__ */ Object.create(null);
        this._gpuBatchableMeshHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init();
      }
      validateRenderable(mesh) {
        const meshData = this._getMeshData(mesh);
        const wasBatched = meshData.batched;
        const isBatched = mesh.batched;
        meshData.batched = isBatched;
        if (wasBatched !== isBatched) {
          return true;
        } else if (isBatched) {
          const geometry = mesh._geometry;
          if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {
            meshData.indexSize = geometry.indices.length;
            meshData.vertexSize = geometry.positions.length;
            return true;
          }
          const batchableMesh = this._getBatchableMesh(mesh);
          const texture = mesh.texture;
          if (batchableMesh.texture._source !== texture._source) {
            if (batchableMesh.texture._source !== texture._source) {
              return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, texture);
            }
          }
        }
        return false;
      }
      addRenderable(mesh, instructionSet) {
        const batcher = this.renderer.renderPipes.batch;
        const { batched } = this._getMeshData(mesh);
        if (batched) {
          const gpuBatchableMesh = this._getBatchableMesh(mesh);
          gpuBatchableMesh.texture = mesh._texture;
          gpuBatchableMesh.geometry = mesh._geometry;
          batcher.addToBatch(gpuBatchableMesh);
        } else {
          batcher.break(instructionSet);
          instructionSet.add(mesh);
        }
      }
      updateRenderable(mesh) {
        if (mesh.batched) {
          const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
          gpuBatchableMesh.texture = mesh._texture;
          gpuBatchableMesh.geometry = mesh._geometry;
          gpuBatchableMesh.batcher.updateElement(gpuBatchableMesh);
        }
      }
      destroyRenderable(mesh) {
        this._meshDataHash[mesh.uid] = null;
        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
        if (gpuMesh) {
          BigPool.return(gpuMesh);
          this._gpuBatchableMeshHash[mesh.uid] = null;
        }
        mesh.off("destroyed", this._destroyRenderableBound);
      }
      execute(mesh) {
        if (!mesh.isRenderable)
          return;
        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
        const localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
        localUniforms.update();
        color32BitToUniform(
          mesh.groupColorAlpha,
          localUniforms.uniforms.uColor,
          0
        );
        this._adaptor.execute(this, mesh);
      }
      _getMeshData(mesh) {
        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
      }
      _initMeshData(mesh) {
        this._meshDataHash[mesh.uid] = {
          batched: mesh.batched,
          indexSize: mesh._geometry.indices?.length,
          vertexSize: mesh._geometry.positions?.length
        };
        mesh.on("destroyed", this._destroyRenderableBound);
        return this._meshDataHash[mesh.uid];
      }
      _getBatchableMesh(mesh) {
        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
      }
      _initBatchableMesh(mesh) {
        const gpuMesh = BigPool.get(BatchableMesh);
        gpuMesh.mesh = mesh;
        gpuMesh.texture = mesh._texture;
        gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
        gpuMesh.mesh = mesh;
        return gpuMesh;
      }
      destroy() {
        for (const i2 in this._gpuBatchableMeshHash) {
          if (this._gpuBatchableMeshHash[i2]) {
            BigPool.return(this._gpuBatchableMeshHash[i2]);
          }
        }
        this._gpuBatchableMeshHash = null;
        this._meshDataHash = null;
        this.localUniforms = null;
        this.localUniformsBindGroup = null;
        this._adaptor.destroy();
        this._adaptor = null;
        this.renderer = null;
      }
    };
    MeshPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/init.mjs
var init_init7 = __esm({
  "node_modules/pixi.js/lib/scene/mesh/init.mjs"() {
    init_Extensions();
    init_MeshPipe();
    extensions.add(MeshPipe);
  }
});

// node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs
var BatchableSprite;
var init_BatchableSprite = __esm({
  "node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"() {
    "use strict";
    BatchableSprite = class {
      constructor() {
        this.vertexSize = 4;
        this.indexSize = 6;
        this.location = 0;
        this.batcher = null;
        this.batch = null;
        this.roundPixels = 0;
      }
      get blendMode() {
        return this.renderable.groupBlendMode;
      }
      packAttributes(float32View, uint32View, index2, textureId) {
        const sprite = this.renderable;
        const texture = this.texture;
        const wt = sprite.groupTransform;
        const a3 = wt.a;
        const b2 = wt.b;
        const c3 = wt.c;
        const d3 = wt.d;
        const tx = wt.tx;
        const ty = wt.ty;
        const bounds = this.bounds;
        const w0 = bounds.maxX;
        const w1 = bounds.minX;
        const h0 = bounds.maxY;
        const h1 = bounds.minY;
        const uvs = texture.uvs;
        const argb = sprite.groupColorAlpha;
        const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
        float32View[index2 + 0] = a3 * w1 + c3 * h1 + tx;
        float32View[index2 + 1] = d3 * h1 + b2 * w1 + ty;
        float32View[index2 + 2] = uvs.x0;
        float32View[index2 + 3] = uvs.y0;
        uint32View[index2 + 4] = argb;
        uint32View[index2 + 5] = textureIdAndRound;
        float32View[index2 + 6] = a3 * w0 + c3 * h1 + tx;
        float32View[index2 + 7] = d3 * h1 + b2 * w0 + ty;
        float32View[index2 + 8] = uvs.x1;
        float32View[index2 + 9] = uvs.y1;
        uint32View[index2 + 10] = argb;
        uint32View[index2 + 11] = textureIdAndRound;
        float32View[index2 + 12] = a3 * w0 + c3 * h0 + tx;
        float32View[index2 + 13] = d3 * h0 + b2 * w0 + ty;
        float32View[index2 + 14] = uvs.x2;
        float32View[index2 + 15] = uvs.y2;
        uint32View[index2 + 16] = argb;
        uint32View[index2 + 17] = textureIdAndRound;
        float32View[index2 + 18] = a3 * w1 + c3 * h0 + tx;
        float32View[index2 + 19] = d3 * h0 + b2 * w1 + ty;
        float32View[index2 + 20] = uvs.x3;
        float32View[index2 + 21] = uvs.y3;
        uint32View[index2 + 22] = argb;
        uint32View[index2 + 23] = textureIdAndRound;
      }
      packIndex(indexBuffer, index2, indicesOffset) {
        indexBuffer[index2] = indicesOffset + 0;
        indexBuffer[index2 + 1] = indicesOffset + 1;
        indexBuffer[index2 + 2] = indicesOffset + 2;
        indexBuffer[index2 + 3] = indicesOffset + 0;
        indexBuffer[index2 + 4] = indicesOffset + 2;
        indexBuffer[index2 + 5] = indicesOffset + 3;
      }
      reset() {
        this.renderable = null;
        this.texture = null;
        this.batcher = null;
        this.batch = null;
        this.bounds = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs
var CanvasTextPipe;
var init_CanvasTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs"() {
    init_Extensions();
    init_updateQuadBounds();
    init_PoolGroup();
    init_BatchableSprite();
    CanvasTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.runners.resolutionChange.add(this);
      }
      resolutionChange() {
        for (const i2 in this._gpuText) {
          const gpuText = this._gpuText[i2];
          const text = gpuText.batchableSprite.renderable;
          if (text._autoResolution) {
            text._resolution = this._renderer.resolution;
            text.onViewUpdate();
          }
        }
      }
      validateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const newKey = text._getKey();
        if (gpuText.currentKey !== newKey) {
          const { width, height } = this._renderer.canvasText.getTextureSize(
            text.text,
            text.resolution,
            text._style
          );
          if (
            // is only being used by this text:
            this._renderer.canvasText.getReferenceCount(gpuText.currentKey) === 1 && width === gpuText.texture._source.width && height === gpuText.texture._source.height
          ) {
            return false;
          }
          return true;
        }
        return false;
      }
      addRenderable(text, _instructionSet) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (text._didTextUpdate) {
          this._updateText(text);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(text) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (text._didTextUpdate) {
          this._updateText(text);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(text) {
        text.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableById(text.uid);
      }
      _destroyRenderableById(textUid) {
        const gpuText = this._gpuText[textUid];
        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[textUid] = null;
      }
      _updateText(text) {
        const newKey = text._getKey();
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(text);
        }
        text._didTextUpdate = false;
        const padding = text._style.padding;
        updateQuadBounds(batchableSprite.bounds, text._anchor, batchableSprite.texture, padding);
      }
      _updateGpuText(text) {
        const gpuText = this._getGpuText(text);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.texture) {
          this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
        }
        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
        gpuText.currentKey = text._getKey();
        batchableSprite.texture = gpuText.texture;
      }
      _getGpuText(text) {
        return this._gpuText[text.uid] || this.initGpuText(text);
      }
      initGpuText(text) {
        const gpuTextData = {
          texture: null,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite)
        };
        gpuTextData.batchableSprite.renderable = text;
        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
        this._gpuText[text.uid] = gpuTextData;
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        this._updateText(text);
        text.on("destroyed", this._destroyRenderableBound);
        return gpuTextData;
      }
      destroy() {
        for (const i2 in this._gpuText) {
          this._destroyRenderableById(i2);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    CanvasTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "text"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs
var CanvasPoolClass, CanvasPool;
var init_CanvasPool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs"() {
    init_adapter();
    init_pow2();
    CanvasPoolClass = class {
      constructor(canvasOptions) {
        this._canvasPool = /* @__PURE__ */ Object.create(null);
        this.canvasOptions = canvasOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       */
      _createCanvasAndContext(pixelWidth, pixelHeight) {
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = pixelWidth;
        canvas.height = pixelHeight;
        const context2 = canvas.getContext("2d");
        return { canvas, context: context2 };
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param minWidth - The minimum width of the render texture.
       * @param minHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @returns The new render texture.
       */
      getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
        minWidth = Math.ceil(minWidth * resolution - 1e-6);
        minHeight = Math.ceil(minHeight * resolution - 1e-6);
        minWidth = nextPow2(minWidth);
        minHeight = nextPow2(minHeight);
        const key = (minWidth << 17) + (minHeight << 1);
        if (!this._canvasPool[key]) {
          this._canvasPool[key] = [];
        }
        let canvasAndContext = this._canvasPool[key].pop();
        if (!canvasAndContext) {
          canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
        }
        return canvasAndContext;
      }
      /**
       * Place a render texture back into the pool.
       * @param canvasAndContext
       */
      returnCanvasAndContext(canvasAndContext) {
        const canvas = canvasAndContext.canvas;
        const { width, height } = canvas;
        const key = (width << 17) + (height << 1);
        this._canvasPool[key].push(canvasAndContext);
      }
      clear() {
        this._canvasPool = {};
      }
    };
    CanvasPool = new CanvasPoolClass();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs
var count, TexturePoolClass, TexturePool;
var init_TexturePool = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs"() {
    init_pow2();
    init_TextureSource();
    init_Texture();
    count = 0;
    TexturePoolClass = class {
      /**
       * @param textureOptions - options that will be passed to BaseRenderTexture constructor
       * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
       */
      constructor(textureOptions) {
        this._poolKeyHash = /* @__PURE__ */ Object.create(null);
        this._texturePool = {};
        this.textureOptions = textureOptions || {};
        this.enableFullScreen = false;
      }
      /**
       * Creates texture with params that were specified in pool constructor.
       * @param pixelWidth - Width of texture in pixels.
       * @param pixelHeight - Height of texture in pixels.
       * @param antialias
       */
      createTexture(pixelWidth, pixelHeight, antialias) {
        const textureSource = new TextureSource({
          ...this.textureOptions,
          width: pixelWidth,
          height: pixelHeight,
          resolution: 1,
          antialias,
          autoGarbageCollect: true
        });
        return new Texture({
          source: textureSource,
          label: `texturePool_${count++}`
        });
      }
      /**
       * Gets a Power-of-Two render texture or fullScreen texture
       * @param frameWidth - The minimum width of the render texture.
       * @param frameHeight - The minimum height of the render texture.
       * @param resolution - The resolution of the render texture.
       * @param antialias
       * @returns The new render texture.
       */
      getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);
        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);
        po2Width = nextPow2(po2Width);
        po2Height = nextPow2(po2Height);
        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
        if (!this._texturePool[key]) {
          this._texturePool[key] = [];
        }
        let texture = this._texturePool[key].pop();
        if (!texture) {
          texture = this.createTexture(po2Width, po2Height, antialias);
        }
        texture.source._resolution = resolution;
        texture.source.width = po2Width / resolution;
        texture.source.height = po2Height / resolution;
        texture.source.pixelWidth = po2Width;
        texture.source.pixelHeight = po2Height;
        texture.frame.x = 0;
        texture.frame.y = 0;
        texture.frame.width = frameWidth;
        texture.frame.height = frameHeight;
        texture.updateUvs();
        this._poolKeyHash[texture.uid] = key;
        return texture;
      }
      /**
       * Gets extra texture of the same size as input renderTexture
       * @param texture - The texture to check what size it is.
       * @param antialias - Whether to use antialias.
       * @returns A texture that is a power of two
       */
      getSameSizeTexture(texture, antialias = false) {
        const source2 = texture.source;
        return this.getOptimalTexture(texture.width, texture.height, source2._resolution, antialias);
      }
      /**
       * Place a render texture back into the pool.
       * @param renderTexture - The renderTexture to free
       */
      returnTexture(renderTexture) {
        const key = this._poolKeyHash[renderTexture.uid];
        this._texturePool[key].push(renderTexture);
      }
      /**
       * Clears the pool.
       * @param destroyTextures - Destroy all stored textures.
       */
      clear(destroyTextures) {
        destroyTextures = destroyTextures !== false;
        if (destroyTextures) {
          for (const i2 in this._texturePool) {
            const textures = this._texturePool[i2];
            if (textures) {
              for (let j3 = 0; j3 < textures.length; j3++) {
                textures[j3].destroy(true);
              }
            }
          }
        }
        this._texturePool = {};
      }
    };
    TexturePool = new TexturePoolClass();
  }
});

// node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs
function checkRow(data, width, y4) {
  for (let x5 = 0, index2 = 4 * y4 * width; x5 < width; ++x5, index2 += 4) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x5, top, bottom) {
  const stride = 4 * width;
  for (let y4 = top, index2 = top * stride + 4 * x5; y4 <= bottom; ++y4, index2 += stride) {
    if (data[index2 + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(canvas, resolution = 1) {
  const { width, height } = canvas;
  const context2 = canvas.getContext("2d", {
    willReadFrequently: true
  });
  if (context2 === null) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  const imageData = context2.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);
}
var init_getCanvasBoundingBox = __esm({
  "node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs"() {
    init_Rectangle();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs
var _FillGradient, FillGradient;
var init_FillGradient = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillGradient.mjs"() {
    init_Color();
    init_adapter();
    init_Matrix();
    init_ImageSource();
    init_Texture();
    init_uid();
    _FillGradient = class _FillGradient2 {
      constructor(x0, y0, x1, y1) {
        this.uid = uid("fillGradient");
        this.type = "linear";
        this.gradientStops = [];
        this._styleKey = null;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
      }
      addColorStop(offset, color2) {
        this.gradientStops.push({ offset, color: Color.shared.setValue(color2).toHexa() });
        this._styleKey = null;
        return this;
      }
      // TODO move to the system!
      buildLinearGradient() {
        const defaultSize = _FillGradient2.defaultTextureSize;
        const { gradientStops } = this;
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = defaultSize;
        canvas.height = defaultSize;
        const ctx = canvas.getContext("2d");
        const gradient = ctx.createLinearGradient(0, 0, _FillGradient2.defaultTextureSize, 1);
        for (let i2 = 0; i2 < gradientStops.length; i2++) {
          const stop = gradientStops[i2];
          gradient.addColorStop(stop.offset, stop.color);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture({
          source: new ImageSource({
            resource: canvas,
            addressModeU: "clamp-to-edge",
            addressModeV: "repeat"
          })
        });
        const { x0, y0, x1, y1 } = this;
        const m4 = new Matrix();
        const dx = x1 - x0;
        const dy = y1 - y0;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        m4.translate(-x0, -y0);
        m4.scale(1 / defaultSize, 1 / defaultSize);
        m4.rotate(-angle);
        m4.scale(256 / dist, 1);
        this.transform = m4;
        this._styleKey = null;
      }
      get styleKey() {
        if (this._styleKey) {
          return this._styleKey;
        }
        const stops = this.gradientStops.map((stop) => `${stop.offset}-${stop.color}`).join("-");
        const texture = this.texture.uid;
        const transform4 = this.transform.toArray().join("-");
        return `fill-gradient-${this.uid}-${stops}-${texture}-${transform4}-${this.x0}-${this.y0}-${this.x1}-${this.y1}`;
      }
    };
    _FillGradient.defaultTextureSize = 256;
    FillGradient = _FillGradient;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs
var repetitionMap, FillPattern;
var init_FillPattern = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/fill/FillPattern.mjs"() {
    init_Matrix();
    init_uid();
    repetitionMap = {
      repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
      },
      "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
      },
      "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
      },
      "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    };
    FillPattern = class {
      constructor(texture, repetition) {
        this.uid = uid("fillPattern");
        this.transform = new Matrix();
        this._styleKey = null;
        this.texture = texture;
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        if (repetition) {
          texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
          texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
        }
      }
      setTransform(transform4) {
        const texture = this.texture;
        this.transform.copyFrom(transform4);
        this.transform.invert();
        this.transform.scale(
          1 / texture.frame.width,
          1 / texture.frame.height
        );
        this._styleKey = null;
      }
      get styleKey() {
        if (this._styleKey)
          return this._styleKey;
        this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`;
        return this._styleKey;
      }
    };
  }
});

// node_modules/parse-svg-path/index.js
var require_parse_svg_path = __commonJS({
  "node_modules/parse-svg-path/index.js"(exports2, module2) {
    module2.exports = parse2;
    var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
    var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
    function parse2(path2) {
      var data = [];
      path2.replace(segment, function(_3, command, args) {
        var type2 = command.toLowerCase();
        args = parseValues(args);
        if (type2 == "m" && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type2 = "l";
          command = command == "m" ? "l" : "L";
        }
        while (true) {
          if (args.length == length[type2]) {
            args.unshift(command);
            return data.push(args);
          }
          if (args.length < length[type2]) throw new Error("malformed path data");
          data.push([command].concat(args.splice(0, length[type2])));
        }
      });
      return data;
    }
    var number3 = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
    function parseValues(args) {
      var numbers = args.match(number3);
      return numbers ? numbers.map(Number) : [];
    }
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs
function SVGToGraphicsPath(svgPath, path2) {
  const commands = (0, import_parse_svg_path.default)(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i2 = 0; i2 < commands.length; i2++) {
    const command = commands[i2];
    const type2 = command[0];
    const data = command;
    switch (type2) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path2.bezierCurveTo(
          data[1],
          data[2],
          data[3],
          data[4],
          lastX,
          lastY
        );
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          lastX + data[3],
          lastY + data[4],
          lastX + data[5],
          lastY + data[6]
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path2.bezierCurveToShort(
          data[1],
          data[2],
          lastX,
          lastY
        );
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          lastX + data[3],
          lastY + data[4]
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path2.quadraticCurveTo(
          data[1],
          data[2],
          lastX,
          lastY
        );
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          lastX + data[3],
          lastY + data[4]
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path2.arcToSvg(
          data[1],
          data[2],
          data[3],
          data[4],
          data[5],
          lastX,
          lastY
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path2.arcToSvg(
          data[1],
          data[2],
          data[3],
          data[4],
          data[5],
          lastX,
          lastY
        );
        break;
      case "Z":
      case "z":
        path2.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn(`Unknown SVG path command: ${type2}`);
    }
    if (type2 !== "Z" && type2 !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path2;
}
var import_parse_svg_path;
var init_SVGToGraphicsPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGToGraphicsPath.mjs"() {
    import_parse_svg_path = __toESM(require_parse_svg_path(), 1);
    init_warn();
  }
});

// node_modules/pixi.js/lib/maths/shapes/Circle.mjs
var Circle;
var init_Circle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Circle.mjs"() {
    init_Rectangle();
    Circle = class _Circle {
      /**
       * @param x - The X coordinate of the center of this circle
       * @param y - The Y coordinate of the center of this circle
       * @param radius - The radius of the circle
       */
      constructor(x5 = 0, y4 = 0, radius = 0) {
        this.type = "circle";
        this.x = x5;
        this.y = y4;
        this.radius = radius;
      }
      /**
       * Creates a clone of this Circle instance
       * @returns A copy of the Circle
       */
      clone() {
        return new _Circle(this.x, this.y, this.radius);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coordinates are within this Circle
       */
      contains(x5, y4) {
        if (this.radius <= 0)
          return false;
        const r2 = this.radius * this.radius;
        let dx = this.x - x5;
        let dy = this.y - y4;
        dx *= dx;
        dy *= dy;
        return dx + dy <= r2;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this circle including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param width - The width of the line to check
       * @returns Whether the x/y coordinates are within this Circle
       */
      strokeContains(x5, y4, width) {
        if (this.radius === 0)
          return false;
        const dx = this.x - x5;
        const dy = this.y - y4;
        const r2 = this.radius;
        const w2 = width / 2;
        const distance2 = Math.sqrt(dx * dx + dy * dy);
        return distance2 < r2 + w2 && distance2 > r2 - w2;
      }
      /**
       * Returns the framing rectangle of the circle as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x - this.radius;
        out2.y = this.y - this.radius;
        out2.width = this.radius * 2;
        out2.height = this.radius * 2;
        return out2;
      }
      /**
       * Copies another circle to this one.
       * @param circle - The circle to copy from.
       * @returns Returns itself.
       */
      copyFrom(circle) {
        this.x = circle.x;
        this.y = circle.y;
        this.radius = circle.radius;
        return this;
      }
      /**
       * Copies this circle to another one.
       * @param circle - The circle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(circle) {
        circle.copyFrom(this);
        return circle;
      }
      toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs
var Ellipse;
var init_Ellipse = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Ellipse.mjs"() {
    init_Rectangle();
    Ellipse = class _Ellipse {
      /**
       * @param x - The X coordinate of the center of this ellipse
       * @param y - The Y coordinate of the center of this ellipse
       * @param halfWidth - The half width of this ellipse
       * @param halfHeight - The half height of this ellipse
       */
      constructor(x5 = 0, y4 = 0, halfWidth = 0, halfHeight = 0) {
        this.type = "ellipse";
        this.x = x5;
        this.y = y4;
        this.halfWidth = halfWidth;
        this.halfHeight = halfHeight;
      }
      /**
       * Creates a clone of this Ellipse instance
       * @returns {Ellipse} A copy of the ellipse
       */
      clone() {
        return new _Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @returns Whether the x/y coords are within this ellipse
       */
      contains(x5, y4) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) {
          return false;
        }
        let normx = (x5 - this.x) / this.halfWidth;
        let normy = (y4 - this.y) / this.halfHeight;
        normx *= normx;
        normy *= normy;
        return normx + normy <= 1;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this ellipse including stroke
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param width
       * @returns Whether the x/y coords are within this ellipse
       */
      strokeContains(x5, y4, width) {
        const { halfWidth, halfHeight } = this;
        if (halfWidth <= 0 || halfHeight <= 0) {
          return false;
        }
        const halfStrokeWidth = width / 2;
        const innerA = halfWidth - halfStrokeWidth;
        const innerB = halfHeight - halfStrokeWidth;
        const outerA = halfWidth + halfStrokeWidth;
        const outerB = halfHeight + halfStrokeWidth;
        const normalizedX = x5 - this.x;
        const normalizedY = y4 - this.y;
        const innerEllipse = normalizedX * normalizedX / (innerA * innerA) + normalizedY * normalizedY / (innerB * innerB);
        const outerEllipse = normalizedX * normalizedX / (outerA * outerA) + normalizedY * normalizedY / (outerB * outerB);
        return innerEllipse > 1 && outerEllipse <= 1;
      }
      /**
       * Returns the framing rectangle of the ellipse as a Rectangle object
       * @param out
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x - this.halfWidth;
        out2.y = this.y - this.halfHeight;
        out2.width = this.halfWidth * 2;
        out2.height = this.halfHeight * 2;
        return out2;
      }
      /**
       * Copies another ellipse to this one.
       * @param ellipse - The ellipse to copy from.
       * @returns Returns itself.
       */
      copyFrom(ellipse) {
        this.x = ellipse.x;
        this.y = ellipse.y;
        this.halfWidth = ellipse.halfWidth;
        this.halfHeight = ellipse.halfHeight;
        return this;
      }
      /**
       * Copies this ellipse to another one.
       * @param ellipse - The ellipse to copy to.
       * @returns Returns given parameter.
       */
      copyTo(ellipse) {
        ellipse.copyFrom(this);
        return ellipse;
      }
      toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs
function squaredDistanceToLineSegment(x5, y4, x1, y1, x22, y22) {
  const a3 = x5 - x1;
  const b2 = y4 - y1;
  const c3 = x22 - x1;
  const d3 = y22 - y1;
  const dot = a3 * c3 + b2 * d3;
  const lenSq = c3 * c3 + d3 * d3;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x22;
    yy = y22;
  } else {
    xx = x1 + param * c3;
    yy = y1 + param * d3;
  }
  const dx = x5 - xx;
  const dy = y4 - yy;
  return dx * dx + dy * dy;
}
var init_squaredDistanceToLineSegment = __esm({
  "node_modules/pixi.js/lib/maths/misc/squaredDistanceToLineSegment.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/maths/shapes/Polygon.mjs
var Polygon;
var init_Polygon = __esm({
  "node_modules/pixi.js/lib/maths/shapes/Polygon.mjs"() {
    init_squaredDistanceToLineSegment();
    init_Rectangle();
    Polygon = class _Polygon {
      /**
       * @param points - This can be an array of Points
       *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
       *  the arguments passed can be all the points of the polygon e.g.
       *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
       *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
       */
      constructor(...points) {
        this.type = "polygon";
        let flat = Array.isArray(points[0]) ? points[0] : points;
        if (typeof flat[0] !== "number") {
          const p2 = [];
          for (let i2 = 0, il = flat.length; i2 < il; i2++) {
            p2.push(flat[i2].x, flat[i2].y);
          }
          flat = p2;
        }
        this.points = flat;
        this.closePath = true;
      }
      /**
       * Creates a clone of this polygon.
       * @returns - A copy of the polygon.
       */
      clone() {
        const points = this.points.slice();
        const polygon = new _Polygon(points);
        polygon.closePath = this.closePath;
        return polygon;
      }
      /**
       * Checks whether the x and y coordinates passed to this function are contained within this polygon.
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this polygon.
       */
      contains(x5, y4) {
        let inside = false;
        const length = this.points.length / 2;
        for (let i2 = 0, j3 = length - 1; i2 < length; j3 = i2++) {
          const xi = this.points[i2 * 2];
          const yi = this.points[i2 * 2 + 1];
          const xj = this.points[j3 * 2];
          const yj = this.points[j3 * 2 + 1];
          const intersect = yi > y4 !== yj > y4 && x5 < (xj - xi) * ((y4 - yi) / (yj - yi)) + xi;
          if (intersect) {
            inside = !inside;
          }
        }
        return inside;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
       * @param x - The X coordinate of the point to test
       * @param y - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @returns Whether the x/y coordinates are within this polygon
       */
      strokeContains(x5, y4, strokeWidth) {
        const halfStrokeWidth = strokeWidth / 2;
        const halfStrokeWidthSqrd = halfStrokeWidth * halfStrokeWidth;
        const { points } = this;
        const iterationLength = points.length - (this.closePath ? 0 : 2);
        for (let i2 = 0; i2 < iterationLength; i2 += 2) {
          const x1 = points[i2];
          const y1 = points[i2 + 1];
          const x22 = points[(i2 + 2) % points.length];
          const y22 = points[(i2 + 3) % points.length];
          const distanceSqrd = squaredDistanceToLineSegment(x5, y4, x1, y1, x22, y22);
          if (distanceSqrd <= halfStrokeWidthSqrd) {
            return true;
          }
        }
        return false;
      }
      /**
       * Returns the framing rectangle of the polygon as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        const points = this.points;
        let minX = Infinity;
        let maxX = -Infinity;
        let minY = Infinity;
        let maxY = -Infinity;
        for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
          const x5 = points[i2];
          const y4 = points[i2 + 1];
          minX = x5 < minX ? x5 : minX;
          maxX = x5 > maxX ? x5 : maxX;
          minY = y4 < minY ? y4 : minY;
          maxY = y4 > maxY ? y4 : maxY;
        }
        out2.x = minX;
        out2.width = maxX - minX;
        out2.y = minY;
        out2.height = maxY - minY;
        return out2;
      }
      /**
       * Copies another polygon to this one.
       * @param polygon - The polygon to copy from.
       * @returns Returns itself.
       */
      copyFrom(polygon) {
        this.points = polygon.points.slice();
        this.closePath = polygon.closePath;
        return this;
      }
      /**
       * Copies this polygon to another one.
       * @param polygon - The polygon to copy to.
       * @returns Returns given parameter.
       */
      copyTo(polygon) {
        polygon.copyFrom(this);
        return polygon;
      }
      toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
      }
      /**
       * Get the last X coordinate of the polygon
       * @readonly
       */
      get lastX() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the last Y coordinate of the polygon
       * @readonly
       */
      get lastY() {
        return this.points[this.points.length - 1];
      }
      /**
       * Get the first X coordinate of the polygon
       * @readonly
       */
      get x() {
        return this.points[this.points.length - 2];
      }
      /**
       * Get the first Y coordinate of the polygon
       * @readonly
       */
      get y() {
        return this.points[this.points.length - 1];
      }
    };
  }
});

// node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs
var isCornerWithinStroke, RoundedRectangle;
var init_RoundedRectangle = __esm({
  "node_modules/pixi.js/lib/maths/shapes/RoundedRectangle.mjs"() {
    init_Rectangle();
    isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, halfStrokeWidth) => {
      const dx = pX - cornerX;
      const dy = pY - cornerY;
      const distance2 = Math.sqrt(dx * dx + dy * dy);
      return distance2 >= radius - halfStrokeWidth && distance2 <= radius + halfStrokeWidth;
    };
    RoundedRectangle = class _RoundedRectangle {
      /**
       * @param x - The X coordinate of the upper-left corner of the rounded rectangle
       * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
       * @param width - The overall width of this rounded rectangle
       * @param height - The overall height of this rounded rectangle
       * @param radius - Controls the radius of the rounded corners
       */
      constructor(x5 = 0, y4 = 0, width = 0, height = 0, radius = 20) {
        this.type = "roundedRectangle";
        this.x = x5;
        this.y = y4;
        this.width = width;
        this.height = height;
        this.radius = radius;
      }
      /**
       * Returns the framing rectangle of the rounded rectangle as a Rectangle object
       * @param out - optional rectangle to store the result
       * @returns The framing rectangle
       */
      getBounds(out2) {
        out2 = out2 || new Rectangle();
        out2.x = this.x;
        out2.y = this.y;
        out2.width = this.width;
        out2.height = this.height;
        return out2;
      }
      /**
       * Creates a clone of this Rounded Rectangle.
       * @returns - A copy of the rounded rectangle.
       */
      clone() {
        return new _RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
      }
      /**
       * Copies another rectangle to this one.
       * @param rectangle - The rectangle to copy from.
       * @returns Returns itself.
       */
      copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
      }
      /**
       * Copies this rectangle to another one.
       * @param rectangle - The rectangle to copy to.
       * @returns Returns given parameter.
       */
      copyTo(rectangle) {
        rectangle.copyFrom(this);
        return rectangle;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
       * @param x - The X coordinate of the point to test.
       * @param y - The Y coordinate of the point to test.
       * @returns - Whether the x/y coordinates are within this Rounded Rectangle.
       */
      contains(x5, y4) {
        if (this.width <= 0 || this.height <= 0) {
          return false;
        }
        if (x5 >= this.x && x5 <= this.x + this.width) {
          if (y4 >= this.y && y4 <= this.y + this.height) {
            const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (y4 >= this.y + radius && y4 <= this.y + this.height - radius || x5 >= this.x + radius && x5 <= this.x + this.width - radius) {
              return true;
            }
            let dx = x5 - (this.x + radius);
            let dy = y4 - (this.y + radius);
            const radius2 = radius * radius;
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x5 - (this.x + this.width - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dy = y4 - (this.y + this.height - radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
            dx = x5 - (this.x + radius);
            if (dx * dx + dy * dy <= radius2) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
       * @param pX - The X coordinate of the point to test
       * @param pY - The Y coordinate of the point to test
       * @param strokeWidth - The width of the line to check
       * @returns Whether the x/y coordinates are within this rectangle
       */
      strokeContains(pX, pY, strokeWidth) {
        const { x: x5, y: y4, width, height, radius } = this;
        const halfStrokeWidth = strokeWidth / 2;
        const innerX = x5 + radius;
        const innerY = y4 + radius;
        const innerWidth = width - radius * 2;
        const innerHeight = height - radius * 2;
        const rightBound = x5 + width;
        const bottomBound = y4 + height;
        if ((pX >= x5 - halfStrokeWidth && pX <= x5 + halfStrokeWidth || pX >= rightBound - halfStrokeWidth && pX <= rightBound + halfStrokeWidth) && pY >= innerY && pY <= innerY + innerHeight) {
          return true;
        }
        if ((pY >= y4 - halfStrokeWidth && pY <= y4 + halfStrokeWidth || pY >= bottomBound - halfStrokeWidth && pY <= bottomBound + halfStrokeWidth) && pX >= innerX && pX <= innerX + innerWidth) {
          return true;
        }
        return (
          // Top-left
          pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, halfStrokeWidth) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, halfStrokeWidth) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, halfStrokeWidth)
        );
      }
      toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(x1, y1, x22, y22, x32, y32, x42, y4, points, distanceTolerance, level) {
  if (level > RECURSION_LIMIT) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y22) / 2;
  const x23 = (x22 + x32) / 2;
  const y23 = (y22 + y32) / 2;
  const x34 = (x32 + x42) / 2;
  const y34 = (y32 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level > 0) {
    let dx = x42 - x1;
    let dy = y4 - y1;
    const d22 = Math.abs((x22 - x42) * dy - (y22 - y4) * dx);
    const d3 = Math.abs((x32 - x42) * dy - (y32 - y4) * dx);
    let da1;
    let da2;
    if (d22 > FLT_EPSILON && d3 > FLT_EPSILON) {
      if ((d22 + d3) * (d22 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        const a23 = Math.atan2(y32 - y22, x32 - x22);
        da1 = Math.abs(a23 - Math.atan2(y22 - y1, x22 - x1));
        da2 = Math.abs(Math.atan2(y4 - y32, x42 - x32) - a23);
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da2 >= pi)
          da2 = 2 * pi - da2;
        if (da1 + da2 < mAngleTolerance) {
          points.push(x1234, y1234);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y22);
            return;
          }
          if (da2 > mCuspLimit) {
            points.push(x32, y32);
            return;
          }
        }
      }
    } else if (d22 > FLT_EPSILON) {
      if (d22 * d22 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y32 - y22, x32 - x22) - Math.atan2(y22 - y1, x22 - x1));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y22);
          points.push(x32, y32);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x22, y22);
            return;
          }
        }
      }
    } else if (d3 > FLT_EPSILON) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        if (mAngleTolerance < curveAngleToleranceEpsilon) {
          points.push(x1234, y1234);
          return;
        }
        da1 = Math.abs(Math.atan2(y4 - y32, x42 - x32) - Math.atan2(y32 - y22, x32 - x22));
        if (da1 >= pi)
          da1 = 2 * pi - da1;
        if (da1 < mAngleTolerance) {
          points.push(x22, y22);
          points.push(x32, y32);
          return;
        }
        if (mCuspLimit !== 0) {
          if (da1 > mCuspLimit) {
            points.push(x32, y32);
            return;
          }
        }
      }
    } else {
      dx = x1234 - (x1 + x42) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level + 1);
  recursive(x1234, y1234, x234, y234, x34, y34, x42, y4, points, distanceTolerance, level + 1);
}
var RECURSION_LIMIT, FLT_EPSILON, PATH_DISTANCE_EPSILON, curveAngleToleranceEpsilon, mAngleTolerance, mCuspLimit;
var init_buildAdaptiveBezier = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveBezier.mjs"() {
    init_GraphicsContextSystem();
    RECURSION_LIMIT = 8;
    FLT_EPSILON = 11920929e-14;
    PATH_DISTANCE_EPSILON = 1;
    curveAngleToleranceEpsilon = 0.01;
    mAngleTolerance = 0;
    mCuspLimit = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON2 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin2(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive2(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive2(points, x1, y1, x22, y22, x32, y32, distanceTolerance, level) {
  if (level > RECURSION_LIMIT2) {
    return;
  }
  const pi = Math.PI;
  const x12 = (x1 + x22) / 2;
  const y12 = (y1 + y22) / 2;
  const x23 = (x22 + x32) / 2;
  const y23 = (y22 + y32) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x32 - x1;
  let dy = y32 - y1;
  const d3 = Math.abs((x22 - x32) * dy - (y22 - y32) * dx);
  if (d3 > FLT_EPSILON2) {
    if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
      if (mAngleTolerance2 < curveAngleToleranceEpsilon2) {
        points.push(x123, y123);
        return;
      }
      let da = Math.abs(Math.atan2(y32 - y22, x32 - x22) - Math.atan2(y22 - y1, x22 - x1));
      if (da >= pi)
        da = 2 * pi - da;
      if (da < mAngleTolerance2) {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x32) / 2;
    dy = y123 - (y1 + y32) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive2(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
  recursive2(points, x123, y123, x23, y23, x32, y32, distanceTolerance, level + 1);
}
var RECURSION_LIMIT2, FLT_EPSILON2, PATH_DISTANCE_EPSILON2, curveAngleToleranceEpsilon2, mAngleTolerance2;
var init_buildAdaptiveQuadratic = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildAdaptiveQuadratic.mjs"() {
    init_GraphicsContextSystem();
    RECURSION_LIMIT2 = 8;
    FLT_EPSILON2 = 11920929e-14;
    PATH_DISTANCE_EPSILON2 = 1;
    curveAngleToleranceEpsilon2 = 0.01;
    mAngleTolerance2 = 0;
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs
function buildArc(points, x5, y4, radius, start2, end, clockwise, steps) {
  let dist = Math.abs(start2 - end);
  if (!clockwise && start2 > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start2) {
    dist = 2 * Math.PI - dist;
  }
  steps = steps || Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI)));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start2;
  f2 *= clockwise ? -1 : 1;
  for (let i2 = 0; i2 < steps + 1; i2++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x5 + cs * radius;
    const ny = y4 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
var init_buildArc = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArc.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs
function buildArcTo(points, x1, y1, x22, y22, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a22 = y22 - y1;
  const b2 = x22 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a22);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a22 * a22 + b2 * b2;
  const tt = a1 * a22 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k22 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j22 = k22 * tt / cc;
  const cx = k1 * b2 + k22 * b1;
  const cy = k1 * a22 + k22 * a1;
  const px = b1 * (k22 + j1);
  const py = a1 * (k22 + j1);
  const qx = b2 * (k1 + j22);
  const qy = a22 * (k1 + j22);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a22 > b2 * a1
  );
}
var init_buildArcTo = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcTo.mjs"() {
    init_buildArc();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a3 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x22 = Math.cos(ang1 + ang2);
  const y22 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a3,
      y: y1 + x1 * a3
    },
    {
      x: x22 + y22 * a3,
      y: y22 - x22 * a3
    },
    {
      x: x22,
      y: y22
    }
  ];
}
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i2 = 0; i2 < segments; i2++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x22, y: y22 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x5, y: y4 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x22,
      y22,
      x5,
      y4
    );
    lastX = x5;
    lastY = y4;
    ang1 += ang2;
  }
}
var TAU, out, mapToEllipse, vectorAngle, getArcCenter;
var init_buildArcToSvg = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/buildCommands/buildArcToSvg.mjs"() {
    init_buildAdaptiveBezier();
    TAU = Math.PI * 2;
    out = {
      centerX: 0,
      centerY: 0,
      ang1: 0,
      ang2: 0
    };
    mapToEllipse = ({ x: x5, y: y4 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
      x5 *= rx;
      y4 *= ry;
      const xp = cosPhi * x5 - sinPhi * y4;
      const yp = sinPhi * x5 + cosPhi * y4;
      out2.x = xp + centerX;
      out2.y = yp + centerY;
      return out2;
    };
    vectorAngle = (ux2, uy2, vx2, vy2) => {
      const sign = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
      let dot = ux2 * vx2 + uy2 * vy2;
      if (dot > 1) {
        dot = 1;
      }
      if (dot < -1) {
        dot = -1;
      }
      return sign * Math.acos(dot);
    };
    getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
      const rxSq = Math.pow(rx, 2);
      const rySq = Math.pow(ry, 2);
      const pxpSq = Math.pow(pxp, 2);
      const pypSq = Math.pow(pyp, 2);
      let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
      if (radicant < 0) {
        radicant = 0;
      }
      radicant /= rxSq * pypSq + rySq * pxpSq;
      radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
      const centerXp = radicant * rx / ry * pyp;
      const centerYp = radicant * -ry / rx * pxp;
      const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
      const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
      const vx1 = (pxp - centerXp) / rx;
      const vy1 = (pyp - centerYp) / ry;
      const vx2 = (-pxp - centerXp) / rx;
      const vy2 = (-pyp - centerYp) / ry;
      const ang1 = vectorAngle(1, 0, vx1, vy1);
      let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
      if (sweepFlag === 0 && ang2 > 0) {
        ang2 -= TAU;
      }
      if (sweepFlag === 1 && ang2 < 0) {
        ang2 += TAU;
      }
      out2.centerX = centerX;
      out2.centerY = centerY;
      out2.ang1 = ang1;
      out2.ang2 = ang2;
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs
function roundedShapeArc(g2, points, radius) {
  const vecFrom = (p2, pp) => {
    const x5 = pp.x - p2.x;
    const y4 = pp.y - p2.y;
    const len = Math.sqrt(x5 * x5 + y4 * y4);
    const nx = x5 / len;
    const ny = y4 / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i2, p2) => {
    if (i2 === 0) {
      g2.moveTo(p2.x, p2.y);
    } else {
      g2.lineTo(p2.x, p2.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2 % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i2 + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v22 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v22.len < 1e-4) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v22.ny - v1.ny * v22.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v22.nx - v1.ny * -v22.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v22.len / 2)) {
      lenOut = Math.min(v1.len / 2, v22.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v22.nx * lenOut + -v22.ny * cRadius * radDirection;
    const cY = p2.y + v22.ny * lenOut + v22.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v22.ny, v22.nx) - Math.PI / 2 * radDirection;
    if (i2 === 0) {
      g2.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
  const distance2 = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t2) => ({
    x: p1.x + (p2.x - p1.x) * t2,
    y: p1.y + (p2.y - p1.y) * t2
  });
  const numPoints = points.length;
  for (let i2 = 0; i2 < numPoints; i2++) {
    const thisPoint = points[(i2 + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i2 === 0) {
        g2.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g2.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i2];
    const nextPoint = points[(i2 + 2) % numPoints];
    const lastEdgeLength = distance2(lastPoint, thisPoint);
    let start2;
    if (lastEdgeLength < 1e-4) {
      start2 = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start2 = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance2(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i2 === 0) {
      g2.moveTo(start2.x, start2.y);
    } else {
      g2.lineTo(start2.x, start2.y);
    }
    g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}
var init_roundShape = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/roundShape.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs
var tempRectangle, ShapePath;
var init_ShapePath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/ShapePath.mjs"() {
    init_Circle();
    init_Ellipse();
    init_Polygon();
    init_Rectangle();
    init_RoundedRectangle();
    init_Bounds();
    init_buildAdaptiveBezier();
    init_buildAdaptiveQuadratic();
    init_buildArc();
    init_buildArcTo();
    init_buildArcToSvg();
    init_roundShape();
    tempRectangle = new Rectangle();
    ShapePath = class {
      constructor(graphicsPath2D) {
        this.shapePrimitives = [];
        this._currentPoly = null;
        this._bounds = new Bounds();
        this._graphicsPath2D = graphicsPath2D;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x5, y4) {
        this.startPoly(x5, y4);
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x5, y4) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        const fromX = points[points.length - 2];
        const fromY = points[points.length - 1];
        if (fromX !== x5 || fromY !== y4) {
          points.push(x5, y4);
        }
        return this;
      }
      /**
       * Adds an arc to the path. The arc is centered at (x, y)
       *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The radius of the arc.
       * @param startAngle - The starting angle of the arc, in radians.
       * @param endAngle - The ending angle of the arc, in radians.
       * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
       * @returns The instance of the current object for chaining.
       */
      arc(x5, y4, radius, startAngle, endAngle, counterclockwise) {
        this._ensurePoly(false);
        const points = this._currentPoly.points;
        buildArc(points, x5, y4, radius, startAngle, endAngle, counterclockwise);
        return this;
      }
      /**
       * Adds an arc to the path with the arc tangent to the line joining two specified points.
       * The arc radius is specified by `radius`.
       * @param x1 - The x-coordinate of the first point.
       * @param y1 - The y-coordinate of the first point.
       * @param x2 - The x-coordinate of the second point.
       * @param y2 - The y-coordinate of the second point.
       * @param radius - The radius of the arc.
       * @returns The instance of the current object for chaining.
       */
      arcTo(x1, y1, x22, y22, radius) {
        this._ensurePoly();
        const points = this._currentPoly.points;
        buildArcTo(points, x1, y1, x22, y22, radius);
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x5, y4) {
        const points = this._currentPoly.points;
        buildArcToSvg(
          points,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          x5,
          y4,
          rx,
          ry,
          xAxisRotation,
          largeArcFlag,
          sweepFlag
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x5, y4, smoothness) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveBezier(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          cp2x,
          cp2y,
          x5,
          y4,
          smoothness
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the control point.
       * @param cp1y - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothing - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cp1x, cp1y, x5, y4, smoothing) {
        this._ensurePoly();
        const currentPoly = this._currentPoly;
        buildAdaptiveQuadratic(
          this._currentPoly.points,
          currentPoly.lastX,
          currentPoly.lastY,
          cp1x,
          cp1y,
          x5,
          y4,
          smoothing
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.endPoly(true);
        return this;
      }
      /**
       * Adds another path to the current path. This method allows for the combination of multiple paths into one.
       * @param path - The `GraphicsPath` object representing the path to add.
       * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform4) {
        this.endPoly();
        if (transform4 && !transform4.isIdentity()) {
          path2 = path2.clone(true);
          path2.transform(transform4);
        }
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        return this;
      }
      /**
       * Finalizes the drawing of the current path. Optionally, it can close the path.
       * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
       */
      finish(closePath = false) {
        this.endPoly(closePath);
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x5, y4, w2, h2, transform4) {
        this.drawShape(new Rectangle(x5, y4, w2, h2), transform4);
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x5, y4, radius, transform4) {
        this.drawShape(new Circle(x5, y4, radius), transform4);
        return this;
      }
      /**
       * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
       * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      poly(points, close, transform4) {
        const polygon = new Polygon(points);
        polygon.closePath = close;
        this.drawShape(polygon, transform4);
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x5, y4, radius, sides, rotation = 0, transform4) {
        sides = Math.max(sides | 0, 3);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const polygon = [];
        for (let i2 = 0; i2 < sides; i2++) {
          const angle = i2 * delta + startAngle;
          polygon.push(
            x5 + radius * Math.cos(angle),
            y4 + radius * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform4);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x5, y4, radius, sides, corner, rotation = 0, smoothness) {
        sides = Math.max(sides | 0, 3);
        if (corner <= 0) {
          return this.regularPoly(x5, y4, radius, sides, rotation);
        }
        const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
        corner = Math.min(corner, sideLength);
        const startAngle = -1 * Math.PI / 2 + rotation;
        const delta = Math.PI * 2 / sides;
        const internalAngle = (sides - 2) * Math.PI / sides / 2;
        for (let i2 = 0; i2 < sides; i2++) {
          const angle = i2 * delta + startAngle;
          const x0 = x5 + radius * Math.cos(angle);
          const y0 = y4 + radius * Math.sin(angle);
          const a1 = angle + Math.PI + internalAngle;
          const a22 = angle - Math.PI - internalAngle;
          const x1 = x0 + corner * Math.cos(a1);
          const y1 = y0 + corner * Math.sin(a1);
          const x32 = x0 + corner * Math.cos(a22);
          const y32 = y0 + corner * Math.sin(a22);
          if (i2 === 0) {
            this.moveTo(x1, y1);
          } else {
            this.lineTo(x1, y1);
          }
          this.quadraticCurveTo(x0, y0, x32, y32, smoothness);
        }
        return this.closePath();
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic = false, smoothness) {
        if (points.length < 3) {
          return this;
        }
        if (useQuadratic) {
          roundedShapeQuadraticCurve(this, points, radius, smoothness);
        } else {
          roundedShapeArc(this, points, radius);
        }
        return this.closePath();
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x5, y4, width, height, fillet) {
        if (fillet === 0) {
          return this.rect(x5, y4, width, height);
        }
        const maxFillet = Math.min(width, height) / 2;
        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
        const right = x5 + width;
        const bottom = y4 + height;
        const dir = inset < 0 ? -inset : 0;
        const size = Math.abs(inset);
        return this.moveTo(x5, y4 + size).arcTo(x5 + dir, y4 + dir, x5 + size, y4, size).lineTo(right - size, y4).arcTo(right - dir, y4 + dir, right, y4 + size, size).lineTo(right, bottom - size).arcTo(right - dir, bottom - dir, x5 + width - size, bottom, size).lineTo(x5 + size, bottom).arcTo(x5 + dir, bottom - dir, x5, bottom - size, size).closePath();
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x5, y4, width, height, chamfer, transform4) {
        if (chamfer <= 0) {
          return this.rect(x5, y4, width, height);
        }
        const inset = Math.min(chamfer, Math.min(width, height) / 2);
        const right = x5 + width;
        const bottom = y4 + height;
        const points = [
          x5 + inset,
          y4,
          right - inset,
          y4,
          right,
          y4 + inset,
          right,
          bottom - inset,
          right - inset,
          bottom,
          x5 + inset,
          bottom,
          x5,
          bottom - inset,
          x5,
          y4 + inset
        ];
        for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
          if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
            points.splice(i2 - 1, 2);
          }
        }
        return this.poly(points, true, transform4);
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x5, y4, radiusX, radiusY, transform4) {
        this.drawShape(new Ellipse(x5, y4, radiusX, radiusY), transform4);
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x5, y4, w2, h2, radius, transform4) {
        this.drawShape(new RoundedRectangle(x5, y4, w2, h2, radius), transform4);
        return this;
      }
      /**
       * Draws a given shape on the canvas.
       * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
       * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
       * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
       * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
       * scaling, and translations.
       * @returns The instance of the current object for chaining.
       */
      drawShape(shape, matrix) {
        this.endPoly();
        this.shapePrimitives.push({ shape, transform: matrix });
        return this;
      }
      /**
       * Starts a new polygon path from the specified starting point.
       * This method initializes a new polygon or ends the current one if it exists.
       * @param x - The x-coordinate of the starting point of the new polygon.
       * @param y - The y-coordinate of the starting point of the new polygon.
       * @returns The instance of the current object for chaining.
       */
      startPoly(x5, y4) {
        let currentPoly = this._currentPoly;
        if (currentPoly) {
          this.endPoly();
        }
        currentPoly = new Polygon();
        currentPoly.points.push(x5, y4);
        this._currentPoly = currentPoly;
        return this;
      }
      /**
       * Ends the current polygon path. If `closePath` is set to true,
       * the path is closed by connecting the last point to the first one.
       * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
       * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
       *  back to the starting point. False by default.
       * @returns The instance of the current object for chaining.
       */
      endPoly(closePath = false) {
        const shape = this._currentPoly;
        if (shape && shape.points.length > 2) {
          shape.closePath = closePath;
          this.shapePrimitives.push({ shape });
        }
        this._currentPoly = null;
        return this;
      }
      _ensurePoly(start2 = true) {
        if (this._currentPoly)
          return;
        this._currentPoly = new Polygon();
        if (start2) {
          const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
          if (lastShape) {
            let lx = lastShape.shape.x;
            let ly = lastShape.shape.y;
            if (lastShape.transform && !lastShape.transform.isIdentity()) {
              const t2 = lastShape.transform;
              const tempX = lx;
              lx = t2.a * lx + t2.c * ly + t2.tx;
              ly = t2.b * tempX + t2.d * ly + t2.ty;
            }
            this._currentPoly.points.push(lx, ly);
          } else {
            this._currentPoly.points.push(0, 0);
          }
        }
      }
      /** Builds the path. */
      buildPath() {
        const path2 = this._graphicsPath2D;
        this.shapePrimitives.length = 0;
        this._currentPoly = null;
        for (let i2 = 0; i2 < path2.instructions.length; i2++) {
          const instruction = path2.instructions[i2];
          this[instruction.action](...instruction.data);
        }
        this.finish();
      }
      /** Gets the bounds of the path. */
      get bounds() {
        const bounds = this._bounds;
        bounds.clear();
        const shapePrimitives = this.shapePrimitives;
        for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
          const shapePrimitive = shapePrimitives[i2];
          const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
          if (shapePrimitive.transform) {
            bounds.addRect(boundsRect, shapePrimitive.transform);
          } else {
            bounds.addRect(boundsRect);
          }
        }
        return bounds;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs
function adjustTransform(currentMatrix, transform4) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform4);
  }
  return transform4.clone();
}
var GraphicsPath;
var init_GraphicsPath = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/path/GraphicsPath.mjs"() {
    init_Point();
    init_uid();
    init_warn();
    init_SVGToGraphicsPath();
    init_ShapePath();
    GraphicsPath = class _GraphicsPath {
      /**
       * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
       * @param instructions - An SVG path string or an array of `PathInstruction` objects.
       */
      constructor(instructions) {
        this.instructions = [];
        this.uid = uid("graphicsPath");
        this._dirty = true;
        if (typeof instructions === "string") {
          SVGToGraphicsPath(instructions, this);
        } else {
          this.instructions = instructions?.slice() ?? [];
        }
      }
      /**
       * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
       * @returns The `ShapePath` instance associated with this `GraphicsPath`.
       */
      get shapePath() {
        if (!this._shapePath) {
          this._shapePath = new ShapePath(this);
        }
        if (this._dirty) {
          this._dirty = false;
          this._shapePath.buildPath();
        }
        return this._shapePath;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @param transform - An optional transformation to apply to the added path.
       * @returns The instance of the current object for chaining.
       */
      addPath(path2, transform4) {
        path2 = path2.clone();
        this.instructions.push({ action: "addPath", data: [path2, transform4] });
        this._dirty = true;
        return this;
      }
      arc(...args) {
        this.instructions.push({ action: "arc", data: args });
        this._dirty = true;
        return this;
      }
      arcTo(...args) {
        this.instructions.push({ action: "arcTo", data: args });
        this._dirty = true;
        return this;
      }
      arcToSvg(...args) {
        this.instructions.push({ action: "arcToSvg", data: args });
        this._dirty = true;
        return this;
      }
      bezierCurveTo(...args) {
        this.instructions.push({ action: "bezierCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires two points: the second control point and the end point. The first control point is assumed to be
       * The starting point is the last point in the current path.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveToShort(cp2x, cp2y, x5, y4, smoothness) {
        const last2 = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cp1x = 0;
        let cp1y = 0;
        if (!last2 || last2.action !== "bezierCurveTo") {
          cp1x = lastPoint.x;
          cp1y = lastPoint.y;
        } else {
          cp1x = last2.data[2];
          cp1y = last2.data[3];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cp1x = currentX + (currentX - cp1x);
          cp1y = currentY + (currentY - cp1y);
        }
        this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x5, y4, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this.instructions.push({ action: "closePath", data: [] });
        this._dirty = true;
        return this;
      }
      ellipse(...args) {
        this.instructions.push({ action: "ellipse", data: args });
        this._dirty = true;
        return this;
      }
      lineTo(...args) {
        this.instructions.push({ action: "lineTo", data: args });
        this._dirty = true;
        return this;
      }
      moveTo(...args) {
        this.instructions.push({ action: "moveTo", data: args });
        return this;
      }
      quadraticCurveTo(...args) {
        this.instructions.push({ action: "quadraticCurveTo", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It uses the previous point as the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveToShort(x5, y4, smoothness) {
        const last2 = this.instructions[this.instructions.length - 1];
        const lastPoint = this.getLastPoint(Point.shared);
        let cpx1 = 0;
        let cpy1 = 0;
        if (!last2 || last2.action !== "quadraticCurveTo") {
          cpx1 = lastPoint.x;
          cpy1 = lastPoint.y;
        } else {
          cpx1 = last2.data[0];
          cpy1 = last2.data[1];
          const currentX = lastPoint.x;
          const currentY = lastPoint.y;
          cpx1 = currentX + (currentX - cpx1);
          cpy1 = currentY + (currentY - cpy1);
        }
        this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x5, y4, smoothness] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x5, y4, w2, h2, transform4) {
        this.instructions.push({ action: "rect", data: [x5, y4, w2, h2, transform4] });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @param transform - An optional `Matrix` object to apply a transformation to the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x5, y4, radius, transform4) {
        this.instructions.push({ action: "circle", data: [x5, y4, radius, transform4] });
        this._dirty = true;
        return this;
      }
      roundRect(...args) {
        this.instructions.push({ action: "roundRect", data: args });
        this._dirty = true;
        return this;
      }
      poly(...args) {
        this.instructions.push({ action: "poly", data: args });
        this._dirty = true;
        return this;
      }
      regularPoly(...args) {
        this.instructions.push({ action: "regularPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundPoly(...args) {
        this.instructions.push({ action: "roundPoly", data: args });
        this._dirty = true;
        return this;
      }
      roundShape(...args) {
        this.instructions.push({ action: "roundShape", data: args });
        this._dirty = true;
        return this;
      }
      filletRect(...args) {
        this.instructions.push({ action: "filletRect", data: args });
        this._dirty = true;
        return this;
      }
      chamferRect(...args) {
        this.instructions.push({ action: "chamferRect", data: args });
        this._dirty = true;
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @param transform - An optional `Matrix` object to apply a transformation to the star.
       * This can include rotations, scaling, and translations.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      // eslint-disable-next-line max-len
      star(x5, y4, points, radius, innerRadius, rotation, transform4) {
        innerRadius = innerRadius || radius / 2;
        const startAngle = -1 * Math.PI / 2 + rotation;
        const len = points * 2;
        const delta = Math.PI * 2 / len;
        const polygon = [];
        for (let i2 = 0; i2 < len; i2++) {
          const r2 = i2 % 2 ? innerRadius : radius;
          const angle = i2 * delta + startAngle;
          polygon.push(
            x5 + r2 * Math.cos(angle),
            y4 + r2 * Math.sin(angle)
          );
        }
        this.poly(polygon, true, transform4);
        return this;
      }
      /**
       * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
       * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
       * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
       * do not affect the original `GraphicsPath` and vice versa.
       * @param deep - A boolean flag indicating whether the clone should be deep.
       * @returns A new `GraphicsPath` instance that is a clone of the current instance.
       */
      clone(deep = false) {
        const newGraphicsPath2D = new _GraphicsPath();
        if (!deep) {
          newGraphicsPath2D.instructions = this.instructions.slice();
        } else {
          for (let i2 = 0; i2 < this.instructions.length; i2++) {
            const instruction = this.instructions[i2];
            newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
          }
        }
        return newGraphicsPath2D;
      }
      clear() {
        this.instructions.length = 0;
        this._dirty = true;
        return this;
      }
      /**
       * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
       * This method enables the modification of the path's geometry according to the provided
       * transformation matrix, which can include translations, rotations, scaling, and skewing.
       *
       * Each drawing instruction in the path is updated to reflect the transformation,
       * ensuring the visual representation of the path is consistent with the applied matrix.
       *
       * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
       * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
       * allowing for fine-grained control over the path's appearance.
       * @param matrix - A `Matrix` object representing the transformation to apply.
       * @returns The instance of the current object for chaining further operations.
       */
      transform(matrix) {
        if (matrix.isIdentity())
          return this;
        const a3 = matrix.a;
        const b2 = matrix.b;
        const c3 = matrix.c;
        const d3 = matrix.d;
        const tx = matrix.tx;
        const ty = matrix.ty;
        let x5 = 0;
        let y4 = 0;
        let cpx1 = 0;
        let cpy1 = 0;
        let cpx2 = 0;
        let cpy2 = 0;
        let rx = 0;
        let ry = 0;
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const data = instruction.data;
          switch (instruction.action) {
            case "moveTo":
            case "lineTo":
              x5 = data[0];
              y4 = data[1];
              data[0] = a3 * x5 + c3 * y4 + tx;
              data[1] = b2 * x5 + d3 * y4 + ty;
              break;
            case "bezierCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              cpx2 = data[2];
              cpy2 = data[3];
              x5 = data[4];
              y4 = data[5];
              data[0] = a3 * cpx1 + c3 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a3 * cpx2 + c3 * cpy2 + tx;
              data[3] = b2 * cpx2 + d3 * cpy2 + ty;
              data[4] = a3 * x5 + c3 * y4 + tx;
              data[5] = b2 * x5 + d3 * y4 + ty;
              break;
            case "quadraticCurveTo":
              cpx1 = data[0];
              cpy1 = data[1];
              x5 = data[2];
              y4 = data[3];
              data[0] = a3 * cpx1 + c3 * cpy1 + tx;
              data[1] = b2 * cpx1 + d3 * cpy1 + ty;
              data[2] = a3 * x5 + c3 * y4 + tx;
              data[3] = b2 * x5 + d3 * y4 + ty;
              break;
            case "arcToSvg":
              x5 = data[5];
              y4 = data[6];
              rx = data[0];
              ry = data[1];
              data[0] = a3 * rx + c3 * ry;
              data[1] = b2 * rx + d3 * ry;
              data[5] = a3 * x5 + c3 * y4 + tx;
              data[6] = b2 * x5 + d3 * y4 + ty;
              break;
            case "circle":
              data[4] = adjustTransform(data[3], matrix);
              break;
            case "rect":
              data[4] = adjustTransform(data[4], matrix);
              break;
            case "ellipse":
              data[8] = adjustTransform(data[8], matrix);
              break;
            case "roundRect":
              data[5] = adjustTransform(data[5], matrix);
              break;
            case "addPath":
              data[0].transform(matrix);
              break;
            case "poly":
              data[2] = adjustTransform(data[2], matrix);
              break;
            default:
              warn("unknown transform action", instruction.action);
              break;
          }
        }
        this._dirty = true;
        return this;
      }
      get bounds() {
        return this.shapePath.bounds;
      }
      /**
       * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
       * This method is useful for operations that depend on the path's current endpoint,
       * such as connecting subsequent shapes or paths. It supports various drawing instructions,
       * ensuring the last point's position is accurately determined regardless of the path's complexity.
       *
       * If the last instruction is a `closePath`, the method iterates backward through the instructions
       *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
       * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
       * the last point from the nested path.
       * @param out - A `Point` object where the last point's coordinates will be stored.
       * This object is modified directly to contain the result.
       * @returns The `Point` object containing the last point's coordinates.
       */
      getLastPoint(out2) {
        let index2 = this.instructions.length - 1;
        let lastInstruction = this.instructions[index2];
        if (!lastInstruction) {
          out2.x = 0;
          out2.y = 0;
          return out2;
        }
        while (lastInstruction.action === "closePath") {
          index2--;
          if (index2 < 0) {
            out2.x = 0;
            out2.y = 0;
            return out2;
          }
          lastInstruction = this.instructions[index2];
        }
        switch (lastInstruction.action) {
          case "moveTo":
          case "lineTo":
            out2.x = lastInstruction.data[0];
            out2.y = lastInstruction.data[1];
            break;
          case "quadraticCurveTo":
            out2.x = lastInstruction.data[2];
            out2.y = lastInstruction.data[3];
            break;
          case "bezierCurveTo":
            out2.x = lastInstruction.data[4];
            out2.y = lastInstruction.data[5];
            break;
          case "arc":
          case "arcToSvg":
            out2.x = lastInstruction.data[5];
            out2.y = lastInstruction.data[6];
            break;
          case "addPath":
            lastInstruction.data[0].getLastPoint(out2);
            break;
        }
        return out2;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    path: new GraphicsPath()
  };
  renderChildren(svg, session, null, null);
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children2 = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseStyle(svg);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  session.context.fillStyle = fillStyle;
  session.context.strokeStyle = strokeStyle;
  let x5;
  let y4;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d3;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path":
      d3 = svg.getAttribute("d");
      graphicsPath = new GraphicsPath(d3);
      session.context.path(graphicsPath);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "circle":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      r2 = parseFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "rect":
      x5 = parseFloatAttribute(svg, "x", 0);
      y4 = parseFloatAttribute(svg, "y", 0);
      width = parseFloatAttribute(svg, "width", 0);
      height = parseFloatAttribute(svg, "height", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x5, y4, width, height, rx || ry);
      } else {
        session.context.rect(x5, y4, width, height);
      }
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "ellipse":
      cx = parseFloatAttribute(svg, "cx", 0);
      cy = parseFloatAttribute(svg, "cy", 0);
      rx = parseFloatAttribute(svg, "rx", 0);
      ry = parseFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "line":
      x1 = parseFloatAttribute(svg, "x1", 0);
      y1 = parseFloatAttribute(svg, "y1", 0);
      x22 = parseFloatAttribute(svg, "x2", 0);
      y22 = parseFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill();
      if (strokeStyle)
        session.context.stroke();
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke();
      break;
    case "g":
    case "svg":
      break;
    default: {
      console.info(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  for (let i2 = 0; i2 < children2.length; i2++) {
    renderChildren(children2[i2], session, fillStyle, strokeStyle);
  }
}
function parseFloatAttribute(svg, id2, defaultValue2) {
  const value = svg.getAttribute(id2);
  return value ? Number(value) : defaultValue2;
}
function parseStyle(svg) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  let useFill = false;
  let useStroke = false;
  if (style) {
    const styleParts = style.split(";");
    for (let i2 = 0; i2 < styleParts.length; i2++) {
      const stylePart = styleParts[i2];
      const [key, value] = stylePart.split(":");
      switch (key) {
        case "stroke":
          if (value !== "none") {
            strokeStyle.color = Color.shared.setValue(value).toNumber();
            useStroke = true;
          }
          break;
        case "stroke-width":
          strokeStyle.width = Number(value);
          break;
        case "fill":
          if (value !== "none") {
            useFill = true;
            fillStyle.color = Color.shared.setValue(value).toNumber();
          }
          break;
        case "fill-opacity":
          fillStyle.alpha = Number(value);
          break;
        case "stroke-opacity":
          strokeStyle.alpha = Number(value);
          break;
        case "opacity":
          fillStyle.alpha = Number(value);
          strokeStyle.alpha = Number(value);
          break;
      }
    }
  } else {
    const stroke = svg.getAttribute("stroke");
    if (stroke && stroke !== "none") {
      useStroke = true;
      strokeStyle.color = Color.shared.setValue(stroke).toNumber();
      strokeStyle.width = parseFloatAttribute(svg, "stroke-width", 1);
    }
    const fill = svg.getAttribute("fill");
    if (fill && fill !== "none") {
      useFill = true;
      fillStyle.color = Color.shared.setValue(fill).toNumber();
    }
  }
  return {
    strokeStyle: useStroke ? strokeStyle : null,
    fillStyle: useFill ? fillStyle : null
  };
}
var init_SVGParser = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/svg/SVGParser.mjs"() {
    init_Color();
    init_GraphicsPath();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs
function isColorLike(value) {
  return Color.isColorLike(value);
}
function isFillPattern(value) {
  return value instanceof FillPattern;
}
function isFillGradient(value) {
  return value instanceof FillGradient;
}
function handleColorLike(fill, value, defaultStyle) {
  const temp = Color.shared.setValue(value ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value, defaultStyle) {
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value, defaultStyle) {
  value.buildLinearGradient();
  fill.fill = value;
  fill.color = 16777215;
  fill.texture = value.texture;
  fill.matrix = value.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value, defaultStyle) {
  const style = { ...defaultStyle, ...value };
  if (style.texture) {
    if (style.texture !== Texture.WHITE) {
      const m4 = style.matrix?.invert() || new Matrix();
      m4.translate(style.texture.frame.x, style.texture.frame.y);
      m4.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
      style.matrix = m4;
    }
    const sourceStyle = style.texture.source.style;
    if (sourceStyle.addressMode === "clamp-to-edge") {
      sourceStyle.addressMode = "repeat";
      sourceStyle.update();
    }
  }
  const color2 = Color.shared.setValue(style.color);
  style.alpha *= color2.alpha;
  style.color = color2.toNumber();
  style.matrix = style.matrix ? style.matrix.clone() : null;
  return style;
}
function toFillStyle(value, defaultStyle) {
  if (value === void 0 || value === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value;
  if (isColorLike(value)) {
    return handleColorLike(fill, value, defaultStyle);
  } else if (isFillPattern(value)) {
    return handleFillPattern(fill, value, defaultStyle);
  } else if (isFillGradient(value)) {
    return handleFillGradient(fill, value, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;
  const fill = toFillStyle(value, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    ...fill
  };
}
var init_convertFillInputToFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/utils/convertFillInputToFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_FillGradient();
    init_FillPattern();
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs
var tmpPoint, tempMatrix3, _GraphicsContext, GraphicsContext;
var init_GraphicsContext = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/GraphicsContext.mjs"() {
    init_eventemitter3();
    init_Color();
    init_Matrix();
    init_Point();
    init_Texture();
    init_uid();
    init_deprecation();
    init_Bounds();
    init_GraphicsPath();
    init_SVGParser();
    init_convertFillInputToFillStyle();
    tmpPoint = new Point();
    tempMatrix3 = new Matrix();
    _GraphicsContext = class _GraphicsContext2 extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.uid = uid("graphicsContext");
        this.dirty = true;
        this.batchMode = "auto";
        this.instructions = [];
        this._activePath = new GraphicsPath();
        this._transform = new Matrix();
        this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
        this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
        this._stateStack = [];
        this._tick = 0;
        this._bounds = new Bounds();
        this._boundsDirty = true;
      }
      /**
       * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
       * including the current drawing state, transformations, styles, and instructions.
       * @returns A new GraphicsContext instance with the same properties and state as this one.
       */
      clone() {
        const clone = new _GraphicsContext2();
        clone.batchMode = this.batchMode;
        clone.instructions = this.instructions.slice();
        clone._activePath = this._activePath.clone();
        clone._transform = this._transform.clone();
        clone._fillStyle = { ...this._fillStyle };
        clone._strokeStyle = { ...this._strokeStyle };
        clone._stateStack = this._stateStack.slice();
        clone._bounds = this._bounds.clone();
        clone._boundsDirty = true;
        return clone;
      }
      /**
       * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
       */
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(value) {
        this._fillStyle = toFillStyle(value, _GraphicsContext2.defaultFillStyle);
      }
      /**
       * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       */
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(value) {
        this._strokeStyle = toStrokeStyle(value, _GraphicsContext2.defaultStrokeStyle);
      }
      /**
       * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
       * pattern, or a more complex style defined by a FillStyle object.
       * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
       *                or a FillStyle or ConvertedFillStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setFillStyle(style) {
        this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        return this;
      }
      /**
       * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
       * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
       *                or a StrokeStyle or ConvertedStrokeStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setStrokeStyle(style) {
        this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
        return this;
      }
      texture(texture, tint, dx, dy, dw, dh) {
        this.instructions.push({
          action: "texture",
          data: {
            image: texture,
            dx: dx || 0,
            dy: dy || 0,
            dw: dw || texture.frame.width,
            dh: dh || texture.frame.height,
            transform: this._transform.clone(),
            alpha: this._fillStyle.alpha,
            style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
          }
        });
        this.onUpdate();
        return this;
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      beginPath() {
        this._activePath = new GraphicsPath();
        return this;
      }
      fill(style, alpha) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "stroke") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          if (alpha !== void 0 && typeof style === "number") {
            deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
            style = { color: style, alpha };
          }
          this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
        }
        this.instructions.push({
          action: "fill",
          // TODO copy fill style!
          data: { style: this.fillStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      _initNextPathLocation() {
        const { x: x5, y: y4 } = this._activePath.getLastPoint(Point.shared);
        this._activePath.clear();
        this._activePath.moveTo(x5, y4);
      }
      /**
       * Strokes the current path with the current stroke style. This method can take an optional
       * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
       * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      stroke(style) {
        let path2;
        const lastInstruction = this.instructions[this.instructions.length - 1];
        if (this._tick === 0 && lastInstruction && lastInstruction.action === "fill") {
          path2 = lastInstruction.data.path;
        } else {
          path2 = this._activePath.clone();
        }
        if (!path2)
          return this;
        if (style != null) {
          this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
        }
        this.instructions.push({
          action: "stroke",
          // TODO copy fill style!
          data: { style: this.strokeStyle, path: path2 }
        });
        this.onUpdate();
        this._initNextPathLocation();
        this._tick = 0;
        return this;
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
       * fail to cut correctly!
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      cut() {
        for (let i2 = 0; i2 < 2; i2++) {
          const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
          const holePath = this._activePath.clone();
          if (lastInstruction) {
            if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
              if (lastInstruction.data.hole) {
                lastInstruction.data.hole.addPath(holePath);
              } else {
                lastInstruction.data.hole = holePath;
                break;
              }
            }
          }
        }
        this._initNextPathLocation();
        return this;
      }
      /**
       * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
       * starting and ending angles, and direction.
       * @param x - The x-coordinate of the arc's center.
       * @param y - The y-coordinate of the arc's center.
       * @param radius - The arc's radius.
       * @param startAngle - The starting angle, in radians.
       * @param endAngle - The ending angle, in radians.
       * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arc(x5, y4, radius, startAngle, endAngle, counterclockwise) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arc(
          t2.a * x5 + t2.c * y4 + t2.tx,
          t2.b * x5 + t2.d * y4 + t2.ty,
          radius,
          startAngle,
          endAngle,
          counterclockwise
        );
        return this;
      }
      /**
       * Adds an arc to the current path with the given control points and radius, connected to the previous point
       * by a straight line if necessary.
       * @param x1 - The x-coordinate of the first control point.
       * @param y1 - The y-coordinate of the first control point.
       * @param x2 - The x-coordinate of the second control point.
       * @param y2 - The y-coordinate of the second control point.
       * @param radius - The arc's radius.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      arcTo(x1, y1, x22, y22, radius) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcTo(
          t2.a * x1 + t2.c * y1 + t2.tx,
          t2.b * x1 + t2.d * y1 + t2.ty,
          t2.a * x22 + t2.c * y22 + t2.tx,
          t2.b * x22 + t2.d * y22 + t2.ty,
          radius
        );
        return this;
      }
      /**
       * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
       * @param rx - The x-radius of the ellipse.
       * @param ry - The y-radius of the ellipse.
       * @param xAxisRotation - The rotation of the ellipse's x-axis relative
       * to the x-axis of the coordinate system, in degrees.
       * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
       * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
       * @param x - The x-coordinate of the arc's end point.
       * @param y - The y-coordinate of the arc's end point.
       * @returns The instance of the current object for chaining.
       */
      arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x5, y4) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.arcToSvg(
          rx,
          ry,
          xAxisRotation,
          // should we rotate this with transform??
          largeArcFlag,
          sweepFlag,
          t2.a * x5 + t2.c * y4 + t2.tx,
          t2.b * x5 + t2.d * y4 + t2.ty
        );
        return this;
      }
      /**
       * Adds a cubic Bezier curve to the path.
       * It requires three points: the first two are control points and the third one is the end point.
       * The starting point is the last point in the current path.
       * @param cp1x - The x-coordinate of the first control point.
       * @param cp1y - The y-coordinate of the first control point.
       * @param cp2x - The x-coordinate of the second control point.
       * @param cp2y - The y-coordinate of the second control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x5, y4, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.bezierCurveTo(
          t2.a * cp1x + t2.c * cp1y + t2.tx,
          t2.b * cp1x + t2.d * cp1y + t2.ty,
          t2.a * cp2x + t2.c * cp2y + t2.tx,
          t2.b * cp2x + t2.d * cp2y + t2.ty,
          t2.a * x5 + t2.c * y4 + t2.tx,
          t2.b * x5 + t2.d * y4 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        this._tick++;
        this._activePath?.closePath();
        return this;
      }
      /**
       * Draws an ellipse at the specified location and with the given x and y radii.
       * An optional transformation can be applied, allowing for rotation, scaling, and translation.
       * @param x - The x-coordinate of the center of the ellipse.
       * @param y - The y-coordinate of the center of the ellipse.
       * @param radiusX - The horizontal radius of the ellipse.
       * @param radiusY - The vertical radius of the ellipse.
       * @returns The instance of the current object for chaining.
       */
      ellipse(x5, y4, radiusX, radiusY) {
        this._tick++;
        this._activePath.ellipse(x5, y4, radiusX, radiusY, this._transform.clone());
        return this;
      }
      /**
       * Draws a circle shape. This method adds a new circle path to the current drawing.
       * @param x - The x-coordinate of the center of the circle.
       * @param y - The y-coordinate of the center of the circle.
       * @param radius - The radius of the circle.
       * @returns The instance of the current object for chaining.
       */
      circle(x5, y4, radius) {
        this._tick++;
        this._activePath.circle(x5, y4, radius, this._transform.clone());
        return this;
      }
      /**
       * Adds another `GraphicsPath` to this path, optionally applying a transformation.
       * @param path - The `GraphicsPath` to add.
       * @returns The instance of the current object for chaining.
       */
      path(path2) {
        this._tick++;
        this._activePath.addPath(path2, this._transform.clone());
        return this;
      }
      /**
       * Connects the current point to a new point with a straight line. This method updates the current path.
       * @param x - The x-coordinate of the new point to connect to.
       * @param y - The y-coordinate of the new point to connect to.
       * @returns The instance of the current object for chaining.
       */
      lineTo(x5, y4) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.lineTo(
          t2.a * x5 + t2.c * y4 + t2.tx,
          t2.b * x5 + t2.d * y4 + t2.ty
        );
        return this;
      }
      /**
       * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
       * @param x - The x-coordinate for the starting point.
       * @param y - The y-coordinate for the starting point.
       * @returns The instance of the current object for chaining.
       */
      moveTo(x5, y4) {
        this._tick++;
        const t2 = this._transform;
        const instructions = this._activePath.instructions;
        const transformedX = t2.a * x5 + t2.c * y4 + t2.tx;
        const transformedY = t2.b * x5 + t2.d * y4 + t2.ty;
        if (instructions.length === 1 && instructions[0].action === "moveTo") {
          instructions[0].data[0] = transformedX;
          instructions[0].data[1] = transformedY;
          return this;
        }
        this._activePath.moveTo(
          transformedX,
          transformedY
        );
        return this;
      }
      /**
       * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
       * The starting point is the last point in the current path.
       * @param cpx - The x-coordinate of the control point.
       * @param cpy - The y-coordinate of the control point.
       * @param x - The x-coordinate of the end point.
       * @param y - The y-coordinate of the end point.
       * @param smoothness - Optional parameter to adjust the smoothness of the curve.
       * @returns The instance of the current object for chaining.
       */
      quadraticCurveTo(cpx, cpy, x5, y4, smoothness) {
        this._tick++;
        const t2 = this._transform;
        this._activePath.quadraticCurveTo(
          t2.a * cpx + t2.c * cpy + t2.tx,
          t2.b * cpx + t2.d * cpy + t2.ty,
          t2.a * x5 + t2.c * y4 + t2.tx,
          t2.b * x5 + t2.d * y4 + t2.ty,
          smoothness
        );
        return this;
      }
      /**
       * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @returns The instance of the current object for chaining.
       */
      rect(x5, y4, w2, h2) {
        this._tick++;
        this._activePath.rect(x5, y4, w2, h2, this._transform.clone());
        return this;
      }
      /**
       * Draws a rectangle with rounded corners.
       * The corner radius can be specified to determine how rounded the corners should be.
       * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
       * @param x - The x-coordinate of the top-left corner of the rectangle.
       * @param y - The y-coordinate of the top-left corner of the rectangle.
       * @param w - The width of the rectangle.
       * @param h - The height of the rectangle.
       * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
       * @returns The instance of the current object for chaining.
       */
      roundRect(x5, y4, w2, h2, radius) {
        this._tick++;
        this._activePath.roundRect(x5, y4, w2, h2, radius, this._transform.clone());
        return this;
      }
      /**
       * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
       * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
       * rotated, or translated as needed.
       * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
       * representing the x and y coordinates, of the polygon's vertices, in sequence.
       * @param close - A boolean indicating whether to close the polygon path. True by default.
       */
      poly(points, close) {
        this._tick++;
        this._activePath.poly(points, close, this._transform.clone());
        return this;
      }
      /**
       * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
       * @returns The instance of the current object for chaining.
       */
      regularPoly(x5, y4, radius, sides, rotation = 0, transform4) {
        this._tick++;
        this._activePath.regularPoly(x5, y4, radius, sides, rotation, transform4);
        return this;
      }
      /**
       * Draws a polygon with rounded corners.
       * Similar to `regularPoly` but with the ability to round the corners of the polygon.
       * @param x - The x-coordinate of the center of the polygon.
       * @param y - The y-coordinate of the center of the polygon.
       * @param radius - The radius of the circumscribed circle of the polygon.
       * @param sides - The number of sides of the polygon. Must be 3 or more.
       * @param corner - The radius of the rounding of the corners.
       * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
       * @returns The instance of the current object for chaining.
       */
      roundPoly(x5, y4, radius, sides, corner, rotation) {
        this._tick++;
        this._activePath.roundPoly(x5, y4, radius, sides, corner, rotation);
        return this;
      }
      /**
       * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
       * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
       * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
       * A minimum of 3 points is required.
       * @param radius - The default radius for the corners.
       * This radius is applied to all corners unless overridden in `points`.
       * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
       *  method instead of an arc method. Defaults to false.
       * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
       * Higher values make the curve smoother.
       * @returns The instance of the current object for chaining.
       */
      roundShape(points, radius, useQuadratic, smoothness) {
        this._tick++;
        this._activePath.roundShape(points, radius, useQuadratic, smoothness);
        return this;
      }
      /**
       * Draw Rectangle with fillet corners. This is much like rounded rectangle
       * however it support negative numbers as well for the corner radius.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param fillet - accept negative or positive values
       */
      filletRect(x5, y4, width, height, fillet) {
        this._tick++;
        this._activePath.filletRect(x5, y4, width, height, fillet);
        return this;
      }
      /**
       * Draw Rectangle with chamfer corners. These are angled corners.
       * @param x - Upper left corner of rect
       * @param y - Upper right corner of rect
       * @param width - Width of rect
       * @param height - Height of rect
       * @param chamfer - non-zero real number, size of corner cutout
       * @param transform
       */
      chamferRect(x5, y4, width, height, chamfer, transform4) {
        this._tick++;
        this._activePath.chamferRect(x5, y4, width, height, chamfer, transform4);
        return this;
      }
      /**
       * Draws a star shape centered at a specified location. This method allows for the creation
       *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
       * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
       * An optional transformation can be applied to scale, rotate, or translate the star as needed.
       * @param x - The x-coordinate of the center of the star.
       * @param y - The y-coordinate of the center of the star.
       * @param points - The number of points of the star.
       * @param radius - The outer radius of the star (distance from the center to the outer points).
       * @param innerRadius - Optional. The inner radius of the star
       * (distance from the center to the inner points between the outer points).
       * If not provided, defaults to half of the `radius`.
       * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
       * Defaults to 0, meaning one point is directly upward.
       * @returns The instance of the current object for chaining further drawing commands.
       */
      star(x5, y4, points, radius, innerRadius = 0, rotation = 0) {
        this._tick++;
        this._activePath.star(x5, y4, points, radius, innerRadius, rotation, this._transform.clone());
        return this;
      }
      /**
       * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
       * defined in SVG format to be drawn within the graphics context.
       * @param svg - The SVG string to be parsed and rendered.
       */
      svg(svg) {
        this._tick++;
        SVGParser(svg, this);
        return this;
      }
      /**
       * Restores the most recently saved graphics state by popping the top of the graphics state stack.
       * This includes transformations, fill styles, and stroke styles.
       */
      restore() {
        const state = this._stateStack.pop();
        if (state) {
          this._transform = state.transform;
          this._fillStyle = state.fillStyle;
          this._strokeStyle = state.strokeStyle;
        }
        return this;
      }
      /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
      save() {
        this._stateStack.push({
          transform: this._transform.clone(),
          fillStyle: { ...this._fillStyle },
          strokeStyle: { ...this._strokeStyle }
        });
        return this;
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * @returns The current transformation matrix.
       */
      getTransform() {
        return this._transform;
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      resetTransform() {
        this._transform.identity();
        return this;
      }
      /**
       * Applies a rotation transformation to the graphics context around the current origin.
       * @param angle - The angle of rotation in radians.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      rotate(angle) {
        this._transform.rotate(angle);
        return this;
      }
      /**
       * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
       * @param x - The scale factor in the horizontal direction.
       * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      scale(x5, y4 = x5) {
        this._transform.scale(x5, y4);
        return this;
      }
      setTransform(a3, b2, c3, d3, dx, dy) {
        if (a3 instanceof Matrix) {
          this._transform.set(a3.a, a3.b, a3.c, a3.d, a3.tx, a3.ty);
          return this;
        }
        this._transform.set(a3, b2, c3, d3, dx, dy);
        return this;
      }
      transform(a3, b2, c3, d3, dx, dy) {
        if (a3 instanceof Matrix) {
          this._transform.append(a3);
          return this;
        }
        tempMatrix3.set(a3, b2, c3, d3, dx, dy);
        this._transform.append(tempMatrix3);
        return this;
      }
      /**
       * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
       * @param x - The amount to translate in the horizontal direction.
       * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      translate(x5, y4 = x5) {
        this._transform.translate(x5, y4);
        return this;
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
       * and optionally resetting transformations to the identity matrix.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      clear() {
        this._activePath.clear();
        this.instructions.length = 0;
        this.resetTransform();
        this.onUpdate();
        return this;
      }
      onUpdate() {
        if (this.dirty)
          return;
        this.emit("update", this, 16);
        this.dirty = true;
        this._boundsDirty = true;
      }
      /** The bounds of the graphic shape. */
      get bounds() {
        if (!this._boundsDirty)
          return this._bounds;
        const bounds = this._bounds;
        bounds.clear();
        for (let i2 = 0; i2 < this.instructions.length; i2++) {
          const instruction = this.instructions[i2];
          const action = instruction.action;
          if (action === "fill") {
            const data = instruction.data;
            bounds.addBounds(data.path.bounds);
          } else if (action === "texture") {
            const data = instruction.data;
            bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
          }
          if (action === "stroke") {
            const data = instruction.data;
            const padding = data.style.width / 2;
            const _bounds = data.path.bounds;
            bounds.addFrame(
              _bounds.minX - padding,
              _bounds.minY - padding,
              _bounds.maxX + padding,
              _bounds.maxY + padding
            );
          }
        }
        return bounds;
      }
      /**
       * Check to see if a point is contained within this geometry.
       * @param point - Point to check if it's contained.
       * @returns {boolean} `true` if the point is contained within geometry.
       */
      containsPoint(point) {
        if (!this.bounds.containsPoint(point.x, point.y))
          return false;
        const instructions = this.instructions;
        let hasHit = false;
        for (let k3 = 0; k3 < instructions.length; k3++) {
          const instruction = instructions[k3];
          const data = instruction.data;
          const path2 = data.path;
          if (!instruction.action || !path2)
            continue;
          const style = data.style;
          const shapes = path2.shapePath.shapePrimitives;
          for (let i2 = 0; i2 < shapes.length; i2++) {
            const shape = shapes[i2].shape;
            if (!style || !shape)
              continue;
            const transform4 = shapes[i2].transform;
            const transformedPoint = transform4 ? transform4.applyInverse(point, tmpPoint) : point;
            if (instruction.action === "fill") {
              hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
            } else {
              hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, style.width);
            }
            const holes = data.hole;
            if (holes) {
              const holeShapes = holes.shapePath?.shapePrimitives;
              if (holeShapes) {
                for (let j3 = 0; j3 < holeShapes.length; j3++) {
                  if (holeShapes[j3].shape.contains(transformedPoint.x, transformedPoint.y)) {
                    hasHit = false;
                  }
                }
              }
            }
            if (hasHit) {
              return true;
            }
          }
        }
        return hasHit;
      }
      /**
       * Destroys the GraphicsData object.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the current texture of the fill/stroke style?
       * @param {boolean} [options.textureSource=false] - Should it destroy the texture source of the fill/stroke style?
       */
      destroy(options = false) {
        this._stateStack.length = 0;
        this._transform = null;
        this.emit("destroy", this);
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fillStyle.texture) {
            this._fillStyle.texture.destroy(destroyTextureSource);
          }
          if (this._strokeStyle.texture) {
            this._strokeStyle.texture.destroy(destroyTextureSource);
          }
        }
        this._fillStyle = null;
        this._strokeStyle = null;
        this.instructions = null;
        this._activePath = null;
        this._bounds = null;
        this._stateStack = null;
        this.customShader = null;
        this._transform = null;
      }
    };
    _GraphicsContext.defaultFillStyle = {
      /** The color to use for the fill. */
      color: 16777215,
      /** The alpha value to use for the fill. */
      alpha: 1,
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null
    };
    _GraphicsContext.defaultStrokeStyle = {
      /** The width of the stroke. */
      width: 1,
      /** The color to use for the stroke. */
      color: 16777215,
      /** The alpha value to use for the stroke. */
      alpha: 1,
      /** The alignment of the stroke. */
      alignment: 0.5,
      /** The miter limit to use. */
      miterLimit: 10,
      /** The line cap style to use. */
      cap: "butt",
      /** The line join style to use. */
      join: "miter",
      /** The texture to use for the fill. */
      texture: Texture.WHITE,
      /** The matrix to apply. */
      matrix: null,
      /** The fill pattern to use. */
      fill: null
    };
    GraphicsContext = _GraphicsContext;
  }
});

// node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs
function generateTextStyleKey(style) {
  const key = [];
  let index2 = 0;
  for (let i2 = 0; i2 < valuesToIterateForKeys.length; i2++) {
    const prop = `_${valuesToIterateForKeys[i2]}`;
    key[index2++] = style[prop];
  }
  index2 = addFillStyleKey(style._fill, key, index2);
  index2 = addStokeStyleKey(style._stroke, key, index2);
  index2 = addDropShadowKey(style.dropShadow, key, index2);
  return key.join("-");
}
function addFillStyleKey(fillStyle, key, index2) {
  if (!fillStyle)
    return index2;
  key[index2++] = fillStyle.color;
  key[index2++] = fillStyle.alpha;
  key[index2++] = fillStyle.fill?.styleKey;
  return index2;
}
function addStokeStyleKey(strokeStyle, key, index2) {
  if (!strokeStyle)
    return index2;
  index2 = addFillStyleKey(strokeStyle, key, index2);
  key[index2++] = strokeStyle.width;
  key[index2++] = strokeStyle.alignment;
  key[index2++] = strokeStyle.cap;
  key[index2++] = strokeStyle.join;
  key[index2++] = strokeStyle.miterLimit;
  return index2;
}
function addDropShadowKey(dropShadow, key, index2) {
  if (!dropShadow)
    return index2;
  key[index2++] = dropShadow.alpha;
  key[index2++] = dropShadow.angle;
  key[index2++] = dropShadow.blur;
  key[index2++] = dropShadow.distance;
  key[index2++] = Color.shared.setValue(dropShadow.color).toNumber();
  return index2;
}
var valuesToIterateForKeys;
var init_generateTextStyleKey = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/generateTextStyleKey.mjs"() {
    init_Color();
    valuesToIterateForKeys = [
      "align",
      "breakWords",
      "cssOverrides",
      "fontVariant",
      "fontWeight",
      "leading",
      "letterSpacing",
      "lineHeight",
      "padding",
      "textBaseline",
      "trim",
      "whiteSpace",
      "wordWrap",
      "wordWrapWidth",
      "fontFamily",
      "fontStyle",
      "fontSize"
    ];
  }
});

// node_modules/pixi.js/lib/scene/text/TextStyle.mjs
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== void 0) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color2 = oldStyle.stroke;
    let obj = {};
    if (Color.isColorLike(color2)) {
      obj.color = color2;
    } else if (color2 instanceof FillGradient || color2 instanceof FillPattern) {
      obj.fill = color2;
    } else if (Object.hasOwnProperty.call(color2, "color") || Object.hasOwnProperty.call(color2, "fill")) {
      obj = color2;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    let fontSize;
    if (style.fontSize == null) {
      style.fontSize = TextStyle.defaultTextStyle.fontSize;
    } else if (typeof style.fontSize === "string") {
      fontSize = parseInt(style.fontSize, 10);
    } else {
      fontSize = style.fontSize;
    }
    const gradientFill = new FillGradient(0, 0, 0, fontSize * 1.7);
    const fills = oldStyle.fillGradientStops.map((color2) => Color.shared.setValue(color2).toNumber());
    fills.forEach((number3, index2) => {
      const ratio = index2 / (fills.length - 1);
      gradientFill.addColorStop(ratio, number3);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
var _TextStyle, TextStyle;
var init_TextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/TextStyle.mjs"() {
    init_eventemitter3();
    init_Color();
    init_deprecation();
    init_FillGradient();
    init_FillPattern();
    init_GraphicsContext();
    init_convertFillInputToFillStyle();
    init_generateTextStyleKey();
    _TextStyle = class _TextStyle2 extends eventemitter3_default {
      constructor(style = {}) {
        super();
        convertV7Tov8Style(style);
        const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
        for (const key in fullStyle) {
          const thisKey = key;
          this[thisKey] = fullStyle[key];
        }
        this.update();
      }
      /**
       * Alignment for multiline text, does not affect single line text.
       * @member {'left'|'center'|'right'|'justify'}
       */
      get align() {
        return this._align;
      }
      set align(value) {
        this._align = value;
        this.update();
      }
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get breakWords() {
        return this._breakWords;
      }
      set breakWords(value) {
        this._breakWords = value;
        this.update();
      }
      /** Set a drop shadow for the text. */
      get dropShadow() {
        return this._dropShadow;
      }
      set dropShadow(value) {
        if (value !== null && typeof value === "object") {
          this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value });
        } else {
          this._dropShadow = value ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
        }
        this.update();
      }
      /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
      get fontFamily() {
        return this._fontFamily;
      }
      set fontFamily(value) {
        this._fontFamily = value;
        this.update();
      }
      /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
      get fontSize() {
        return this._fontSize;
      }
      set fontSize(value) {
        if (typeof value === "string") {
          this._fontSize = parseInt(value, 10);
        } else {
          this._fontSize = value;
        }
        this.update();
      }
      /**
       * The font style.
       * @member {'normal'|'italic'|'oblique'}
       */
      get fontStyle() {
        return this._fontStyle;
      }
      set fontStyle(value) {
        this._fontStyle = value;
        this.update();
      }
      /**
       * The font variant.
       * @member {'normal'|'small-caps'}
       */
      get fontVariant() {
        return this._fontVariant;
      }
      set fontVariant(value) {
        this._fontVariant = value;
        this.update();
      }
      /**
       * The font weight.
       * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      get fontWeight() {
        return this._fontWeight;
      }
      set fontWeight(value) {
        this._fontWeight = value;
        this.update();
      }
      /** The space between lines. */
      get leading() {
        return this._leading;
      }
      set leading(value) {
        this._leading = value;
        this.update();
      }
      /** The amount of spacing between letters, default is 0. */
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        this._letterSpacing = value;
        this.update();
      }
      /** The line height, a number that represents the vertical space that a letter uses. */
      get lineHeight() {
        return this._lineHeight;
      }
      set lineHeight(value) {
        this._lineHeight = value;
        this.update();
      }
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get padding() {
        return this._padding;
      }
      set padding(value) {
        this._padding = value;
        this.update();
      }
      /** Trim transparent borders. This is an expensive operation so only use this if you have to! */
      get trim() {
        return this._trim;
      }
      set trim(value) {
        this._trim = value;
        this.update();
      }
      /**
       * The baseline of the text that is rendered.
       * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      get textBaseline() {
        return this._textBaseline;
      }
      set textBaseline(value) {
        this._textBaseline = value;
        this.update();
      }
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       * @member {'normal'|'pre'|'pre-line'}
       */
      get whiteSpace() {
        return this._whiteSpace;
      }
      set whiteSpace(value) {
        this._whiteSpace = value;
        this.update();
      }
      /** Indicates if word wrap should be used. */
      get wordWrap() {
        return this._wordWrap;
      }
      set wordWrap(value) {
        this._wordWrap = value;
        this.update();
      }
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get wordWrapWidth() {
        return this._wordWrapWidth;
      }
      set wordWrapWidth(value) {
        this._wordWrapWidth = value;
        this.update();
      }
      /** A fillstyle that will be used on the text e.g., 'red', '#00FF00'. */
      get fill() {
        return this._originalFill;
      }
      set fill(value) {
        if (value === this._originalFill)
          return;
        this._originalFill = value;
        if (this._isFillStyle(value)) {
          this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () => {
            this._fill = toFillStyle(
              { ...this._originalFill },
              GraphicsContext.defaultFillStyle
            );
          });
        }
        this._fill = toFillStyle(
          value === 0 ? "black" : value,
          GraphicsContext.defaultFillStyle
        );
        this.update();
      }
      /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
      get stroke() {
        return this._originalStroke;
      }
      set stroke(value) {
        if (value === this._originalStroke)
          return;
        this._originalStroke = value;
        if (this._isFillStyle(value)) {
          this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () => {
            this._stroke = toStrokeStyle(
              { ...this._originalStroke },
              GraphicsContext.defaultStrokeStyle
            );
          });
        }
        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);
        this.update();
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this);
        return this._styleKey;
      }
      update() {
        this._styleKey = null;
        this.emit("update", this);
      }
      /** Resets all properties to the default values */
      reset() {
        const defaultStyle = _TextStyle2.defaultTextStyle;
        for (const key in defaultStyle) {
          this[key] = defaultStyle[key];
        }
      }
      get styleKey() {
        return this._styleKey || this._generateKey();
      }
      /**
       * Creates a new TextStyle object with the same values as this one.
       * @returns New cloned TextStyle object
       */
      clone() {
        return new _TextStyle2({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          leading: this.leading,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          textBaseline: this.textBaseline,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth
        });
      }
      /**
       * Destroys this text style.
       * @param options - Options parameter. A boolean will act as if all options
       *  have been set to that value
       * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style
       * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style
       */
      destroy(options = false) {
        this.removeAllListeners();
        const destroyTexture = typeof options === "boolean" ? options : options?.texture;
        if (destroyTexture) {
          const destroyTextureSource = typeof options === "boolean" ? options : options?.textureSource;
          if (this._fill?.texture) {
            this._fill.texture.destroy(destroyTextureSource);
          }
          if (this._originalFill?.texture) {
            this._originalFill.texture.destroy(destroyTextureSource);
          }
          if (this._stroke?.texture) {
            this._stroke.texture.destroy(destroyTextureSource);
          }
          if (this._originalStroke?.texture) {
            this._originalStroke.texture.destroy(destroyTextureSource);
          }
        }
        this._fill = null;
        this._stroke = null;
        this.dropShadow = null;
        this._originalStroke = null;
        this._originalFill = null;
      }
      _createProxy(value, cb) {
        return new Proxy(value, {
          set: (target, property2, newValue) => {
            target[property2] = newValue;
            cb?.(property2, newValue);
            this.update();
            return true;
          }
        });
      }
      _isFillStyle(value) {
        return (value ?? null) !== null && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern);
      }
    };
    _TextStyle.defaultDropShadow = {
      /** Set alpha for the drop shadow */
      alpha: 1,
      /** Set a angle of the drop shadow */
      angle: Math.PI / 6,
      /** Set a shadow blur radius */
      blur: 0,
      /** A fill style to be used on the  e.g., 'red', '#00FF00' */
      color: "black",
      /** Set a distance of the drop shadow */
      distance: 5
    };
    _TextStyle.defaultTextStyle = {
      /**
       * See {@link TextStyle.align}
       * @type {'left'|'center'|'right'|'justify'}
       */
      align: "left",
      /** See {@link TextStyle.breakWords} */
      breakWords: false,
      /** See {@link TextStyle.dropShadow} */
      dropShadow: null,
      /**
       * See {@link TextStyle.fill}
       * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      fill: "black",
      /**
       * See {@link TextStyle.fontFamily}
       * @type {string|string[]}
       */
      fontFamily: "Arial",
      /**
       * See {@link TextStyle.fontSize}
       * @type {number|string}
       */
      fontSize: 26,
      /**
       * See {@link TextStyle.fontStyle}
       * @type {'normal'|'italic'|'oblique'}
       */
      fontStyle: "normal",
      /**
       * See {@link TextStyle.fontVariant}
       * @type {'normal'|'small-caps'}
       */
      fontVariant: "normal",
      /**
       * See {@link TextStyle.fontWeight}
       * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
       */
      fontWeight: "normal",
      /** See {@link TextStyle.leading} */
      leading: 0,
      /** See {@link TextStyle.letterSpacing} */
      letterSpacing: 0,
      /** See {@link TextStyle.lineHeight} */
      lineHeight: 0,
      /** See {@link TextStyle.padding} */
      padding: 0,
      /**
       * See {@link TextStyle.stroke}
       * @type {string|number}
       */
      stroke: null,
      /**
       * See {@link TextStyle.textBaseline}
       * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
       */
      textBaseline: "alphabetic",
      /** See {@link TextStyle.trim} */
      trim: false,
      /**
       * See {@link TextStyle.whiteSpace}
       * @type {'normal'|'pre'|'pre-line'}
       */
      whiteSpace: "pre",
      /** See {@link TextStyle.wordWrap} */
      wordWrap: false,
      /** See {@link TextStyle.wordWrapWidth} */
      wordWrapWidth: 100
    };
    TextStyle = _TextStyle;
  }
});

// node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs
function getPo2TextureFromSource(image, width, height, resolution) {
  const bounds = tempBounds2;
  bounds.minX = 0;
  bounds.minY = 0;
  bounds.maxX = image.width / resolution | 0;
  bounds.maxY = image.height / resolution | 0;
  const texture = TexturePool.getOptimalTexture(
    bounds.width,
    bounds.height,
    resolution,
    false
  );
  texture.source.uploadMethodId = "image";
  texture.source.resource = image;
  texture.source.alphaMode = "premultiply-alpha-on-upload";
  texture.frame.width = width / resolution;
  texture.frame.height = height / resolution;
  texture.source.emit("update", texture.source);
  texture.updateUvs();
  return texture;
}
var tempBounds2;
var init_getPo2TextureFromSource = __esm({
  "node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs"() {
    init_TexturePool();
    init_Bounds();
    tempBounds2 = new Bounds();
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    let fontFamily = fontFamilies[i2].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i2] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
var genericFontFamilies;
var init_fontStringFromTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/fontStringFromTextStyle.mjs"() {
    "use strict";
    genericFontFamilies = [
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui"
    ];
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs
var contextSettings, _CanvasTextMetrics, CanvasTextMetrics;
var init_CanvasTextMetrics = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextMetrics.mjs"() {
    init_adapter();
    init_fontStringFromTextStyle();
    contextSettings = {
      // TextMetrics requires getImageData readback for measuring fonts.
      willReadFrequently: true
    };
    _CanvasTextMetrics = class _CanvasTextMetrics2 {
      /**
       * Checking that we can use modern canvas 2D API.
       *
       * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
       * @see TextMetrics.experimentalLetterSpacing
       * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
       * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
       */
      static get experimentalLetterSpacingSupported() {
        let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
        if (result !== void 0) {
          const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
          result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
        }
        return result;
      }
      /**
       * @param text - the text that was measured
       * @param style - the style that was measured
       * @param width - the measured width of the text
       * @param height - the measured height of the text
       * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
       * @param lineWidths - an array of the line widths for each line matched to `lines`
       * @param lineHeight - the measured line height for this style
       * @param maxLineWidth - the maximum line width for all measured lines
       * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
       */
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      /**
       * Measures the supplied string of text and returns a Rectangle.
       * @param text - The text to measure.
       * @param style - The text style to use for measuring
       * @param canvas - optional specification of the canvas to use for measuring.
       * @param wordWrap
       * @returns Measured width and height of the text.
       */
      static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
        const textKey = `${text}:${style.styleKey}`;
        if (_CanvasTextMetrics2._measurementCache[textKey])
          return _CanvasTextMetrics2._measurementCache[textKey];
        const font = fontStringFromTextStyle(style);
        const fontProperties = _CanvasTextMetrics2.measureFont(font);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = style.fontSize;
          fontProperties.ascent = style.fontSize;
        }
        const context2 = _CanvasTextMetrics2.__context;
        context2.font = font;
        const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
        const lines = outputText.split(/(?:\r\n|\r|\n)/);
        const lineWidths = new Array(lines.length);
        let maxLineWidth = 0;
        for (let i2 = 0; i2 < lines.length; i2++) {
          const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context2);
          lineWidths[i2] = lineWidth;
          maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        const strokeWidth = style._stroke?.width || 0;
        let width = maxLineWidth + strokeWidth;
        if (style.dropShadow) {
          width += style.dropShadow.distance;
        }
        const lineHeight = style.lineHeight || fontProperties.fontSize;
        let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
        if (style.dropShadow) {
          height += style.dropShadow.distance;
        }
        const measurements = new _CanvasTextMetrics2(
          text,
          style,
          width,
          height,
          lines,
          lineWidths,
          lineHeight + style.leading,
          maxLineWidth,
          fontProperties
        );
        return measurements;
      }
      static _measureText(text, letterSpacing, context2) {
        let useExperimentalLetterSpacing = false;
        if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
          if (_CanvasTextMetrics2.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        let width = context2.measureText(text).width;
        if (width > 0) {
          if (useExperimentalLetterSpacing) {
            width -= letterSpacing;
          } else {
            width += (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
          }
        }
        return width;
      }
      /**
       * Applies newlines to a string to have it optimally fit into the horizontal
       * bounds set by the Text object's wordWrapWidth property.
       * @param text - String to apply word wrapping to
       * @param style - the style to use when wrapping
       * @param canvas - optional specification of the canvas to use for measuring.
       * @returns New string with new lines applied where required
       */
      static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
        const context2 = canvas.getContext("2d", contextSettings);
        let width = 0;
        let line = "";
        let lines = "";
        const cache = /* @__PURE__ */ Object.create(null);
        const { letterSpacing, whiteSpace } = style;
        const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
        const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        const tokens = _CanvasTextMetrics2._tokenize(text);
        for (let i2 = 0; i2 < tokens.length; i2++) {
          let token = tokens[i2];
          if (_CanvasTextMetrics2._isNewline(token)) {
            if (!collapseNewlines) {
              lines += _CanvasTextMetrics2._addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
            const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context2);
          if (tokenWidth > wordWrapWidth) {
            if (line !== "") {
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
              const characters = _CanvasTextMetrics2.wordWrapSplit(token);
              for (let j3 = 0; j3 < characters.length; j3++) {
                let char = characters[j3];
                let lastChar = char;
                let k3 = 1;
                while (characters[j3 + k3]) {
                  const nextChar = characters[j3 + k3];
                  if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j3, style.breakWords)) {
                    char += nextChar;
                  } else {
                    break;
                  }
                  lastChar = nextChar;
                  k3++;
                }
                j3 += k3 - 1;
                const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context2);
                if (characterWidth + width > wordWrapWidth) {
                  lines += _CanvasTextMetrics2._addLine(line);
                  canPrependSpaces = false;
                  line = "";
                  width = 0;
                }
                line += char;
                width += characterWidth;
              }
            } else {
              if (line.length > 0) {
                lines += _CanvasTextMetrics2._addLine(line);
                line = "";
                width = 0;
              }
              const isLastToken = i2 === tokens.length - 1;
              lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
          } else {
            if (tokenWidth + width > wordWrapWidth) {
              canPrependSpaces = false;
              lines += _CanvasTextMetrics2._addLine(line);
              line = "";
              width = 0;
            }
            if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
              line += token;
              width += tokenWidth;
            }
          }
        }
        lines += _CanvasTextMetrics2._addLine(line, false);
        return lines;
      }
      /**
       * Convenience function for logging each line added during the wordWrap method.
       * @param line    - The line of text to add
       * @param newLine - Add new line character to end
       * @returns A formatted line
       */
      static _addLine(line, newLine = true) {
        line = _CanvasTextMetrics2._trimRight(line);
        line = newLine ? `${line}
` : line;
        return line;
      }
      /**
       * Gets & sets the widths of calculated characters in a cache object
       * @param key            - The key
       * @param letterSpacing  - The letter spacing
       * @param cache          - The cache
       * @param context        - The canvas context
       * @returns The from cache.
       */
      static _getFromCache(key, letterSpacing, cache, context2) {
        let width = cache[key];
        if (typeof width !== "number") {
          width = _CanvasTextMetrics2._measureText(key, letterSpacing, context2) + letterSpacing;
          cache[key] = width;
        }
        return width;
      }
      /**
       * Determines whether we should collapse breaking spaces.
       * @param whiteSpace - The TextStyle property whiteSpace
       * @returns Should collapse
       */
      static _collapseSpaces(whiteSpace) {
        return whiteSpace === "normal" || whiteSpace === "pre-line";
      }
      /**
       * Determines whether we should collapse newLine chars.
       * @param whiteSpace - The white space
       * @returns should collapse
       */
      static _collapseNewlines(whiteSpace) {
        return whiteSpace === "normal";
      }
      /**
       * Trims breaking whitespaces from string.
       * @param text - The text
       * @returns Trimmed string
       */
      static _trimRight(text) {
        if (typeof text !== "string") {
          return "";
        }
        for (let i2 = text.length - 1; i2 >= 0; i2--) {
          const char = text[i2];
          if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
            break;
          }
          text = text.slice(0, -1);
        }
        return text;
      }
      /**
       * Determines if char is a newline.
       * @param char - The character
       * @returns True if newline, False otherwise.
       */
      static _isNewline(char) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
      }
      /**
       * Determines if char is a breaking whitespace.
       *
       * It allows one to determine whether char should be a breaking whitespace
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param char - The character
       * @param [_nextChar] - The next character
       * @returns True if whitespace, False otherwise.
       */
      static isBreakingSpace(char, _nextChar) {
        if (typeof char !== "string") {
          return false;
        }
        return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
      }
      /**
       * Splits a string into words, breaking-spaces and newLine characters
       * @param text - The text
       * @returns A tokenized array
       */
      static _tokenize(text) {
        const tokens = [];
        let token = "";
        if (typeof text !== "string") {
          return tokens;
        }
        for (let i2 = 0; i2 < text.length; i2++) {
          const char = text[i2];
          const nextChar = text[i2 + 1];
          if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
            if (token !== "") {
              tokens.push(token);
              token = "";
            }
            tokens.push(char);
            continue;
          }
          token += char;
        }
        if (token !== "") {
          tokens.push(token);
        }
        return tokens;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to customise which words should break
       * Examples are if the token is CJK or numbers.
       * It must return a boolean.
       * @param _token - The token
       * @param breakWords - The style attr break words
       * @returns Whether to break word or not
       */
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It allows one to determine whether a pair of characters
       * should be broken by newlines
       * For example certain characters in CJK langs or numbers.
       * It must return a boolean.
       * @param _char - The character
       * @param _nextChar - The next character
       * @param _token - The token/word the characters are from
       * @param _index - The index in the token of the char
       * @param _breakWords - The style attr break words
       * @returns whether to break word or not
       */
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return true;
      }
      /**
       * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
       *
       * It is called when a token (usually a word) has to be split into separate pieces
       * in order to determine the point to break a word.
       * It must return an array of characters.
       * @param token - The token to split
       * @returns The characters of the token
       * @see CanvasTextMetrics.graphemeSegmenter
       */
      static wordWrapSplit(token) {
        return _CanvasTextMetrics2.graphemeSegmenter(token);
      }
      /**
       * Calculates the ascent, descent and fontSize of a given font-style
       * @param font - String representing the style of the font
       * @returns Font properties object
       */
      static measureFont(font) {
        if (_CanvasTextMetrics2._fonts[font]) {
          return _CanvasTextMetrics2._fonts[font];
        }
        const context2 = _CanvasTextMetrics2._context;
        context2.font = font;
        const metrics = context2.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
        const properties = {
          ascent: metrics.actualBoundingBoxAscent,
          descent: metrics.actualBoundingBoxDescent,
          fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
        };
        _CanvasTextMetrics2._fonts[font] = properties;
        return properties;
      }
      /**
       * Clear font metrics in metrics cache.
       * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
       */
      static clearMetrics(font = "") {
        if (font) {
          delete _CanvasTextMetrics2._fonts[font];
        } else {
          _CanvasTextMetrics2._fonts = {};
        }
      }
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _canvas() {
        if (!_CanvasTextMetrics2.__canvas) {
          let canvas;
          try {
            const c3 = new OffscreenCanvas(0, 0);
            const context2 = c3.getContext("2d", contextSettings);
            if (context2?.measureText) {
              _CanvasTextMetrics2.__canvas = c3;
              return c3;
            }
            canvas = DOMAdapter.get().createCanvas();
          } catch (ex) {
            canvas = DOMAdapter.get().createCanvas();
          }
          canvas.width = canvas.height = 10;
          _CanvasTextMetrics2.__canvas = canvas;
        }
        return _CanvasTextMetrics2.__canvas;
      }
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      static get _context() {
        if (!_CanvasTextMetrics2.__context) {
          _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
        }
        return _CanvasTextMetrics2.__context;
      }
    };
    _CanvasTextMetrics.METRICS_STRING = "|\xC9q\xC5";
    _CanvasTextMetrics.BASELINE_SYMBOL = "M";
    _CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
    _CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
    _CanvasTextMetrics.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter === "function") {
        const segmenter = new Intl.Segmenter();
        return (s2) => [...segmenter.segment(s2)].map((x5) => x5.segment);
      }
      return (s2) => [...s2];
    })();
    _CanvasTextMetrics.experimentalLetterSpacing = false;
    _CanvasTextMetrics._fonts = {};
    _CanvasTextMetrics._newlines = [
      10,
      // line feed
      13
      // carriage return
    ];
    _CanvasTextMetrics._breakingSpaces = [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ];
    _CanvasTextMetrics._measurementCache = {};
    CanvasTextMetrics = _CanvasTextMetrics;
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs
function getCanvasFillStyle(fillStyle, context2) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix6 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix6.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix6);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix6 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix6.scale(
      fillPattern.texture.frame.width,
      fillPattern.texture.frame.height
    );
    pattern.setTransform(tempMatrix6);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    if (fillGradient.type === "linear") {
      const gradient = context2.createLinearGradient(
        fillGradient.x0,
        fillGradient.y0,
        fillGradient.x1,
        fillGradient.y1
      );
      fillGradient.gradientStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
      return gradient;
    }
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
var init_getCanvasFillStyle = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/utils/getCanvasFillStyle.mjs"() {
    init_Color();
    init_Matrix();
    init_Texture();
    init_warn();
    init_FillGradient();
    init_FillPattern();
  }
});

// node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs
var CanvasTextSystem;
var init_CanvasTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_pow2();
    init_CanvasPool();
    init_TexturePool();
    init_getCanvasBoundingBox();
    init_deprecation();
    init_TextStyle();
    init_getPo2TextureFromSource();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    CanvasTextSystem = class {
      constructor(_renderer) {
        this._activeTextures = {};
        this._renderer = _renderer;
      }
      getTextureSize(text, resolution, style) {
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        let width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        let height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        width = Math.ceil(width - 1e-6);
        height = Math.ceil(height - 1e-6);
        width = nextPow2(width);
        height = nextPow2(height);
        return { width, height };
      }
      getTexture(options, resolution, style, _textKey) {
        if (typeof options === "string") {
          deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments");
          options = {
            text: options,
            style,
            resolution
          };
        }
        if (!(options.style instanceof TextStyle)) {
          options.style = new TextStyle(options.style);
        }
        const { texture, canvasAndContext } = this.createTextureAndCanvas(
          options
        );
        this._renderer.texture.initSource(texture._source);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return texture;
      }
      createTextureAndCanvas(options) {
        const { text, style } = options;
        const resolution = options.resolution ?? this._renderer.resolution;
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
        const { canvas } = canvasAndContext;
        this.renderTextToCanvas(text, style, resolution, canvasAndContext);
        const texture = getPo2TextureFromSource(canvas, width, height, resolution);
        if (style.trim) {
          const trimmed = getCanvasBoundingBox(canvas, resolution);
          texture.frame.copyFrom(trimmed);
          texture.updateUvs();
        }
        return { texture, canvasAndContext };
      }
      getManagedTexture(text) {
        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
        const textKey = text._getKey();
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].texture;
        }
        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);
        this._activeTextures[textKey] = {
          canvasAndContext,
          texture,
          usageCount: 1
        };
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);
          TexturePool.returnTexture(activeTexture.texture);
          const source2 = activeTexture.texture.source;
          source2.resource = null;
          source2.uploadMethodId = "unknown";
          source2.alphaMode = "no-premultiply-alpha";
          this._activeTextures[textKey] = null;
        }
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      /**
       * Renders text to its canvas, and updates its texture.
       *
       * By default this is used internally to ensure the texture is correct before rendering,
       * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,
       * and then shared across multiple Sprites.
       * @param text
       * @param style
       * @param resolution
       * @param canvasAndContext
       */
      renderTextToCanvas(text, style, resolution, canvasAndContext) {
        const { canvas, context: context2 } = canvasAndContext;
        const font = fontStringFromTextStyle(style);
        const measured = CanvasTextMetrics.measureText(text || " ", style);
        const lines = measured.lines;
        const lineHeight = measured.lineHeight;
        const lineWidths = measured.lineWidths;
        const maxLineWidth = measured.maxLineWidth;
        const fontProperties = measured.fontProperties;
        const height = canvas.height;
        context2.resetTransform();
        context2.scale(resolution, resolution);
        const padding = style.padding * 2;
        context2.clearRect(0, 0, measured.width + 4 + padding, measured.height + 4 + padding);
        if (style._stroke?.width) {
          const strokeStyle = style._stroke;
          context2.lineWidth = strokeStyle.width;
          context2.miterLimit = strokeStyle.miterLimit;
          context2.lineJoin = strokeStyle.join;
          context2.lineCap = strokeStyle.cap;
        }
        context2.font = font;
        let linePositionX;
        let linePositionY;
        const passesCount = style.dropShadow ? 2 : 1;
        for (let i2 = 0; i2 < passesCount; ++i2) {
          const isShadowPass = style.dropShadow && i2 === 0;
          const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + style.padding * 2) : 0;
          const dsOffsetShadow = dsOffsetText * resolution;
          if (isShadowPass) {
            context2.fillStyle = "black";
            context2.strokeStyle = "black";
            const shadowOptions = style.dropShadow;
            const dropShadowColor = shadowOptions.color;
            const dropShadowAlpha = shadowOptions.alpha;
            context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
            const dropShadowBlur = shadowOptions.blur * resolution;
            const dropShadowDistance = shadowOptions.distance * resolution;
            context2.shadowBlur = dropShadowBlur;
            context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
            context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
          } else {
            context2.globalAlpha = style._fill?.alpha ?? 1;
            context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2) : null;
            if (style._stroke?.width) {
              context2.strokeStyle = getCanvasFillStyle(style._stroke, context2);
            }
            context2.shadowColor = "black";
          }
          let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
          if (lineHeight - fontProperties.fontSize < 0) {
            linePositionYShift = 0;
          }
          const strokeWidth = style._stroke?.width ?? 0;
          for (let i22 = 0; i22 < lines.length; i22++) {
            linePositionX = strokeWidth / 2;
            linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
            if (style.align === "right") {
              linePositionX += maxLineWidth - lineWidths[i22];
            } else if (style.align === "center") {
              linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
            }
            if (style._stroke?.width) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText,
                true
              );
            }
            if (style._fill !== void 0) {
              this._drawLetterSpacing(
                lines[i22],
                style,
                canvasAndContext,
                linePositionX + style.padding,
                linePositionY + style.padding - dsOffsetText
              );
            }
          }
        }
      }
      /**
       * Render the text with letter-spacing.
       * @param text - The text to draw
       * @param style
       * @param canvasAndContext
       * @param x - Horizontal position to draw the text
       * @param y - Vertical position to draw the text
       * @param isStroke - Is this drawing for the outside stroke of the
       *  text? If not, it's for the inside fill
       */
      _drawLetterSpacing(text, style, canvasAndContext, x5, y4, isStroke = false) {
        const { context: context2 } = canvasAndContext;
        const letterSpacing = style.letterSpacing;
        let useExperimentalLetterSpacing = false;
        if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
          if (CanvasTextMetrics.experimentalLetterSpacing) {
            context2.letterSpacing = `${letterSpacing}px`;
            context2.textLetterSpacing = `${letterSpacing}px`;
            useExperimentalLetterSpacing = true;
          } else {
            context2.letterSpacing = "0px";
            context2.textLetterSpacing = "0px";
          }
        }
        if (letterSpacing === 0 || useExperimentalLetterSpacing) {
          if (isStroke) {
            context2.strokeText(text, x5, y4);
          } else {
            context2.fillText(text, x5, y4);
          }
          return;
        }
        let currentPosition = x5;
        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
        let previousWidth = context2.measureText(text).width;
        let currentWidth = 0;
        for (let i2 = 0; i2 < stringArray.length; ++i2) {
          const currentChar = stringArray[i2];
          if (isStroke) {
            context2.strokeText(currentChar, currentPosition, y4);
          } else {
            context2.fillText(currentChar, currentPosition, y4);
          }
          let textStr = "";
          for (let j3 = i2 + 1; j3 < stringArray.length; ++j3) {
            textStr += stringArray[j3];
          }
          currentWidth = context2.measureText(textStr).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    CanvasTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "canvasText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text/init.mjs
var init_init8 = __esm({
  "node_modules/pixi.js/lib/scene/text/init.mjs"() {
    init_Extensions();
    init_CanvasTextPipe();
    init_CanvasTextSystem();
    extensions.add(CanvasTextSystem);
    extensions.add(CanvasTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs
var Graphics;
var init_Graphics = __esm({
  "node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs"() {
    init_deprecation();
    init_View();
    init_GraphicsContext();
    Graphics = class _Graphics extends ViewContainer {
      /**
       * @param options - Options for the Graphics.
       */
      constructor(options) {
        if (options instanceof GraphicsContext) {
          options = { context: options };
        }
        const { context: context2, roundPixels, ...rest } = options || {};
        super({
          label: "Graphics",
          ...rest
        });
        this.renderPipeId = "graphics";
        if (!context2) {
          this._context = this._ownedContext = new GraphicsContext();
        } else {
          this._context = context2;
        }
        this._context.on("update", this.onViewUpdate, this);
        this.allowChildren = false;
        this.roundPixels = roundPixels ?? false;
      }
      set context(context2) {
        if (context2 === this._context)
          return;
        this._context.off("update", this.onViewUpdate, this);
        this._context = context2;
        this._context.on("update", this.onViewUpdate, this);
        this.onViewUpdate();
      }
      get context() {
        return this._context;
      }
      /**
       * The local bounds of the graphic.
       * @type {rendering.Bounds}
       */
      get bounds() {
        return this._context.bounds;
      }
      /**
       * Adds the bounds of this object to the bounds object.
       * @param bounds - The output bounds object.
       */
      addBounds(bounds) {
        bounds.addBounds(this._context.bounds);
      }
      /**
       * Checks if the object contains the given point.
       * @param point - The point to check
       */
      containsPoint(point) {
        return this._context.containsPoint(point);
      }
      onViewUpdate() {
        this._didViewChangeTick++;
        this._didGraphicsUpdate = true;
        if (this.didViewUpdate)
          return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
          renderGroup.onChildViewUpdate(this);
        }
      }
      /**
       * Destroys this graphics renderable and optionally its context.
       * @param options - Options parameter. A boolean will act as if all options
       *
       * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
       * then the context will still be destroyed.
       *
       * If you want to explicitly not destroy this context that this graphics created,
       * then you should pass destroy({ context: false })
       *
       * If the context was passed in as an argument to the constructor then it will not be destroyed
       * @param {boolean} [options.texture=false] - Should destroy the texture of the graphics context
       * @param {boolean} [options.textureSource=false] - Should destroy the texture source of the graphics context
       * @param {boolean} [options.context=false] - Should destroy the context
       */
      destroy(options) {
        if (this._ownedContext && !options) {
          this._ownedContext.destroy(options);
        } else if (options === true || options?.context === true) {
          this._context.destroy(options);
        }
        this._ownedContext = null;
        this._context = null;
        super.destroy(options);
      }
      _callContextMethod(method, args) {
        this.context[method](...args);
        return this;
      }
      // --------------------------------------- GraphicsContext methods ---------------------------------------
      /**
       * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
       * pattern, or a more complex style defined by a FillStyle object.
       * @param {FillInput} args - The fill style to apply. This can be a simple color, a gradient or
       * pattern object, or a FillStyle or ConvertedFillStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setFillStyle(...args) {
        return this._callContextMethod("setFillStyle", args);
      }
      /**
       * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
       * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
       * @param {StrokeInput} args - The stroke style to apply. Can be defined as a color, a gradient or pattern,
       * or a StrokeStyle or ConvertedStrokeStyle object.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      setStrokeStyle(...args) {
        return this._callContextMethod("setStrokeStyle", args);
      }
      fill(...args) {
        return this._callContextMethod("fill", args);
      }
      /**
       * Strokes the current path with the current stroke style. This method can take an optional
       * FillStyle parameter to define the stroke's appearance, including its color, width, and other properties.
       * @param {FillStyle} args - (Optional) The stroke style to apply. Can be defined as a simple color or a more
       * complex style object. If omitted, uses the current stroke style.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      stroke(...args) {
        return this._callContextMethod("stroke", args);
      }
      texture(...args) {
        return this._callContextMethod("texture", args);
      }
      /**
       * Resets the current path. Any previous path and its commands are discarded and a new path is
       * started. This is typically called before beginning a new shape or series of drawing commands.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      beginPath() {
        return this._callContextMethod("beginPath", []);
      }
      /**
       * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
       * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
       * fail to cut correctly!
       */
      cut() {
        return this._callContextMethod("cut", []);
      }
      arc(...args) {
        return this._callContextMethod("arc", args);
      }
      arcTo(...args) {
        return this._callContextMethod("arcTo", args);
      }
      arcToSvg(...args) {
        return this._callContextMethod("arcToSvg", args);
      }
      bezierCurveTo(...args) {
        return this._callContextMethod("bezierCurveTo", args);
      }
      /**
       * Closes the current path by drawing a straight line back to the start.
       * If the shape is already closed or there are no points in the path, this method does nothing.
       * @returns The instance of the current object for chaining.
       */
      closePath() {
        return this._callContextMethod("closePath", []);
      }
      ellipse(...args) {
        return this._callContextMethod("ellipse", args);
      }
      circle(...args) {
        return this._callContextMethod("circle", args);
      }
      path(...args) {
        return this._callContextMethod("path", args);
      }
      lineTo(...args) {
        return this._callContextMethod("lineTo", args);
      }
      moveTo(...args) {
        return this._callContextMethod("moveTo", args);
      }
      quadraticCurveTo(...args) {
        return this._callContextMethod("quadraticCurveTo", args);
      }
      rect(...args) {
        return this._callContextMethod("rect", args);
      }
      roundRect(...args) {
        return this._callContextMethod("roundRect", args);
      }
      poly(...args) {
        return this._callContextMethod("poly", args);
      }
      regularPoly(...args) {
        return this._callContextMethod("regularPoly", args);
      }
      roundPoly(...args) {
        return this._callContextMethod("roundPoly", args);
      }
      roundShape(...args) {
        return this._callContextMethod("roundShape", args);
      }
      filletRect(...args) {
        return this._callContextMethod("filletRect", args);
      }
      chamferRect(...args) {
        return this._callContextMethod("chamferRect", args);
      }
      star(...args) {
        return this._callContextMethod("star", args);
      }
      svg(...args) {
        return this._callContextMethod("svg", args);
      }
      restore(...args) {
        return this._callContextMethod("restore", args);
      }
      /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
      save() {
        return this._callContextMethod("save", []);
      }
      /**
       * Returns the current transformation matrix of the graphics context.
       * @returns The current transformation matrix.
       */
      getTransform() {
        return this.context.getTransform();
      }
      /**
       * Resets the current transformation matrix to the identity matrix, effectively removing
       * any transformations (rotation, scaling, translation) previously applied.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      resetTransform() {
        return this._callContextMethod("resetTransform", []);
      }
      rotateTransform(...args) {
        return this._callContextMethod("rotate", args);
      }
      scaleTransform(...args) {
        return this._callContextMethod("scale", args);
      }
      setTransform(...args) {
        return this._callContextMethod("setTransform", args);
      }
      transform(...args) {
        return this._callContextMethod("transform", args);
      }
      translateTransform(...args) {
        return this._callContextMethod("translate", args);
      }
      /**
       * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
       * and optionally resetting transformations to the identity matrix.
       * @returns The instance of the current GraphicsContext for method chaining.
       */
      clear() {
        return this._callContextMethod("clear", []);
      }
      /**
       * The fill style to use.
       * @type {ConvertedFillStyle}
       */
      get fillStyle() {
        return this._context.fillStyle;
      }
      set fillStyle(value) {
        this._context.fillStyle = value;
      }
      /**
       * The stroke style to use.
       * @type {ConvertedStrokeStyle}
       */
      get strokeStyle() {
        return this._context.strokeStyle;
      }
      set strokeStyle(value) {
        this._context.strokeStyle = value;
      }
      /**
       * Creates a new Graphics object.
       * Note that only the context of the object is cloned, not its transform (position,scale,etc)
       * @param deep - Whether to create a deep clone of the graphics object. If false, the context
       * will be shared between the two objects (default false). If true, the context will be
       * cloned (recommended if you need to modify the context in any way).
       * @returns - A clone of the graphics object
       */
      clone(deep = false) {
        if (deep) {
          return new _Graphics(this._context.clone());
        }
        this._ownedContext = null;
        const clone = new _Graphics(this._context);
        return clone;
      }
      // -------- v7 deprecations ---------
      /**
       * @param width
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
       */
      lineStyle(width, color2, alpha) {
        deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const strokeStyle = {};
        width && (strokeStyle.width = width);
        color2 && (strokeStyle.color = color2);
        alpha && (strokeStyle.alpha = alpha);
        this.context.strokeStyle = strokeStyle;
        return this;
      }
      /**
       * @param color
       * @param alpha
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      beginFill(color2, alpha) {
        deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const fillStyle = {};
        color2 && (fillStyle.color = color2);
        alpha && (fillStyle.alpha = alpha);
        this.context.fillStyle = fillStyle;
        return this;
      }
      /**
       * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
       */
      endFill() {
        deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        this.context.fill();
        const strokeStyle = this.context.strokeStyle;
        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
          this.context.stroke();
        }
        return this;
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
       */
      drawCircle(...args) {
        deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
        return this._callContextMethod("circle", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
       */
      drawEllipse(...args) {
        deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
        return this._callContextMethod("ellipse", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
       */
      drawPolygon(...args) {
        deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
        return this._callContextMethod("poly", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
       */
      drawRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
        return this._callContextMethod("rect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
       */
      drawRoundedRect(...args) {
        deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
        return this._callContextMethod("roundRect", args);
      }
      /**
       * @param {...any} args
       * @deprecated since 8.0.0 Use {@link Graphics#star} instead
       */
      drawStar(...args) {
        deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
        return this._callContextMethod("star", args);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
var maxFragmentPrecision;
var init_getMaxFragmentPrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs"() {
    init_getTestContext();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs
function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}
var init_addProgramDefines = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
var init_ensurePrecision = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs
function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}
var init_insertVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs
function setProgramName(src, { name = `pixi-program` }, isFragment = true) {
  name = name.replace(/\s+/g, "-");
  name += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name]) {
    nameCache[name]++;
    name += `-${nameCache[name]}`;
  } else {
    nameCache[name] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name}`;
  return `${shaderName}
${src}`;
}
var fragmentNameCache, VertexNameCache;
var init_setProgramName = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs"() {
    "use strict";
    fragmentNameCache = {};
    VertexNameCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs
function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}
var init_stripVersion = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs
var processes, programCache, _GlProgram, GlProgram;
var init_GlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs"() {
    init_createIdFromString();
    init_getMaxFragmentPrecision();
    init_addProgramDefines();
    init_ensurePrecision();
    init_insertVersion();
    init_setProgramName();
    init_stripVersion();
    processes = {
      // strips any version headers..
      stripVersion,
      // adds precision string if not already present
      ensurePrecision,
      // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
      addProgramDefines,
      // add the program name to the shader
      setProgramName,
      // add the version string to the shader header
      insertVersion
    };
    programCache = /* @__PURE__ */ Object.create(null);
    _GlProgram = class _GlProgram2 {
      /**
       * Creates a shiny new GlProgram. Used by WebGL renderer.
       * @param options - The options for the program.
       */
      constructor(options) {
        options = { ..._GlProgram2.defaultOptions, ...options };
        const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
        const preprocessorOptions = {
          stripVersion: isES300,
          ensurePrecision: {
            requestedFragmentPrecision: options.preferredFragmentPrecision,
            requestedVertexPrecision: options.preferredVertexPrecision,
            maxSupportedVertexPrecision: "highp",
            maxSupportedFragmentPrecision: getMaxFragmentPrecision()
          },
          setProgramName: {
            name: options.name
          },
          addProgramDefines: isES300,
          insertVersion: isES300
        };
        let fragment2 = options.fragment;
        let vertex2 = options.vertex;
        Object.keys(processes).forEach((processKey) => {
          const processOptions = preprocessorOptions[processKey];
          fragment2 = processes[processKey](fragment2, processOptions, true);
          vertex2 = processes[processKey](vertex2, processOptions, false);
        });
        this.fragment = fragment2;
        this.vertex = vertex2;
        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
      }
      /** destroys the program */
      destroy() {
        this.fragment = null;
        this.vertex = null;
        this._attributeData = null;
        this._uniformData = null;
        this._uniformBlockData = null;
        this.transformFeedbackVaryings = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex}:${options.fragment}`;
        if (!programCache[key]) {
          programCache[key] = new _GlProgram2(options);
        }
        return programCache[key];
      }
    };
    _GlProgram.defaultOptions = {
      preferredVertexPrecision: "highp",
      preferredFragmentPrecision: "mediump"
    };
    GlProgram = _GlProgram;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs
function getAttributeInfoFromFormat(format2) {
  return attributeFormatData[format2] ?? attributeFormatData.float32;
}
var attributeFormatData;
var init_getAttributeInfoFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs"() {
    "use strict";
    attributeFormatData = {
      uint8x2: { size: 2, stride: 2, normalised: false },
      uint8x4: { size: 4, stride: 4, normalised: false },
      sint8x2: { size: 2, stride: 2, normalised: false },
      sint8x4: { size: 4, stride: 4, normalised: false },
      unorm8x2: { size: 2, stride: 2, normalised: true },
      unorm8x4: { size: 4, stride: 4, normalised: true },
      snorm8x2: { size: 2, stride: 2, normalised: true },
      snorm8x4: { size: 4, stride: 4, normalised: true },
      uint16x2: { size: 2, stride: 4, normalised: false },
      uint16x4: { size: 4, stride: 8, normalised: false },
      sint16x2: { size: 2, stride: 4, normalised: false },
      sint16x4: { size: 4, stride: 8, normalised: false },
      unorm16x2: { size: 2, stride: 4, normalised: true },
      unorm16x4: { size: 4, stride: 8, normalised: true },
      snorm16x2: { size: 2, stride: 4, normalised: true },
      snorm16x4: { size: 4, stride: 8, normalised: true },
      float16x2: { size: 2, stride: 4, normalised: false },
      float16x4: { size: 4, stride: 8, normalised: false },
      float32: { size: 1, stride: 4, normalised: false },
      float32x2: { size: 2, stride: 8, normalised: false },
      float32x3: { size: 3, stride: 12, normalised: false },
      float32x4: { size: 4, stride: 16, normalised: false },
      uint32: { size: 1, stride: 4, normalised: false },
      uint32x2: { size: 2, stride: 8, normalised: false },
      uint32x3: { size: 3, stride: 12, normalised: false },
      uint32x4: { size: 4, stride: 16, normalised: false },
      sint32: { size: 1, stride: 4, normalised: false },
      sint32x2: { size: 2, stride: 8, normalised: false },
      sint32x3: { size: 3, stride: 12, normalised: false },
      sint32x4: { size: 4, stride: 16, normalised: false }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs
function extractAttributesFromGpuProgram({ source: source2, entryPoint }) {
  const results = {};
  const mainVertStart = source2.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source2.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source2.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format2 = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format: format2,
          stride: getAttributeInfoFromFormat(format2).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}
var WGSL_TO_VERTEX_TYPES;
var init_extractAttributesFromGpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs"() {
    init_getAttributeInfoFromFormat();
    WGSL_TO_VERTEX_TYPES = {
      f32: "float32",
      "vec2<f32>": "float32x2",
      "vec3<f32>": "float32x3",
      "vec4<f32>": "float32x4",
      vec2f: "float32x2",
      vec3f: "float32x3",
      vec4f: "float32x4",
      i32: "sint32",
      "vec2<i32>": "sint32x2",
      "vec3<i32>": "sint32x3",
      "vec4<i32>": "sint32x4",
      u32: "uint32",
      "vec2<u32>": "uint32x2",
      "vec3<u32>": "uint32x3",
      "vec4<u32>": "uint32x4",
      bool: "uint32",
      "vec2<bool>": "uint32x2",
      "vec3<bool>": "uint32x3",
      "vec4<bool>": "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs
function extractStructAndGroups(wgsl) {
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = wgsl.match(linePattern)?.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = wgsl.match(structPattern)?.map((struct) => {
    const name = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name2, type2] = member.split(":");
      acc[name2.trim()] = type2.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name, members };
  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];
  return {
    groups,
    structs
  };
}
var init_extractStructAndGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs
var ShaderStage;
var init_const6 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs"() {
    "use strict";
    ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
      ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
      ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
      ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
      return ShaderStage2;
    })(ShaderStage || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
var init_generateGpuLayoutGroups = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs"() {
    init_const6();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
var init_generateLayoutHash = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key)) {
      return false;
    }
    dupeGroupKeySet.add(key);
    return true;
  });
  return { structs, groups };
}
var init_removeStructAndGroupDuplicates = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs
var programCache2, GpuProgram;
var init_GpuProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs"() {
    init_createIdFromString();
    init_extractAttributesFromGpuProgram();
    init_extractStructAndGroups();
    init_generateGpuLayoutGroups();
    init_generateLayoutHash();
    init_removeStructAndGroupDuplicates();
    programCache2 = /* @__PURE__ */ Object.create(null);
    GpuProgram = class _GpuProgram {
      /**
       * Create a new GpuProgram
       * @param options - The options for the gpu program
       */
      constructor(options) {
        this._layoutKey = 0;
        this._attributeLocationsKey = 0;
        const { fragment: fragment2, vertex: vertex2, layout, gpuLayout, name } = options;
        this.name = name;
        this.fragment = fragment2;
        this.vertex = vertex2;
        if (fragment2.source === vertex2.source) {
          const structsAndGroups = extractStructAndGroups(fragment2.source);
          this.structsAndGroups = structsAndGroups;
        } else {
          const vertexStructsAndGroups = extractStructAndGroups(vertex2.source);
          const fragmentStructsAndGroups = extractStructAndGroups(fragment2.source);
          this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
        }
        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);
        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);
        this._generateProgramKey();
      }
      // TODO maker this pure
      _generateProgramKey() {
        const { vertex: vertex2, fragment: fragment2 } = this;
        const bigKey = vertex2.source + fragment2.source + vertex2.entryPoint + fragment2.entryPoint;
        this._layoutKey = createIdFromString(bigKey, "program");
      }
      get attributeData() {
        this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
        return this._attributeData;
      }
      /** destroys the program */
      destroy() {
        this.gpuLayout = null;
        this.layout = null;
        this.structsAndGroups = null;
        this.fragment = null;
        this.vertex = null;
      }
      /**
       * Helper function that creates a program for a given source.
       * It will check the program cache if the program has already been created.
       * If it has that one will be returned, if not a new one will be created and cached.
       * @param options - The options for the program.
       * @returns A program using the same source
       */
      static from(options) {
        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
        if (!programCache2[key]) {
          programCache2[key] = new _GpuProgram(options);
        }
        return programCache2[key];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs
function addBits(srcParts, parts, name) {
  if (srcParts) {
    for (const i2 in srcParts) {
      const id2 = i2.toLocaleLowerCase();
      const part = parts[id2];
      if (part) {
        let sanitisedPart = srcParts[i2];
        if (i2 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name) {
          part.push(`//----${name}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i2} placement hook does not exist in shader`);
      }
    }
  }
}
var init_addBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs"() {
    init_warn();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs
function compileHooks(programSrc) {
  const parts = {};
  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, "")) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
var findHooksRx;
var init_compileHooks = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs"() {
    "use strict";
    findHooksRx = /\{\{(.*?)\}\}/g;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs
function extractInputs(fragmentSource, out2) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment2) => {
    if (fragment2.header) {
      extractInputs(fragment2.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
var init_compileInputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs
function extractOutputs(fragmentSource, out2) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function extractVariableName(value) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value);
  return match ? match[1] : "";
}
function stripVariable(value) {
  const regex = /@.*?\s+/g;
  return value.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment2) => {
    if (fragment2.header) {
      extractOutputs(fragment2.header, results);
    }
  });
  let index2 = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index2++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
var init_compileOutputs = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs
function injectBits(templateSrc, fragmentParts) {
  let out2 = templateSrc;
  for (const i2 in fragmentParts) {
    const parts = fragmentParts[i2];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
    } else {
      out2 = out2.replace(`{{${i2}}}`, "");
    }
  }
  return out2;
}
var init_injectBits = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex: vertex2, fragment: fragment2 } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex2, fragment2, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v3) => !!v3);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v3) => !!v3);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a3, b2) => a3 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex2, fragment2, bits) {
  const vertexParts = compileHooks(vertex2);
  const fragmentParts = compileHooks(fragment2);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex2, vertexParts),
    fragment: injectBits(fragment2, fragmentParts)
  };
}
var cacheMap, bitCacheMap, CACHE_UID;
var init_compileHighShader = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs"() {
    init_addBits();
    init_compileHooks();
    init_compileInputs();
    init_compileOutputs();
    init_injectBits();
    cacheMap = /* @__PURE__ */ Object.create(null);
    bitCacheMap = /* @__PURE__ */ new Map();
    CACHE_UID = 0;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs
var vertexGPUTemplate, fragmentGPUTemplate, vertexGlTemplate, fragmentGlTemplate;
var init_defaultProgramTemplate = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs"() {
    "use strict";
    vertexGPUTemplate = /* wgsl */
    `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`;
    fragmentGPUTemplate = /* wgsl */
    `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`;
    vertexGlTemplate = /* glsl */
    `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`;
    fragmentGlTemplate = /* glsl */
    `
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs
var globalUniformsBit, globalUniformsBitGl;
var init_globalUniformsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs"() {
    "use strict";
    globalUniformsBit = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* wgsl */
          `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        )
      }
    };
    globalUniformsBitGl = {
      name: "global-uniforms-bit",
      vertex: {
        header: (
          /* glsl */
          `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs
function compileHighShaderGpuProgram({ bits, name }) {
  const source2 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return GpuProgram.from({
    name,
    vertex: {
      source: source2.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source2.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name }) {
  return new GlProgram({
    name,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
var init_compileHighShaderToProgram = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_compileHighShader();
    init_defaultProgramTemplate();
    init_globalUniformsBit();
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs
var colorBit, colorBitGl;
var init_colorBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs"() {
    "use strict";
    colorBit = {
      name: "color-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            @in aColor: vec4<f32>;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
    colorBitGl = {
      name: "color-bit",
      vertex: {
        header: (
          /* glsl */
          `
            in vec4 aColor;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs
function generateBindingSrc(maxTextures2) {
  const src = [];
  if (maxTextures2 === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures2) {
  const src = [];
  if (maxTextures2 === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i2 = 0; i2 < maxTextures2; i2++) {
      if (i2 === maxTextures2 - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i2}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures2) {
  if (!textureBatchBitGpuCache[maxTextures2]) {
    textureBatchBitGpuCache[maxTextures2] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures2)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures2)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures2];
}
function generateSampleGlSrc(maxTextures2) {
  const src = [];
  for (let i2 = 0; i2 < maxTextures2; i2++) {
    if (i2 > 0) {
      src.push("else");
    }
    if (i2 < maxTextures2 - 1) {
      src.push(`if(vTextureId < ${i2}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures2) {
  if (!textureBatchBitGlCache[maxTextures2]) {
    textureBatchBitGlCache[maxTextures2] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures2}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures2)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures2];
}
var textureBatchBitGpuCache, textureBatchBitGlCache;
var init_generateTextureBatchBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs"() {
    "use strict";
    textureBatchBitGpuCache = {};
    textureBatchBitGlCache = {};
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs
var roundPixelsBit, roundPixelsBitGl;
var init_roundPixelsBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs"() {
    "use strict";
    roundPixelsBit = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
    roundPixelsBitGl = {
      name: "round-pixels-bit",
      vertex: {
        header: (
          /* glsl */
          `   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs
function getBatchSamplersUniformGroup(maxTextures2) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures2);
  for (let i2 = 0; i2 < maxTextures2; i2++) {
    sampleValues[i2] = i2;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures2] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures2 }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}
var batchSamplersUniformGroupHash;
var init_getBatchSamplersUniformGroup = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs"() {
    init_UniformGroup();
    batchSamplersUniformGroupHash = {};
  }
});

// node_modules/pixi.js/lib/rendering/renderers/types.mjs
var RendererType;
var init_types2 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/types.mjs"() {
    "use strict";
    RendererType = /* @__PURE__ */ ((RendererType2) => {
      RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
      RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
      RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
      return RendererType2;
    })(RendererType || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs
var Shader;
var init_Shader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs"() {
    init_eventemitter3();
    init_GlProgram();
    init_BindGroup();
    init_GpuProgram();
    init_types2();
    init_UniformGroup();
    Shader = class _Shader extends eventemitter3_default {
      constructor(options) {
        super();
        this._uniformBindMap = /* @__PURE__ */ Object.create(null);
        this._ownedBindGroups = [];
        let {
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          groups,
          resources,
          compatibleRenderers,
          groupMap
        } = options;
        this.gpuProgram = gpuProgram3;
        this.glProgram = glProgram3;
        if (compatibleRenderers === void 0) {
          compatibleRenderers = 0;
          if (gpuProgram3)
            compatibleRenderers |= RendererType.WEBGPU;
          if (glProgram3)
            compatibleRenderers |= RendererType.WEBGL;
        }
        this.compatibleRenderers = compatibleRenderers;
        const nameHash = {};
        if (!resources && !groups) {
          resources = {};
        }
        if (resources && groups) {
          throw new Error("[Shader] Cannot have both resources and groups");
        } else if (!gpuProgram3 && groups && !groupMap) {
          throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        } else if (!gpuProgram3 && groups && groupMap) {
          for (const i2 in groupMap) {
            for (const j3 in groupMap[i2]) {
              const uniformName = groupMap[i2][j3];
              nameHash[uniformName] = {
                group: i2,
                binding: j3,
                name: uniformName
              };
            }
          }
        } else if (gpuProgram3 && groups && !groupMap) {
          const groupData = gpuProgram3.structsAndGroups.groups;
          groupMap = {};
          groupData.forEach((data) => {
            groupMap[data.group] = groupMap[data.group] || {};
            groupMap[data.group][data.binding] = data.name;
            nameHash[data.name] = data;
          });
        } else if (resources) {
          groups = {};
          groupMap = {};
          if (gpuProgram3) {
            const groupData = gpuProgram3.structsAndGroups.groups;
            groupData.forEach((data) => {
              groupMap[data.group] = groupMap[data.group] || {};
              groupMap[data.group][data.binding] = data.name;
              nameHash[data.name] = data;
            });
          }
          let bindTick = 0;
          for (const i2 in resources) {
            if (nameHash[i2])
              continue;
            if (!groups[99]) {
              groups[99] = new BindGroup();
              this._ownedBindGroups.push(groups[99]);
            }
            nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
            groupMap[99] = groupMap[99] || {};
            groupMap[99][bindTick] = i2;
            bindTick++;
          }
          for (const i2 in resources) {
            const name = i2;
            let value = resources[i2];
            if (!value.source && !value._resourceType) {
              value = new UniformGroup(value);
            }
            const data = nameHash[name];
            if (data) {
              if (!groups[data.group]) {
                groups[data.group] = new BindGroup();
                this._ownedBindGroups.push(groups[data.group]);
              }
              groups[data.group].setResource(value, data.binding);
            }
          }
        }
        this.groups = groups;
        this._uniformBindMap = groupMap;
        this.resources = this._buildResourceAccessor(groups, nameHash);
      }
      /**
       * Sometimes a resource group will be provided later (for example global uniforms)
       * In such cases, this method can be used to let the shader know about the group.
       * @param name - the name of the resource group
       * @param groupIndex - the index of the group (should match the webGPU shader group location)
       * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
       */
      addResource(name, groupIndex, bindIndex2) {
        var _a, _b;
        (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
        (_b = this._uniformBindMap[groupIndex])[bindIndex2] || (_b[bindIndex2] = name);
        if (!this.groups[groupIndex]) {
          this.groups[groupIndex] = new BindGroup();
          this._ownedBindGroups.push(this.groups[groupIndex]);
        }
      }
      _buildResourceAccessor(groups, nameHash) {
        const uniformsOut = {};
        for (const i2 in nameHash) {
          const data = nameHash[i2];
          Object.defineProperty(uniformsOut, data.name, {
            get() {
              return groups[data.group].getResource(data.binding);
            },
            set(value) {
              groups[data.group].setResource(value, data.binding);
            }
          });
        }
        return uniformsOut;
      }
      /**
       * Use to destroy the shader when its not longer needed.
       * It will destroy the resources and remove listeners.
       * @param destroyPrograms - if the programs should be destroyed as well.
       * Make sure its not being used by other shaders!
       */
      destroy(destroyPrograms = false) {
        this.emit("destroy", this);
        if (destroyPrograms) {
          this.gpuProgram?.destroy();
          this.glProgram?.destroy();
        }
        this.gpuProgram = null;
        this.glProgram = null;
        this.removeAllListeners();
        this._uniformBindMap = null;
        this._ownedBindGroups.forEach((bindGroup) => {
          bindGroup.destroy();
        });
        this._ownedBindGroups = null;
        this.resources = null;
        this.groups = null;
      }
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Shader({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs
var localUniformMSDFBit, localUniformMSDFBitGl;
var init_localUniformMSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs"() {
    "use strict";
    localUniformMSDFBit = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `
        ),
        main: (
          /* wgsl */
          ` 
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        )
      }
    };
    localUniformMSDFBitGl = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform float uDistance;
         `
        ),
        main: (
          /* glsl */
          ` 
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs
var mSDFBit, mSDFBitGl;
var init_mSDFBit = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs"() {
    "use strict";
    mSDFBit = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* wgsl */
          `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;
             
            }
        `
        )
      }
    };
    mSDFBitGl = {
      name: "msdf-bit",
      fragment: {
        header: (
          /* glsl */
          `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);  
              
                return coverage;
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs
var gpuProgram, glProgram, SdfShader;
var init_SdfShader = __esm({
  "node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs"() {
    init_Matrix();
    init_maxRecommendedTextures();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    init_localUniformMSDFBit();
    init_mSDFBit();
    SdfShader = class extends Shader {
      constructor() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uDistance: { value: 4, type: "f32" },
          uRound: { value: 0, type: "f32" }
        });
        const maxTextures2 = getMaxTexturesPerBatch();
        gpuProgram ?? (gpuProgram = compileHighShaderGpuProgram({
          name: "sdf-shader",
          bits: [
            colorBit,
            generateTextureBatchBit(maxTextures2),
            localUniformMSDFBit,
            mSDFBit,
            roundPixelsBit
          ]
        }));
        glProgram ?? (glProgram = compileHighShaderGlProgram({
          name: "sdf-shader",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            localUniformMSDFBitGl,
            mSDFBitGl,
            roundPixelsBitGl
          ]
        }));
        super({
          glProgram,
          gpuProgram,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs
var AbstractBitmapFont;
var init_AbstractBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/AbstractBitmapFont.mjs"() {
    init_eventemitter3();
    init_deprecation();
    AbstractBitmapFont = class extends eventemitter3_default {
      constructor() {
        super(...arguments);
        this.chars = /* @__PURE__ */ Object.create(null);
        this.lineHeight = 0;
        this.fontFamily = "";
        this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
        this.baseLineOffset = 0;
        this.distanceField = { type: "none", range: 0 };
        this.pages = [];
        this.applyFillAsTint = true;
        this.baseMeasurementFontSize = 100;
        this.baseRenderedFontSize = 100;
      }
      /**
       * The name of the font face.
       * @deprecated since 8.0.0 Use `fontFamily` instead.
       */
      get font() {
        deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
        return this.fontFamily;
      }
      /**
       * The map of base page textures (i.e., sheets of glyphs).
       * @deprecated since 8.0.0 Use `pages` instead.
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      /**
       * The size of the font face in pixels.
       * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
       */
      get size() {
        deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
        return this.fontMetrics.fontSize;
      }
      /**
       * The kind of distance field for this font or "none".
       * @deprecated since 8.0.0 Use `distanceField.type` instead.
       */
      get distanceFieldRange() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
        return this.distanceField.range;
      }
      /**
       * The range of the distance field in pixels.
       * @deprecated since 8.0.0 Use `distanceField.range` instead.
       */
      get distanceFieldType() {
        deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
        return this.distanceField.type;
      }
      destroy(destroyTextures = false) {
        this.emit("destroy", this);
        this.removeAllListeners();
        for (const i2 in this.chars) {
          this.chars[i2].texture?.destroy();
        }
        this.chars = null;
        if (destroyTextures) {
          this.pages.forEach((page) => page.texture.destroy(true));
          this.pages = null;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j3 = chars.length; i2 < j3; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
var init_resolveCharacters = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/resolveCharacters.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs
var _DynamicBitmapFont, DynamicBitmapFont;
var init_DynamicBitmapFont = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/DynamicBitmapFont.mjs"() {
    init_Color();
    init_Rectangle();
    init_CanvasPool();
    init_ImageSource();
    init_Texture();
    init_deprecation();
    init_CanvasTextMetrics();
    init_fontStringFromTextStyle();
    init_getCanvasFillStyle();
    init_TextStyle();
    init_AbstractBitmapFont();
    init_resolveCharacters();
    _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
      /**
       * @param options - The options for the dynamic bitmap font.
       */
      constructor(options) {
        super();
        this.resolution = 1;
        this.pages = [];
        this._padding = 0;
        this._measureCache = /* @__PURE__ */ Object.create(null);
        this._currentChars = [];
        this._currentX = 0;
        this._currentY = 0;
        this._currentPageIndex = -1;
        this._skipKerning = false;
        const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
        this._textureSize = dynamicOptions.textureSize;
        this._mipmap = dynamicOptions.mipmap;
        const style = dynamicOptions.style.clone();
        if (dynamicOptions.overrideFill) {
          style._fill.color = 16777215;
          style._fill.alpha = 1;
          style._fill.texture = Texture.WHITE;
          style._fill.fill = null;
        }
        this.applyFillAsTint = dynamicOptions.overrideFill;
        const requestedFontSize = style.fontSize;
        style.fontSize = this.baseMeasurementFontSize;
        const font = fontStringFromTextStyle(style);
        if (dynamicOptions.overrideSize) {
          if (style._stroke) {
            style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
          }
        } else {
          style.fontSize = this.baseRenderedFontSize = requestedFontSize;
        }
        this._style = style;
        this._skipKerning = dynamicOptions.skipKerning ?? false;
        this.resolution = dynamicOptions.resolution ?? 1;
        this._padding = dynamicOptions.padding ?? 4;
        this.fontMetrics = CanvasTextMetrics.measureFont(font);
        this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
      }
      ensureCharacters(chars) {
        const charList = resolveCharacters(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index2, self2) => self2.indexOf(char) === index2);
        if (!charList.length)
          return;
        this._currentChars = [...this._currentChars, ...charList];
        let pageData;
        if (this._currentPageIndex === -1) {
          pageData = this._nextPage();
        } else {
          pageData = this.pages[this._currentPageIndex];
        }
        let { canvas, context: context2 } = pageData.canvasAndContext;
        let textureSource = pageData.texture.source;
        const style = this._style;
        let currentX = this._currentX;
        let currentY = this._currentY;
        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
        const padding = this._padding * fontScale;
        const widthScale = style.fontStyle === "italic" ? 2 : 1;
        let maxCharHeight = 0;
        let skipTexture = false;
        for (let i2 = 0; i2 < charList.length; i2++) {
          const char = charList[i2];
          const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
          metrics.lineHeight = metrics.height;
          const width = widthScale * metrics.width * fontScale;
          const height = metrics.height * fontScale;
          const paddedWidth = width + padding * 2;
          const paddedHeight = height + padding * 2;
          skipTexture = false;
          if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
            skipTexture = true;
            maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));
          }
          if (currentX + paddedWidth > this._textureSize) {
            currentY += maxCharHeight;
            maxCharHeight = paddedHeight;
            currentX = 0;
            if (currentY + maxCharHeight > this._textureSize) {
              textureSource.update();
              const pageData2 = this._nextPage();
              canvas = pageData2.canvasAndContext.canvas;
              context2 = pageData2.canvasAndContext.context;
              textureSource = pageData2.texture.source;
              currentY = 0;
            }
          }
          const xAdvance = width / fontScale - (style.dropShadow?.distance ?? 0) - (style._stroke?.width ?? 0);
          this.chars[char] = {
            id: char.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance,
            kerning: {}
          };
          if (skipTexture) {
            this._drawGlyph(
              context2,
              metrics,
              currentX + padding,
              currentY + padding,
              fontScale,
              style
            );
            const px = textureSource.width * fontScale;
            const py = textureSource.height * fontScale;
            const frame2 = new Rectangle(
              currentX / px * textureSource.width,
              currentY / py * textureSource.height,
              paddedWidth / px * textureSource.width,
              paddedHeight / py * textureSource.height
            );
            this.chars[char].texture = new Texture({
              source: textureSource,
              frame: frame2
            });
            currentX += Math.ceil(paddedWidth);
          }
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._skipKerning && this._applyKerning(charList, context2);
      }
      /**
       * @deprecated since 8.0.0
       * The map of base page textures (i.e., sheets of glyphs).
       */
      get pageTextures() {
        deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
        return this.pages;
      }
      _applyKerning(newChars, context2) {
        const measureCache = this._measureCache;
        for (let i2 = 0; i2 < newChars.length; i2++) {
          const first = newChars[i2];
          for (let j3 = 0; j3 < this._currentChars.length; j3++) {
            const second = this._currentChars[j3];
            let c1 = measureCache[first];
            if (!c1)
              c1 = measureCache[first] = context2.measureText(first).width;
            let c22 = measureCache[second];
            if (!c22)
              c22 = measureCache[second] = context2.measureText(second).width;
            let total = context2.measureText(first + second).width;
            let amount = total - (c1 + c22);
            if (amount) {
              this.chars[first].kerning[second] = amount;
            }
            total = context2.measureText(first + second).width;
            amount = total - (c1 + c22);
            if (amount) {
              this.chars[second].kerning[first] = amount;
            }
          }
        }
      }
      _nextPage() {
        this._currentPageIndex++;
        const textureResolution = this.resolution;
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
          this._textureSize,
          this._textureSize,
          textureResolution
        );
        this._setupContext(canvasAndContext.context, this._style, textureResolution);
        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
        const texture = new Texture({
          source: new ImageSource({
            resource: canvasAndContext.canvas,
            resolution,
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: this._mipmap
          })
        });
        const pageData = {
          canvasAndContext,
          texture
        };
        this.pages[this._currentPageIndex] = pageData;
        return pageData;
      }
      // canvas style!
      _setupContext(context2, style, resolution) {
        style.fontSize = this.baseRenderedFontSize;
        context2.scale(resolution, resolution);
        context2.font = fontStringFromTextStyle(style);
        style.fontSize = this.baseMeasurementFontSize;
        context2.textBaseline = style.textBaseline;
        const stroke = style._stroke;
        const strokeThickness = stroke?.width ?? 0;
        if (stroke) {
          context2.lineWidth = strokeThickness;
          context2.lineJoin = stroke.join;
          context2.miterLimit = stroke.miterLimit;
          context2.strokeStyle = getCanvasFillStyle(stroke, context2);
        }
        if (style._fill) {
          context2.fillStyle = getCanvasFillStyle(style._fill, context2);
        }
        if (style.dropShadow) {
          const shadowOptions = style.dropShadow;
          const rgb2 = Color.shared.setValue(shadowOptions.color).toArray();
          const dropShadowBlur = shadowOptions.blur * resolution;
          const dropShadowDistance = shadowOptions.distance * resolution;
          context2.shadowColor = `rgba(${rgb2[0] * 255},${rgb2[1] * 255},${rgb2[2] * 255},${shadowOptions.alpha})`;
          context2.shadowBlur = dropShadowBlur;
          context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
          context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
        } else {
          context2.shadowColor = "black";
          context2.shadowBlur = 0;
          context2.shadowOffsetX = 0;
          context2.shadowOffsetY = 0;
        }
      }
      _drawGlyph(context2, metrics, x5, y4, fontScale, style) {
        const char = metrics.text;
        const fontProperties = metrics.fontProperties;
        const stroke = style._stroke;
        const strokeThickness = (stroke?.width ?? 0) * fontScale;
        const tx = x5 + strokeThickness / 2;
        const ty = y4 - strokeThickness / 2;
        const descent = fontProperties.descent * fontScale;
        const lineHeight = metrics.lineHeight * fontScale;
        if (style.stroke && strokeThickness) {
          context2.strokeText(char, tx, ty + lineHeight - descent);
        }
        if (style._fill) {
          context2.fillText(char, tx, ty + lineHeight - descent);
        }
      }
      destroy() {
        super.destroy();
        for (let i2 = 0; i2 < this.pages.length; i2++) {
          const { canvasAndContext, texture } = this.pages[i2];
          canvasAndContext.canvas.width = canvasAndContext.canvas.width;
          CanvasPool.returnCanvasAndContext(canvasAndContext);
          texture.destroy(true);
        }
        this.pages = null;
      }
    };
    _DynamicBitmapFont.defaultOptions = {
      textureSize: 512,
      style: new TextStyle(),
      mipmap: true
    };
    DynamicBitmapFont = _DynamicBitmapFont;
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs
function getBitmapTextLayout(chars, style, font) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    spaceWord: false,
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const nextWord = (word) => {
    const start2 = currentLine.width;
    for (let j3 = 0; j3 < currentWord.index; j3++) {
      const position = word.positions[j3];
      currentLine.chars.push(word.chars[j3]);
      currentLine.charPositions.push(position + start2);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index2 = currentLine.chars.length - 1;
    let lastChar = currentLine.chars[index2];
    while (lastChar === " ") {
      currentLine.width -= font.chars[lastChar].xAdvance;
      lastChar = currentLine.chars[--index2];
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += font.lineHeight;
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  for (let i2 = 0; i2 < chars.length + 1; i2++) {
    let char;
    const isEnd = i2 === chars.length;
    if (!isEnd) {
      char = chars[i2];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > adjustedWordWrapWidth;
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        if (currentLine.width !== 0) {
          nextLine();
        }
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width - line.width;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      line.charPositions[j3] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j3 = 0; j3 < line.charPositions.length; j3++) {
      if (j3 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j3] += offset;
    }
  }
}
var init_getBitmapTextLayout = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/utils/getBitmapTextLayout.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs
var fontCount, BitmapFontManagerClass, BitmapFontManager;
var init_BitmapFontManager = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapFontManager.mjs"() {
    init_Cache();
    init_deprecation();
    init_warn();
    init_TextStyle();
    init_DynamicBitmapFont();
    init_getBitmapTextLayout();
    init_resolveCharacters();
    fontCount = 0;
    BitmapFontManagerClass = class {
      constructor() {
        this.ALPHA = [["a", "z"], ["A", "Z"], " "];
        this.NUMERIC = [["0", "9"]];
        this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
        this.ASCII = [[" ", "~"]];
        this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: false
        };
      }
      /**
       * Get a font for the specified text and style.
       * @param text - The text to get the font for
       * @param style - The style to use
       */
      getFont(text, style) {
        let fontFamilyKey = `${style.fontFamily}-bitmap`;
        let overrideFill = true;
        if (style._fill.fill && !style._stroke) {
          fontFamilyKey += style._fill.fill.styleKey;
          overrideFill = false;
        } else if (style._stroke || style.dropShadow) {
          let key = style.styleKey;
          key = key.substring(0, key.lastIndexOf("-"));
          fontFamilyKey = `${key}-bitmap`;
          overrideFill = false;
        }
        if (!Cache.has(fontFamilyKey)) {
          const fnt = new DynamicBitmapFont({
            style,
            overrideFill,
            overrideSize: true,
            ...this.defaultOptions
          });
          fontCount++;
          if (fontCount > 50) {
            warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
          }
          fnt.once("destroy", () => {
            fontCount--;
            Cache.remove(fontFamilyKey);
          });
          Cache.set(
            fontFamilyKey,
            fnt
          );
        }
        const dynamicFont = Cache.get(fontFamilyKey);
        dynamicFont.ensureCharacters?.(text);
        return dynamicFont;
      }
      /**
       * Get the layout of a text for the specified style.
       * @param text - The text to get the layout for
       * @param style - The style to use
       */
      getLayout(text, style) {
        const bitmapFont = this.getFont(text, style);
        return getBitmapTextLayout([...text], style, bitmapFont);
      }
      /**
       * Measure the text using the specified style.
       * @param text - The text to measure
       * @param style - The style to use
       */
      measureText(text, style) {
        return this.getLayout(text, style);
      }
      // eslint-disable-next-line max-len
      install(...args) {
        let options = args[0];
        if (typeof options === "string") {
          options = {
            name: options,
            style: args[1],
            chars: args[2]?.chars,
            resolution: args[2]?.resolution,
            padding: args[2]?.padding,
            skipKerning: args[2]?.skipKerning
          };
          deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
        }
        const name = options?.name;
        if (!name) {
          throw new Error("[BitmapFontManager] Property `name` is required.");
        }
        options = { ...this.defaultOptions, ...options };
        const textStyle = options.style;
        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
        const overrideFill = style._fill.fill !== null && style._fill.fill !== void 0;
        const font = new DynamicBitmapFont({
          style,
          overrideFill,
          skipKerning: options.skipKerning,
          padding: options.padding,
          resolution: options.resolution,
          overrideSize: false
        });
        const flatChars = resolveCharacters(options.chars);
        font.ensureCharacters(flatChars.join(""));
        Cache.set(`${name}-bitmap`, font);
        font.once("destroy", () => Cache.remove(`${name}-bitmap`));
        return font;
      }
      /**
       * Uninstalls a bitmap font from the cache.
       * @param {string} name - The name of the bitmap font to uninstall.
       */
      uninstall(name) {
        const cacheKey = `${name}-bitmap`;
        const font = Cache.get(cacheKey);
        if (font) {
          Cache.remove(cacheKey);
          font.destroy();
        }
      }
    };
    BitmapFontManager = new BitmapFontManagerClass();
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs
function syncWithProxy(container, proxy) {
  proxy.groupTransform = container.groupTransform;
  proxy.groupColorAlpha = container.groupColorAlpha;
  proxy.groupColor = container.groupColor;
  proxy.groupBlendMode = container.groupBlendMode;
  proxy.globalDisplayStatus = container.globalDisplayStatus;
  proxy.groupTransform = container.groupTransform;
  proxy.localDisplayStatus = container.localDisplayStatus;
  proxy.groupAlpha = container.groupAlpha;
  proxy._roundPixels = container._roundPixels;
}
var BitmapTextPipe;
var init_BitmapTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs"() {
    init_Cache();
    init_Extensions();
    init_PoolGroup();
    init_Graphics();
    init_SdfShader();
    init_BitmapFontManager();
    init_getBitmapTextLayout();
    BitmapTextPipe = class {
      constructor(renderer) {
        this._gpuBitmapText = {};
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
      }
      validateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        if (bitmapText._didTextUpdate) {
          bitmapText._didTextUpdate = false;
          this._updateContext(bitmapText, graphicsRenderable);
        }
        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
      }
      addRenderable(bitmapText, instructionSet) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        if (bitmapText._didTextUpdate) {
          bitmapText._didTextUpdate = false;
          this._updateContext(bitmapText, graphicsRenderable);
        }
        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      destroyRenderable(bitmapText) {
        bitmapText.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableByUid(bitmapText.uid);
      }
      _destroyRenderableByUid(renderableUid) {
        const context2 = this._gpuBitmapText[renderableUid].context;
        if (context2.customShader) {
          BigPool.return(context2.customShader);
          context2.customShader = null;
        }
        BigPool.return(this._gpuBitmapText[renderableUid]);
        this._gpuBitmapText[renderableUid] = null;
      }
      updateRenderable(bitmapText) {
        const graphicsRenderable = this._getGpuBitmapText(bitmapText);
        syncWithProxy(bitmapText, graphicsRenderable);
        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
        if (graphicsRenderable.context.customShader) {
          this._updateDistanceField(bitmapText);
        }
      }
      _updateContext(bitmapText, proxyGraphics) {
        const { context: context2 } = proxyGraphics;
        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
        context2.clear();
        if (bitmapFont.distanceField.type !== "none") {
          if (!context2.customShader) {
            context2.customShader = BigPool.get(SdfShader);
          }
        }
        const chars = Array.from(bitmapText.text);
        const style = bitmapText._style;
        let currentY = bitmapFont.baseLineOffset;
        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont);
        let index2 = 0;
        const padding = style.padding;
        const scale = bitmapTextLayout.scale;
        let tx = bitmapTextLayout.width;
        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
        if (style._stroke) {
          tx += style._stroke.width / scale;
          ty += style._stroke.width / scale;
        }
        context2.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
        for (let i2 = 0; i2 < bitmapTextLayout.lines.length; i2++) {
          const line = bitmapTextLayout.lines[i2];
          for (let j3 = 0; j3 < line.charPositions.length; j3++) {
            const char = chars[index2++];
            const charData = bitmapFont.chars[char];
            if (charData?.texture) {
              context2.texture(
                charData.texture,
                tint ? tint : "black",
                Math.round(line.charPositions[j3] + charData.xOffset),
                Math.round(currentY + charData.yOffset)
              );
            }
          }
          currentY += bitmapFont.lineHeight;
        }
      }
      _getGpuBitmapText(bitmapText) {
        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
      }
      initGpuText(bitmapText) {
        const proxyRenderable = BigPool.get(Graphics);
        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
        this._updateContext(bitmapText, proxyRenderable);
        bitmapText.on("destroyed", this._destroyRenderableBound);
        return this._gpuBitmapText[bitmapText.uid];
      }
      _updateDistanceField(bitmapText) {
        const context2 = this._getGpuBitmapText(bitmapText).context;
        const fontFamily = bitmapText._style.fontFamily;
        const dynamicFont = Cache.get(`${fontFamily}-bitmap`);
        const { a: a3, b: b2, c: c3, d: d3 } = bitmapText.groupTransform;
        const dx = Math.sqrt(a3 * a3 + b2 * b2);
        const dy = Math.sqrt(c3 * c3 + d3 * d3);
        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;
        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;
        const distance2 = worldScale * dynamicFont.distanceField.range * (1 / fontScale);
        context2.customShader.resources.localUniforms.uniforms.uDistance = distance2;
      }
      destroy() {
        for (const uid3 in this._gpuBitmapText) {
          this._destroyRenderableByUid(uid3);
        }
        this._gpuBitmapText = null;
        this._renderer = null;
      }
    };
    BitmapTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "bitmapText"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-bitmap/init.mjs
var init_init9 = __esm({
  "node_modules/pixi.js/lib/scene/text-bitmap/init.mjs"() {
    init_Extensions();
    init_BitmapTextPipe();
    extensions.add(BitmapTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs
var HTMLTextPipe;
var init_HTMLTextPipe = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs"() {
    init_Extensions();
    init_Texture();
    init_updateQuadBounds();
    init_PoolGroup();
    init_BatchableSprite();
    HTMLTextPipe = class {
      constructor(renderer) {
        this._gpuText = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
        this._renderer.runners.resolutionChange.add(this);
      }
      resolutionChange() {
        for (const i2 in this._gpuText) {
          const gpuText = this._gpuText[i2];
          const text = gpuText.batchableSprite.renderable;
          if (text._autoResolution) {
            text._resolution = this._renderer.resolution;
            text.onViewUpdate();
          }
        }
      }
      validateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const newKey = htmlText._getKey();
        if (gpuText.textureNeedsUploading) {
          gpuText.textureNeedsUploading = false;
          return true;
        }
        if (gpuText.currentKey !== newKey) {
          return true;
        }
        return false;
      }
      addRenderable(htmlText, _instructionSet) {
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (htmlText._didTextUpdate) {
          this._updateText(htmlText);
        }
        this._renderer.renderPipes.batch.addToBatch(batchableSprite);
      }
      updateRenderable(htmlText) {
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (htmlText._didTextUpdate) {
          this._updateText(htmlText);
        }
        batchableSprite.batcher.updateElement(batchableSprite);
      }
      destroyRenderable(htmlText) {
        htmlText.off("destroyed", this._destroyRenderableBound);
        this._destroyRenderableById(htmlText.uid);
      }
      _destroyRenderableById(htmlTextUid) {
        const gpuText = this._gpuText[htmlTextUid];
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        BigPool.return(gpuText.batchableSprite);
        this._gpuText[htmlTextUid] = null;
      }
      _updateText(htmlText) {
        const newKey = htmlText._getKey();
        const gpuText = this._getGpuText(htmlText);
        const batchableSprite = gpuText.batchableSprite;
        if (gpuText.currentKey !== newKey) {
          this._updateGpuText(htmlText).catch((e3) => {
            console.error(e3);
          });
        }
        htmlText._didTextUpdate = false;
        const padding = htmlText._style.padding;
        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
      }
      async _updateGpuText(htmlText) {
        htmlText._didTextUpdate = false;
        const gpuText = this._getGpuText(htmlText);
        if (gpuText.generatingTexture)
          return;
        const newKey = htmlText._getKey();
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        gpuText.generatingTexture = true;
        gpuText.currentKey = newKey;
        const resolution = htmlText.resolution ?? this._renderer.resolution;
        const texture = await this._renderer.htmlText.getManagedTexture(
          htmlText.text,
          resolution,
          htmlText._style,
          htmlText._getKey()
        );
        const batchableSprite = gpuText.batchableSprite;
        batchableSprite.texture = gpuText.texture = texture;
        gpuText.generatingTexture = false;
        gpuText.textureNeedsUploading = true;
        htmlText.onViewUpdate();
        const padding = htmlText._style.padding;
        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);
      }
      _getGpuText(htmlText) {
        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
      }
      initGpuText(htmlText) {
        const gpuTextData = {
          texture: Texture.EMPTY,
          currentKey: "--",
          batchableSprite: BigPool.get(BatchableSprite),
          textureNeedsUploading: false,
          generatingTexture: false
        };
        const batchableSprite = gpuTextData.batchableSprite;
        batchableSprite.renderable = htmlText;
        batchableSprite.texture = Texture.EMPTY;
        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
        batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
        this._gpuText[htmlText.uid] = gpuTextData;
        htmlText.on("destroyed", this._destroyRenderableBound);
        return gpuTextData;
      }
      destroy() {
        for (const i2 in this._gpuText) {
          this._destroyRenderableById(i2);
        }
        this._gpuText = null;
        this._renderer = null;
      }
    };
    HTMLTextPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "htmlText"
    };
  }
});

// node_modules/pixi.js/lib/utils/browser/isSafari.mjs
function isSafari() {
  const { userAgent } = DOMAdapter.get().getNavigator();
  return /^((?!chrome|android).)*safari/i.test(userAgent);
}
var init_isSafari = __esm({
  "node_modules/pixi.js/lib/utils/browser/isSafari.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs
var nssvg, nsxhtml, HTMLTextRenderData;
var init_HTMLTextRenderData = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs"() {
    "use strict";
    nssvg = "http://www.w3.org/2000/svg";
    nsxhtml = "http://www.w3.org/1999/xhtml";
    HTMLTextRenderData = class {
      constructor() {
        this.svgRoot = document.createElementNS(nssvg, "svg");
        this.foreignObject = document.createElementNS(nssvg, "foreignObject");
        this.domElement = document.createElementNS(nsxhtml, "div");
        this.styleElement = document.createElementNS(nsxhtml, "style");
        this.image = new Image();
        const { foreignObject, svgRoot, styleElement, domElement } = this;
        foreignObject.setAttribute("width", "10000");
        foreignObject.setAttribute("height", "10000");
        foreignObject.style.overflow = "hidden";
        svgRoot.appendChild(foreignObject);
        foreignObject.appendChild(styleElement);
        foreignObject.appendChild(domElement);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs
function textStyleToCSS(style) {
  const stroke = style._stroke;
  const fill = style._fill;
  const cssStyleString = [
    `color: ${Color.shared.setValue(fill.color).toHex()}`,
    `font-size: ${style.fontSize}px`,
    `font-family: ${style.fontFamily}`,
    `font-weight: ${style.fontWeight}`,
    `font-style: ${style.fontStyle}`,
    `font-variant: ${style.fontVariant}`,
    `letter-spacing: ${style.letterSpacing}px`,
    `text-align: ${style.align}`,
    `padding: ${style.padding}px`,
    `white-space: ${style.whiteSpace === "pre" && style.wordWrap ? "pre-wrap" : style.whiteSpace}`,
    ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],
    ...style.wordWrap ? [
      `word-wrap: ${style.breakWords ? "break-all" : "break-word"}`,
      `max-width: ${style.wordWrapWidth}px`
    ] : [],
    ...stroke ? [strokeToCSS(stroke)] : [],
    ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],
    ...style.cssOverrides
  ].join(";");
  const cssStyles = [`div { ${cssStyleString} }`];
  tagStyleToCSS(style.tagStyles, cssStyles);
  return cssStyles.join(" ");
}
function dropShadowToCSS(dropShadowStyle) {
  const color2 = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();
  const x5 = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);
  const y4 = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);
  const position = `${x5}px ${y4}px`;
  if (dropShadowStyle.blur > 0) {
    return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color2}`;
  }
  return `text-shadow: ${position} ${color2}`;
}
function strokeToCSS(stroke) {
  return [
    `-webkit-text-stroke-width: ${stroke.width}px`,
    `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    `text-stroke-width: ${stroke.width}px`,
    `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,
    "paint-order: stroke"
  ].join(";");
}
function tagStyleToCSS(tagStyles, out2) {
  for (const i2 in tagStyles) {
    const tagStyle = tagStyles[i2];
    const cssTagStyle = [];
    for (const j3 in tagStyle) {
      if (transform[j3]) {
        cssTagStyle.push(transform[j3](tagStyle[j3]));
      } else if (templates[j3]) {
        cssTagStyle.push(templates[j3].replace("{{VALUE}}", tagStyle[j3]));
      }
    }
    out2.push(`${i2} { ${cssTagStyle.join(";")} }`);
  }
}
var templates, transform;
var init_textStyleToCSS = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/textStyleToCSS.mjs"() {
    init_Color();
    templates = {
      fontSize: `font-size: {{VALUE}}px`,
      fontFamily: `font-family: {{VALUE}}`,
      fontWeight: `font-weight: {{VALUE}}`,
      fontStyle: `font-style: {{VALUE}}`,
      fontVariant: `font-variant: {{VALUE}}`,
      letterSpacing: `letter-spacing: {{VALUE}}px`,
      align: `text-align: {{VALUE}}`,
      padding: `padding: {{VALUE}}px`,
      whiteSpace: `white-space: {{VALUE}}`,
      lineHeight: `line-height: {{VALUE}}px`,
      wordWrapWidth: `max-width: {{VALUE}}px`
    };
    transform = {
      fill: (value) => `color: ${Color.shared.setValue(value).toHex()}`,
      breakWords: (value) => `word-wrap: ${value ? "break-all" : "break-word"}`,
      stroke: strokeToCSS,
      dropShadow: dropShadowToCSS
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs
var HTMLTextStyle;
var init_HtmlTextStyle = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HtmlTextStyle.mjs"() {
    init_warn();
    init_TextStyle();
    init_generateTextStyleKey();
    init_textStyleToCSS();
    HTMLTextStyle = class _HTMLTextStyle extends TextStyle {
      constructor(options = {}) {
        super(options);
        this._cssOverrides = [];
        this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
        this.tagStyles = options.tagStyles ?? {};
      }
      /** List of style overrides that will be applied to the HTML text. */
      set cssOverrides(value) {
        this._cssOverrides = value instanceof Array ? value : [value];
        this.update();
      }
      get cssOverrides() {
        return this._cssOverrides;
      }
      _generateKey() {
        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join("-");
        return this._styleKey;
      }
      update() {
        this._cssStyle = null;
        super.update();
      }
      /**
       * Creates a new HTMLTextStyle object with the same values as this one.
       * @returns New cloned HTMLTextStyle object
       */
      clone() {
        return new _HTMLTextStyle({
          align: this.align,
          breakWords: this.breakWords,
          dropShadow: this.dropShadow ? { ...this.dropShadow } : null,
          fill: this._fill,
          fontFamily: this.fontFamily,
          fontSize: this.fontSize,
          fontStyle: this.fontStyle,
          fontVariant: this.fontVariant,
          fontWeight: this.fontWeight,
          letterSpacing: this.letterSpacing,
          lineHeight: this.lineHeight,
          padding: this.padding,
          stroke: this._stroke,
          whiteSpace: this.whiteSpace,
          wordWrap: this.wordWrap,
          wordWrapWidth: this.wordWrapWidth,
          cssOverrides: this.cssOverrides
        });
      }
      get cssStyle() {
        if (!this._cssStyle) {
          this._cssStyle = textStyleToCSS(this);
        }
        return this._cssStyle;
      }
      /**
       * Add a style override, this can be any CSS property
       * it will override any built-in style. This is the
       * property and the value as a string (e.g., `color: red`).
       * This will override any other internal style.
       * @param {string} value - CSS style(s) to add.
       * @example
       * style.addOverride('background-color: red');
       */
      addOverride(...value) {
        const toAdd = value.filter((v3) => !this.cssOverrides.includes(v3));
        if (toAdd.length > 0) {
          this.cssOverrides.push(...toAdd);
          this.update();
        }
      }
      /**
       * Remove any overrides that match the value.
       * @param {string} value - CSS style to remove.
       * @example
       * style.removeOverride('background-color: red');
       */
      removeOverride(...value) {
        const toRemove = value.filter((v3) => this.cssOverrides.includes(v3));
        if (toRemove.length > 0) {
          this.cssOverrides = this.cssOverrides.filter((v3) => !toRemove.includes(v3));
          this.update();
        }
      }
      set fill(value) {
        if (typeof value !== "string" && typeof value !== "number") {
          warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
        }
        super.fill = value;
      }
      set stroke(value) {
        if (value && typeof value !== "string" && typeof value !== "number") {
          warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
        }
        super.stroke = value;
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs
function extractFontFamilies(text, style) {
  const fontFamily = style.fontFamily;
  const fontFamilies = [];
  const dedupe = {};
  const regex = /font-family:([^;"\s]+)/g;
  const matches = text.match(regex);
  function addFontFamily(fontFamily2) {
    if (!dedupe[fontFamily2]) {
      fontFamilies.push(fontFamily2);
      dedupe[fontFamily2] = true;
    }
  }
  if (Array.isArray(fontFamily)) {
    for (let i2 = 0; i2 < fontFamily.length; i2++) {
      addFontFamily(fontFamily[i2]);
    }
  } else {
    addFontFamily(fontFamily);
  }
  if (matches) {
    matches.forEach((match) => {
      const fontFamily2 = match.split(":")[1].trim();
      addFontFamily(fontFamily2);
    });
  }
  for (const i2 in style.tagStyles) {
    const fontFamily2 = style.tagStyles[i2].fontFamily;
    addFontFamily(fontFamily2);
  }
  return fontFamilies;
}
var init_extractFontFamilies = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs
async function loadFontAsBase64(url) {
  const response = await DOMAdapter.get().fetch(url);
  const blob = await response.blob();
  const reader = new FileReader();
  const dataSrc = await new Promise((resolve, reject) => {
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
  return dataSrc;
}
var init_loadFontAsBase64 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs
async function loadFontCSS(style, url) {
  const dataSrc = await loadFontAsBase64(url);
  return `@font-face {
        font-family: "${style.fontFamily}";
        src: url('${dataSrc}');
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
    }`;
}
var init_loadFontCSS = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs"() {
    init_loadFontAsBase64();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs
async function getFontCss(fontFamilies, style, defaultOptions) {
  const fontPromises = fontFamilies.filter((fontFamily) => Cache.has(`${fontFamily}-and-url`)).map((fontFamily, i2) => {
    if (!FontStylePromiseCache.has(fontFamily)) {
      const { url } = Cache.get(`${fontFamily}-and-url`);
      if (i2 === 0) {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          fontWeight: style.fontWeight,
          fontStyle: style.fontStyle,
          fontFamily
        }, url));
      } else {
        FontStylePromiseCache.set(fontFamily, loadFontCSS({
          fontWeight: defaultOptions.fontWeight,
          fontStyle: defaultOptions.fontStyle,
          fontFamily
        }, url));
      }
    }
    return FontStylePromiseCache.get(fontFamily);
  });
  return (await Promise.all(fontPromises)).join("\n");
}
var FontStylePromiseCache;
var init_getFontCss = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs"() {
    init_Cache();
    init_loadFontCSS();
    FontStylePromiseCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs
function getSVGUrl(text, style, resolution, fontCSS, htmlTextData) {
  const { domElement, styleElement, svgRoot } = htmlTextData;
  domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;
  domElement.setAttribute("style", `transform: scale(${resolution});transform-origin: top left; display: inline-block`);
  styleElement.textContent = fontCSS;
  const { width, height } = htmlTextData.image;
  svgRoot.setAttribute("width", width.toString());
  svgRoot.setAttribute("height", height.toString());
  return new XMLSerializer().serializeToString(svgRoot);
}
var init_getSVGUrl = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs
function getTemporaryCanvasFromImage(image, resolution) {
  const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
    image.width,
    image.height,
    resolution
  );
  const { context: context2 } = canvasAndContext;
  context2.clearRect(0, 0, image.width, image.height);
  context2.drawImage(image, 0, 0);
  CanvasPool.returnCanvasAndContext(canvasAndContext);
  return canvasAndContext.canvas;
}
var init_getTemporaryCanvasFromImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs"() {
    init_CanvasPool();
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs
function loadSVGImage(image, url, delay) {
  return new Promise(async (resolve) => {
    if (delay) {
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    image.onload = () => {
      resolve();
    };
    image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;
    image.crossOrigin = "anonymous";
  });
}
var init_loadSVGImage = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs
function measureHtmlText(text, style, fontStyleCSS, htmlTextRenderData) {
  htmlTextRenderData = htmlTextRenderData || tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());
  const { domElement, styleElement, svgRoot } = htmlTextRenderData;
  domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;
  domElement.setAttribute("style", "transform-origin: top left; display: inline-block");
  if (fontStyleCSS) {
    styleElement.textContent = fontStyleCSS;
  }
  document.body.appendChild(svgRoot);
  const contentBounds = domElement.getBoundingClientRect();
  svgRoot.remove();
  const descenderPadding = CanvasTextMetrics.measureFont(style.fontStyle).descent;
  const doublePadding = style.padding * 2;
  return {
    width: contentBounds.width - doublePadding,
    height: contentBounds.height + descenderPadding - doublePadding
  };
}
var tempHTMLTextRenderData;
var init_measureHtmlText = __esm({
  "node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs"() {
    init_CanvasTextMetrics();
    init_HTMLTextRenderData();
  }
});

// node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs
var HTMLTextSystem;
var init_HTMLTextSystem = __esm({
  "node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs"() {
    init_Extensions();
    init_TexturePool();
    init_types2();
    init_isSafari();
    init_warn();
    init_PoolGroup();
    init_getPo2TextureFromSource();
    init_HTMLTextRenderData();
    init_HtmlTextStyle();
    init_extractFontFamilies();
    init_getFontCss();
    init_getSVGUrl();
    init_getTemporaryCanvasFromImage();
    init_loadSVGImage();
    init_measureHtmlText();
    HTMLTextSystem = class {
      constructor(renderer) {
        this._activeTextures = {};
        this._renderer = renderer;
        this._createCanvas = renderer.type === RendererType.WEBGPU;
      }
      getTexture(options) {
        return this._buildTexturePromise(
          options.text,
          options.resolution,
          options.style
        );
      }
      getManagedTexture(text, resolution, style, textKey) {
        if (this._activeTextures[textKey]) {
          this._increaseReferenceCount(textKey);
          return this._activeTextures[textKey].promise;
        }
        const promise2 = this._buildTexturePromise(text, resolution, style).then((texture) => {
          this._activeTextures[textKey].texture = texture;
          return texture;
        });
        this._activeTextures[textKey] = {
          texture: null,
          promise: promise2,
          usageCount: 1
        };
        return promise2;
      }
      async _buildTexturePromise(text, resolution, style) {
        const htmlTextData = BigPool.get(HTMLTextRenderData);
        const fontFamilies = extractFontFamilies(text, style);
        const fontCSS = await getFontCss(
          fontFamilies,
          style,
          HTMLTextStyle.defaultTextStyle
        );
        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);
        const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + style.padding * 2) * resolution);
        const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + style.padding * 2) * resolution);
        const image = htmlTextData.image;
        const uvSafeOffset = 2;
        image.width = (width | 0) + uvSafeOffset;
        image.height = (height | 0) + uvSafeOffset;
        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);
        let resource = image;
        if (this._createCanvas) {
          resource = getTemporaryCanvasFromImage(image, resolution);
        }
        const texture = getPo2TextureFromSource(
          resource,
          image.width - uvSafeOffset,
          image.height - uvSafeOffset,
          resolution
        );
        if (this._createCanvas) {
          this._renderer.texture.initSource(texture.source);
        }
        BigPool.return(htmlTextData);
        return texture;
      }
      _increaseReferenceCount(textKey) {
        this._activeTextures[textKey].usageCount++;
      }
      decreaseReferenceCount(textKey) {
        const activeTexture = this._activeTextures[textKey];
        if (!activeTexture)
          return;
        activeTexture.usageCount--;
        if (activeTexture.usageCount === 0) {
          if (activeTexture.texture) {
            this._cleanUp(activeTexture);
          } else {
            activeTexture.promise.then((texture) => {
              activeTexture.texture = texture;
              this._cleanUp(activeTexture);
            }).catch(() => {
              warn("HTMLTextSystem: Failed to clean texture");
            });
          }
          this._activeTextures[textKey] = null;
        }
      }
      _cleanUp(activeTexture) {
        TexturePool.returnTexture(activeTexture.texture);
        activeTexture.texture.source.resource = null;
        activeTexture.texture.source.uploadMethodId = "unknown";
      }
      getReferenceCount(textKey) {
        return this._activeTextures[textKey].usageCount;
      }
      destroy() {
        this._activeTextures = null;
      }
    };
    HTMLTextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "htmlText"
    };
    HTMLTextSystem.defaultFontOptions = {
      fontFamily: "Arial",
      fontStyle: "normal",
      fontWeight: "normal"
    };
  }
});

// node_modules/pixi.js/lib/scene/text-html/init.mjs
var init_init10 = __esm({
  "node_modules/pixi.js/lib/scene/text-html/init.mjs"() {
    init_Extensions();
    init_HTMLTextPipe();
    init_HTMLTextSystem();
    extensions.add(HTMLTextSystem);
    extensions.add(HTMLTextPipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs
var _MeshGeometry, MeshGeometry;
var init_MeshGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs"() {
    init_Buffer();
    init_const4();
    init_Geometry();
    init_deprecation();
    _MeshGeometry = class _MeshGeometry2 extends Geometry {
      constructor(...args) {
        let options = args[0] ?? {};
        if (options instanceof Float32Array) {
          deprecation(v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead");
          options = {
            positions: options,
            uvs: args[1],
            indices: args[2]
          };
        }
        options = { ..._MeshGeometry2.defaultOptions, ...options };
        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const uvs = options.uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
        const shrinkToFit = options.shrinkBuffersToFit;
        const positionBuffer = new Buffer2({
          data: positions,
          label: "attribute-mesh-positions",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const uvBuffer = new Buffer2({
          data: uvs,
          label: "attribute-mesh-uvs",
          shrinkToFit,
          usage: BufferUsage.VERTEX | BufferUsage.COPY_DST
        });
        const indexBuffer = new Buffer2({
          data: indices,
          label: "index-mesh-buffer",
          shrinkToFit,
          usage: BufferUsage.INDEX | BufferUsage.COPY_DST
        });
        super({
          attributes: {
            aPosition: {
              buffer: positionBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            },
            aUV: {
              buffer: uvBuffer,
              format: "float32x2",
              stride: 2 * 4,
              offset: 0
            }
          },
          indexBuffer,
          topology: options.topology
        });
        this.batchMode = "auto";
      }
      /** The positions of the mesh. */
      get positions() {
        return this.attributes.aPosition.buffer.data;
      }
      set positions(value) {
        this.attributes.aPosition.buffer.data = value;
      }
      /** The UVs of the mesh. */
      get uvs() {
        return this.attributes.aUV.buffer.data;
      }
      set uvs(value) {
        this.attributes.aUV.buffer.data = value;
      }
      /** The indices of the mesh. */
      get indices() {
        return this.indexBuffer.data;
      }
      set indices(value) {
        this.indexBuffer.data = value;
      }
    };
    _MeshGeometry.defaultOptions = {
      topology: "triangle-list",
      shrinkBuffersToFit: false
    };
    MeshGeometry = _MeshGeometry;
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs
var localUniformBit, localUniformBitGroup2, localUniformBitGl;
var init_localUniformBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs"() {
    "use strict";
    localUniformBit = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* wgsl */
          `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `
        ),
        end: (
          /* wgsl */
          `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        )
      }
    };
    localUniformBitGroup2 = {
      ...localUniformBit,
      vertex: {
        ...localUniformBit.vertex,
        // replace the group!
        header: localUniformBit.vertex.header.replace("group(1)", "group(2)")
      }
    };
    localUniformBitGl = {
      name: "local-uniform-bit",
      vertex: {
        header: (
          /* glsl */
          `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `
        ),
        main: (
          /* glsl */
          `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `
        ),
        end: (
          /* glsl */
          `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs
var tilingBit, tilingBitGl;
var init_tilingBit = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs"() {
    "use strict";
    tilingBit = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `
        ),
        main: (
          /* wgsl */
          `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        )
      }
    };
    tilingBitGl = {
      name: "tiling-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `
        ),
        main: (
          /* glsl */
          `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs
var gpuProgram2, glProgram2, TilingSpriteShader;
var init_TilingSpriteShader = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs"() {
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    init_Texture();
    init_tilingBit();
    TilingSpriteShader = class extends Shader {
      constructor() {
        gpuProgram2 ?? (gpuProgram2 = compileHighShaderGpuProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBit,
            tilingBit,
            roundPixelsBit
          ]
        }));
        glProgram2 ?? (glProgram2 = compileHighShaderGlProgram({
          name: "tiling-sprite-shader",
          bits: [
            localUniformBitGl,
            tilingBitGl,
            roundPixelsBitGl
          ]
        }));
        const tilingUniforms = new UniformGroup({
          uMapCoord: { value: new Matrix(), type: "mat3x3<f32>" },
          uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: "vec4<f32>" },
          uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
          uTextureTransform: { value: new Matrix(), type: "mat3x3<f32>" },
          uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: "vec4<f32>" }
        });
        super({
          glProgram: glProgram2,
          gpuProgram: gpuProgram2,
          resources: {
            localUniforms: new UniformGroup({
              uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
              uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
              uRound: { value: 0, type: "f32" }
            }),
            tilingUniforms,
            uTexture: Texture.EMPTY.source,
            uSampler: Texture.EMPTY.source.style
          }
        });
      }
      updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
        const tilingUniforms = this.resources.tilingUniforms;
        const textureWidth = texture.width;
        const textureHeight = texture.height;
        const textureMatrix = texture.textureMatrix;
        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
        uTextureTransform.set(
          matrix.a * textureWidth / width,
          matrix.b * textureWidth / height,
          matrix.c * textureHeight / width,
          matrix.d * textureHeight / height,
          matrix.tx / width,
          matrix.ty / height
        );
        uTextureTransform.invert();
        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
        tilingUniforms.uniforms.uSizeAnchor[0] = width;
        tilingUniforms.uniforms.uSizeAnchor[1] = height;
        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
        if (texture) {
          this.resources.uTexture = texture.source;
          this.resources.uSampler = texture.source.style;
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs
var QuadGeometry;
var init_QuadGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs"() {
    init_MeshGeometry();
    QuadGeometry = class extends MeshGeometry {
      constructor() {
        super({
          positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        });
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs
function setPositions(tilingSprite, positions) {
  const anchorX = tilingSprite.anchor.x;
  const anchorY = tilingSprite.anchor.y;
  positions[0] = -anchorX * tilingSprite.width;
  positions[1] = -anchorY * tilingSprite.height;
  positions[2] = (1 - anchorX) * tilingSprite.width;
  positions[3] = -anchorY * tilingSprite.height;
  positions[4] = (1 - anchorX) * tilingSprite.width;
  positions[5] = (1 - anchorY) * tilingSprite.height;
  positions[6] = -anchorX * tilingSprite.width;
  positions[7] = (1 - anchorY) * tilingSprite.height;
}
var init_setPositions = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs
function applyMatrix(array2, stride, offset, matrix) {
  let index2 = 0;
  const size = array2.length / (stride || 2);
  const a3 = matrix.a;
  const b2 = matrix.b;
  const c3 = matrix.c;
  const d3 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  offset *= stride;
  while (index2 < size) {
    const x5 = array2[offset];
    const y4 = array2[offset + 1];
    array2[offset] = a3 * x5 + c3 * y4 + tx;
    array2[offset + 1] = b2 * x5 + d3 * y4 + ty;
    offset += stride;
    index2++;
  }
}
var init_applyMatrix = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs
function setUvs(tilingSprite, uvs) {
  const texture = tilingSprite.texture;
  const width = texture.frame.width;
  const height = texture.frame.height;
  let anchorX = 0;
  let anchorY = 0;
  if (tilingSprite._applyAnchorToTexture) {
    anchorX = tilingSprite.anchor.x;
    anchorY = tilingSprite.anchor.y;
  }
  uvs[0] = uvs[6] = -anchorX;
  uvs[2] = uvs[4] = 1 - anchorX;
  uvs[1] = uvs[3] = -anchorY;
  uvs[5] = uvs[7] = 1 - anchorY;
  const textureMatrix = Matrix.shared;
  textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);
  textureMatrix.tx /= tilingSprite.width;
  textureMatrix.ty /= tilingSprite.height;
  textureMatrix.invert();
  textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);
  applyMatrix(uvs, 2, 0, textureMatrix);
}
var init_setUvs = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs"() {
    init_Matrix();
    init_applyMatrix();
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs
var sharedQuad, TilingSpritePipe;
var init_TilingSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs"() {
    init_Extensions();
    init_getAdjustedBlendModeBlend();
    init_State();
    init_types2();
    init_colorToUniform();
    init_BatchableMesh();
    init_MeshGeometry();
    init_TilingSpriteShader();
    init_QuadGeometry();
    init_setPositions();
    init_setUvs();
    sharedQuad = new QuadGeometry();
    TilingSpritePipe = class {
      constructor(renderer) {
        this._state = State.default2d;
        this._tilingSpriteDataHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
      }
      validateRenderable(renderable) {
        const tilingSpriteData = this._getTilingSpriteData(renderable);
        const couldBatch = tilingSpriteData.canBatch;
        this._updateCanBatch(renderable);
        const canBatch = tilingSpriteData.canBatch;
        if (canBatch && canBatch === couldBatch) {
          const { batchableMesh } = tilingSpriteData;
          if (batchableMesh && batchableMesh.texture._source !== renderable.texture._source) {
            return !batchableMesh.batcher.checkAndUpdateTexture(batchableMesh, renderable.texture);
          }
        }
        return couldBatch !== canBatch;
      }
      addRenderable(tilingSprite, instructionSet) {
        const batcher = this._renderer.renderPipes.batch;
        this._updateCanBatch(tilingSprite);
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { geometry, canBatch } = tilingSpriteData;
        if (canBatch) {
          tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh());
          const batchableMesh = tilingSpriteData.batchableMesh;
          if (tilingSprite._didTilingSpriteUpdate) {
            tilingSprite._didTilingSpriteUpdate = false;
            this._updateBatchableMesh(tilingSprite);
            batchableMesh.geometry = geometry;
            batchableMesh.mesh = tilingSprite;
            batchableMesh.texture = tilingSprite._texture;
          }
          batchableMesh.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels;
          batcher.addToBatch(batchableMesh);
        } else {
          batcher.break(instructionSet);
          tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader());
          this.updateRenderable(tilingSprite);
          instructionSet.add(tilingSprite);
        }
      }
      execute(tilingSprite) {
        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];
        shader.groups[0] = this._renderer.globalUniforms.bindGroup;
        const localUniforms = shader.resources.localUniforms.uniforms;
        localUniforms.uTransformMatrix = tilingSprite.groupTransform;
        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
        color32BitToUniform(
          tilingSprite.groupColorAlpha,
          localUniforms.uColor,
          0
        );
        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
        this._renderer.encoder.draw({
          geometry: sharedQuad,
          shader,
          state: this._state
        });
      }
      updateRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        const { canBatch } = tilingSpriteData;
        if (canBatch) {
          const { batchableMesh } = tilingSpriteData;
          if (tilingSprite._didTilingSpriteUpdate)
            this._updateBatchableMesh(tilingSprite);
          batchableMesh.batcher.updateElement(batchableMesh);
        } else if (tilingSprite._didTilingSpriteUpdate) {
          const { shader } = tilingSpriteData;
          shader.updateUniforms(
            tilingSprite.width,
            tilingSprite.height,
            tilingSprite._tileTransform.matrix,
            tilingSprite.anchor.x,
            tilingSprite.anchor.y,
            tilingSprite.texture
          );
        }
        tilingSprite._didTilingSpriteUpdate = false;
      }
      destroyRenderable(tilingSprite) {
        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
        tilingSpriteData.batchableMesh = null;
        tilingSpriteData.shader?.destroy();
        this._tilingSpriteDataHash[tilingSprite.uid] = null;
        tilingSprite.off("destroyed", this._destroyRenderableBound);
      }
      _getTilingSpriteData(renderable) {
        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
      }
      _initTilingSpriteData(tilingSprite) {
        const geometry = new MeshGeometry({
          indices: sharedQuad.indices,
          positions: sharedQuad.positions.slice(),
          uvs: sharedQuad.uvs.slice()
        });
        this._tilingSpriteDataHash[tilingSprite.uid] = {
          canBatch: true,
          renderable: tilingSprite,
          geometry
        };
        tilingSprite.on("destroyed", this._destroyRenderableBound);
        return this._tilingSpriteDataHash[tilingSprite.uid];
      }
      _updateBatchableMesh(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const { geometry } = renderableData;
        const style = tilingSprite.texture.source.style;
        if (style.addressMode !== "repeat") {
          style.addressMode = "repeat";
          style.update();
        }
        setUvs(tilingSprite, geometry.uvs);
        setPositions(tilingSprite, geometry.positions);
      }
      destroy() {
        for (const i2 in this._tilingSpriteDataHash) {
          this.destroyRenderable(this._tilingSpriteDataHash[i2].renderable);
        }
        this._tilingSpriteDataHash = null;
        this._renderer = null;
      }
      _updateCanBatch(tilingSprite) {
        const renderableData = this._getTilingSpriteData(tilingSprite);
        const texture = tilingSprite.texture;
        let _nonPowOf2wrapping = true;
        if (this._renderer.type === RendererType.WEBGL) {
          _nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping;
        }
        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);
        return renderableData.canBatch;
      }
    };
    TilingSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "tilingSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs
var init_init11 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs"() {
    init_Extensions();
    init_TilingSpritePipe();
    extensions.add(TilingSpritePipe);
  }
});

// node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs
var _PlaneGeometry, PlaneGeometry;
var init_PlaneGeometry = __esm({
  "node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs"() {
    init_deprecation();
    init_MeshGeometry();
    _PlaneGeometry = class _PlaneGeometry2 extends MeshGeometry {
      constructor(...args) {
        super({});
        let options = args[0] ?? {};
        if (typeof options === "number") {
          deprecation(v8_0_0, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead");
          options = {
            width: options,
            height: args[1],
            verticesX: args[2],
            verticesY: args[3]
          };
        }
        this.build(options);
      }
      /**
       * Refreshes plane coordinates
       * @param options - Options to be applied to plane geometry
       */
      build(options) {
        options = { ..._PlaneGeometry2.defaultOptions, ...options };
        this.verticesX = this.verticesX ?? options.verticesX;
        this.verticesY = this.verticesY ?? options.verticesY;
        this.width = this.width ?? options.width;
        this.height = this.height ?? options.height;
        const total = this.verticesX * this.verticesY;
        const verts = [];
        const uvs = [];
        const indices = [];
        const verticesX = this.verticesX - 1;
        const verticesY = this.verticesY - 1;
        const sizeX = this.width / verticesX;
        const sizeY = this.height / verticesY;
        for (let i2 = 0; i2 < total; i2++) {
          const x5 = i2 % this.verticesX;
          const y4 = i2 / this.verticesX | 0;
          verts.push(x5 * sizeX, y4 * sizeY);
          uvs.push(x5 / verticesX, y4 / verticesY);
        }
        const totalSub = verticesX * verticesY;
        for (let i2 = 0; i2 < totalSub; i2++) {
          const xpos = i2 % verticesX;
          const ypos = i2 / verticesX | 0;
          const value = ypos * this.verticesX + xpos;
          const value2 = ypos * this.verticesX + xpos + 1;
          const value3 = (ypos + 1) * this.verticesX + xpos;
          const value4 = (ypos + 1) * this.verticesX + xpos + 1;
          indices.push(
            value,
            value2,
            value3,
            value2,
            value4,
            value3
          );
        }
        this.buffers[0].data = new Float32Array(verts);
        this.buffers[1].data = new Float32Array(uvs);
        this.indexBuffer.data = new Uint32Array(indices);
        this.buffers[0].update();
        this.buffers[1].update();
        this.indexBuffer.update();
      }
    };
    _PlaneGeometry.defaultOptions = {
      width: 100,
      height: 100,
      verticesX: 10,
      verticesY: 10
    };
    PlaneGeometry = _PlaneGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs
var _NineSliceGeometry, NineSliceGeometry;
var init_NineSliceGeometry = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs"() {
    init_PlaneGeometry();
    _NineSliceGeometry = class _NineSliceGeometry2 extends PlaneGeometry {
      constructor(options = {}) {
        options = { ..._NineSliceGeometry2.defaultOptions, ...options };
        super({
          width: options.width,
          height: options.height,
          verticesX: 4,
          verticesY: 4
        });
        this.update(options);
      }
      /**
       * Updates the NineSliceGeometry with the options.
       * @param options - The options of the NineSliceGeometry.
       */
      update(options) {
        this.width = options.width ?? this.width;
        this.height = options.height ?? this.height;
        this._originalWidth = options.originalWidth ?? this._originalWidth;
        this._originalHeight = options.originalHeight ?? this._originalHeight;
        this._leftWidth = options.leftWidth ?? this._leftWidth;
        this._rightWidth = options.rightWidth ?? this._rightWidth;
        this._topHeight = options.topHeight ?? this._topHeight;
        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;
        this.updateUvs();
        this.updatePositions();
      }
      /** Updates the positions of the vertices. */
      updatePositions() {
        const positions = this.positions;
        const w2 = this._leftWidth + this._rightWidth;
        const scaleW = this.width > w2 ? 1 : this.width / w2;
        const h2 = this._topHeight + this._bottomHeight;
        const scaleH = this.height > h2 ? 1 : this.height / h2;
        const scale = Math.min(scaleW, scaleH);
        positions[9] = positions[11] = positions[13] = positions[15] = this._topHeight * scale;
        positions[17] = positions[19] = positions[21] = positions[23] = this.height - this._bottomHeight * scale;
        positions[25] = positions[27] = positions[29] = positions[31] = this.height;
        positions[2] = positions[10] = positions[18] = positions[26] = this._leftWidth * scale;
        positions[4] = positions[12] = positions[20] = positions[28] = this.width - this._rightWidth * scale;
        positions[6] = positions[14] = positions[22] = positions[30] = this.width;
        this.getBuffer("aPosition").update();
      }
      /** Updates the UVs of the vertices. */
      updateUvs() {
        const uvs = this.uvs;
        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;
        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;
        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
        const _uvw = 1 / this._originalWidth;
        const _uvh = 1 / this._originalHeight;
        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;
        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;
        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _uvw * this._rightWidth;
        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _uvh * this._bottomHeight;
        this.getBuffer("aUV").update();
      }
    };
    _NineSliceGeometry.defaultOptions = {
      /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      width: 100,
      /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
      height: 100,
      /** The width of the left column. */
      leftWidth: 10,
      /** The height of the top row. */
      topHeight: 10,
      /** The width of the right column. */
      rightWidth: 10,
      /** The height of the bottom row. */
      bottomHeight: 10,
      /** The original width of the texture */
      originalWidth: 100,
      /** The original height of the texture */
      originalHeight: 100
    };
    NineSliceGeometry = _NineSliceGeometry;
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs
var NineSliceSpritePipe;
var init_NineSliceSpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableMesh();
    init_NineSliceGeometry();
    NineSliceSpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
      }
      addRenderable(sprite, _instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite._didSpriteUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._gpuSpriteHash[sprite.uid];
        if (sprite._didSpriteUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite.batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const texture = sprite._texture;
        const gpuSprite = this._getGpuSprite(sprite);
        if (gpuSprite.texture._source !== texture._source) {
          return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
        }
        return false;
      }
      destroyRenderable(sprite) {
        const batchableMesh = this._gpuSpriteHash[sprite.uid];
        BigPool.return(batchableMesh.geometry);
        BigPool.return(batchableMesh);
        this._gpuSpriteHash[sprite.uid] = null;
        sprite.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        sprite._didSpriteUpdate = false;
        batchableSprite.geometry.update(sprite);
        batchableSprite.texture = sprite._texture;
      }
      _getGpuSprite(sprite) {
        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const batchableMesh = BigPool.get(BatchableMesh);
        batchableMesh.geometry = BigPool.get(NineSliceGeometry);
        batchableMesh.mesh = sprite;
        batchableMesh.texture = sprite._texture;
        batchableMesh.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        sprite._didSpriteUpdate = true;
        this._gpuSpriteHash[sprite.uid] = batchableMesh;
        sprite.on("destroyed", this._destroyRenderableBound);
        return batchableMesh;
      }
      destroy() {
        for (const i2 in this._gpuSpriteHash) {
          const batchableMesh = this._gpuSpriteHash[i2];
          batchableMesh.geometry.destroy();
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    NineSliceSpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "nineSliceSprite"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs
var init_init12 = __esm({
  "node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs"() {
    init_Extensions();
    init_NineSliceSpritePipe();
    extensions.add(NineSliceSpritePipe);
  }
});

// node_modules/pixi.js/lib/filters/FilterPipe.mjs
var FilterPipe;
var init_FilterPipe = __esm({
  "node_modules/pixi.js/lib/filters/FilterPipe.mjs"() {
    init_Extensions();
    FilterPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      push(filterEffect, container, instructionSet) {
        const renderPipes3 = this._renderer.renderPipes;
        renderPipes3.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          canBundle: false,
          action: "pushFilter",
          container,
          filterEffect
        });
      }
      pop(_filterEffect, _container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      execute(instruction) {
        if (instruction.action === "pushFilter") {
          this._renderer.filter.push(instruction);
        } else if (instruction.action === "popFilter") {
          this._renderer.filter.pop();
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    FilterPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs
function getFastGlobalBounds(target, bounds) {
  bounds.clear();
  _getGlobalBoundsRecursive(target, bounds);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  if (!target.renderGroup) {
    bounds.applyMatrix(target.parentRenderGroup.worldTransform);
  } else {
    bounds.applyMatrix(target.renderGroup.localTransform);
  }
  return bounds;
}
function _getGlobalBoundsRecursive(target, bounds) {
  if (target.localDisplayStatus !== 7 || !target.measurable) {
    return;
  }
  const manageEffects = !!target.effects.length;
  let localBounds = bounds;
  if (target.renderGroup || manageEffects) {
    localBounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, target.worldTransform);
  } else {
    if (target.renderPipeId) {
      const viewBounds = target.bounds;
      localBounds.addFrame(
        viewBounds.minX,
        viewBounds.minY,
        viewBounds.maxX,
        viewBounds.maxY,
        target.groupTransform
      );
    }
    const children2 = target.children;
    for (let i2 = 0; i2 < children2.length; i2++) {
      _getGlobalBoundsRecursive(children2[i2], localBounds);
    }
  }
  if (manageEffects) {
    let advanced = false;
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      if (target.effects[i2].addBounds) {
        if (!advanced) {
          advanced = true;
          localBounds.applyMatrix(target.parentRenderGroup.worldTransform);
        }
        target.effects[i2].addBounds(localBounds, true);
      }
    }
    if (advanced) {
      localBounds.applyMatrix(target.parentRenderGroup.worldTransform.copyTo(tempMatrix4).invert());
      bounds.addBounds(localBounds, target.relativeGroupTransform);
    }
    bounds.addBounds(localBounds);
    boundsPool.return(localBounds);
  } else if (target.renderGroup) {
    bounds.addBounds(localBounds, target.relativeGroupTransform);
    boundsPool.return(localBounds);
  }
}
var tempMatrix4;
var init_getFastGlobalBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getFastGlobalBounds.mjs"() {
    init_Matrix();
    init_matrixAndBoundsPool();
    tempMatrix4 = new Matrix();
  }
});

// node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs
function getGlobalRenderableBounds(renderables, bounds) {
  bounds.clear();
  const tempMatrix6 = bounds.matrix;
  for (let i2 = 0; i2 < renderables.length; i2++) {
    const renderable = renderables[i2];
    if (renderable.globalDisplayStatus < 7) {
      continue;
    }
    bounds.matrix = renderable.worldTransform;
    renderable.addBounds(bounds);
  }
  bounds.matrix = tempMatrix6;
  return bounds;
}
var init_getRenderableBounds = __esm({
  "node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/filters/FilterSystem.mjs
var quadGeometry, FilterSystem;
var init_FilterSystem = __esm({
  "node_modules/pixi.js/lib/filters/FilterSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_BindGroup();
    init_Geometry();
    init_UniformGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    init_Bounds();
    init_getFastGlobalBounds();
    init_getRenderableBounds();
    init_warn();
    quadGeometry = new Geometry({
      attributes: {
        aPosition: {
          buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
          format: "float32x2",
          stride: 2 * 4,
          offset: 0
        }
      },
      indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
    });
    FilterSystem = class {
      constructor(renderer) {
        this._filterStackIndex = 0;
        this._filterStack = [];
        this._filterGlobalUniforms = new UniformGroup({
          uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" }
        });
        this._globalFilterBindGroup = new BindGroup({});
        this.renderer = renderer;
      }
      /**
       * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.
       * @readonly
       */
      get activeBackTexture() {
        return this._activeFilterData?.backTexture;
      }
      push(instruction) {
        const renderer = this.renderer;
        const filters = instruction.filterEffect.filters;
        if (!this._filterStack[this._filterStackIndex]) {
          this._filterStack[this._filterStackIndex] = this._getFilterData();
        }
        const filterData = this._filterStack[this._filterStackIndex];
        this._filterStackIndex++;
        if (filters.length === 0) {
          filterData.skip = true;
          return;
        }
        const bounds = filterData.bounds;
        if (instruction.renderables) {
          getGlobalRenderableBounds(instruction.renderables, bounds);
        } else if (instruction.filterEffect.filterArea) {
          bounds.clear();
          bounds.addRect(instruction.filterEffect.filterArea);
          bounds.applyMatrix(instruction.container.worldTransform);
        } else {
          getFastGlobalBounds(instruction.container, bounds);
        }
        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        let resolution = Infinity;
        let padding = 0;
        let antialias = true;
        let blendRequired = false;
        let enabled = false;
        for (let i2 = 0; i2 < filters.length; i2++) {
          const filter3 = filters[i2];
          resolution = Math.min(resolution, filter3.resolution === "inherit" ? colorTextureSource._resolution : filter3.resolution);
          padding += filter3.padding;
          if (filter3.antialias === "off") {
            antialias = false;
          } else if (filter3.antialias === "inherit") {
            antialias && (antialias = colorTextureSource.antialias);
          }
          const isCompatible = !!(filter3.compatibleRenderers & renderer.type);
          if (!isCompatible) {
            enabled = false;
            break;
          }
          if (filter3.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? true)) {
            warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = false;
            break;
          }
          enabled = filter3.enabled || enabled;
          blendRequired = blendRequired || filter3.blendRequired;
        }
        if (!enabled) {
          filterData.skip = true;
          return;
        }
        const viewPort = renderer.renderTarget.rootViewPort;
        bounds.scale(resolution).fitBounds(0, viewPort.width, 0, viewPort.height).ceil().scale(1 / resolution).pad(padding | 0);
        if (!bounds.isPositive) {
          filterData.skip = true;
          return;
        }
        filterData.skip = false;
        filterData.bounds = bounds;
        filterData.blendRequired = blendRequired;
        filterData.container = instruction.container;
        filterData.filterEffect = instruction.filterEffect;
        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;
        filterData.inputTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          resolution,
          antialias
        );
        renderer.renderTarget.bind(filterData.inputTexture, true);
        renderer.globalUniforms.push({
          offset: bounds
        });
      }
      pop() {
        const renderer = this.renderer;
        this._filterStackIndex--;
        const filterData = this._filterStack[this._filterStackIndex];
        if (filterData.skip) {
          return;
        }
        this._activeFilterData = filterData;
        const inputTexture = filterData.inputTexture;
        const bounds = filterData.bounds;
        let backTexture = Texture.EMPTY;
        renderer.renderTarget.finishRenderPass();
        if (filterData.blendRequired) {
          const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;
          const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
          backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);
        }
        filterData.backTexture = backTexture;
        const filters = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (filters.length === 1) {
          filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(inputTexture);
        } else {
          let flip = filterData.inputTexture;
          let flop = TexturePool.getOptimalTexture(
            bounds.width,
            bounds.height,
            flip.source._resolution,
            false
          );
          let i2 = 0;
          for (i2 = 0; i2 < filters.length - 1; ++i2) {
            const filter3 = filters[i2];
            filter3.apply(this, flip, flop, true);
            const t2 = flip;
            flip = flop;
            flop = t2;
          }
          filters[i2].apply(this, flip, filterData.previousRenderSurface, false);
          TexturePool.returnTexture(flip);
          TexturePool.returnTexture(flop);
        }
        if (filterData.blendRequired) {
          TexturePool.returnTexture(backTexture);
        }
      }
      getBackTexture(lastRenderSurface, bounds, previousBounds) {
        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;
        const backTexture = TexturePool.getOptimalTexture(
          bounds.width,
          bounds.height,
          backgroundResolution,
          false
        );
        let x5 = bounds.minX;
        let y4 = bounds.minY;
        if (previousBounds) {
          x5 -= previousBounds.minX;
          y4 -= previousBounds.minY;
        }
        x5 = Math.floor(x5 * backgroundResolution);
        y4 = Math.floor(y4 * backgroundResolution);
        const width = Math.ceil(bounds.width * backgroundResolution);
        const height = Math.ceil(bounds.height * backgroundResolution);
        this.renderer.renderTarget.copyToTexture(
          lastRenderSurface,
          backTexture,
          { x: x5, y: y4 },
          { width, height },
          { x: 0, y: 0 }
        );
        return backTexture;
      }
      applyFilter(filter3, input, output, clear) {
        const renderer = this.renderer;
        const filterData = this._filterStack[this._filterStackIndex];
        const bounds = filterData.bounds;
        const offset = Point.shared;
        const previousRenderSurface = filterData.previousRenderSurface;
        const isFinalTarget = previousRenderSurface === output;
        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
        let currentIndex = this._filterStackIndex - 1;
        while (currentIndex > 0 && this._filterStack[currentIndex].skip) {
          --currentIndex;
        }
        if (currentIndex > 0) {
          resolution = this._filterStack[currentIndex].inputTexture.source._resolution;
        }
        const filterUniforms = this._filterGlobalUniforms;
        const uniforms = filterUniforms.uniforms;
        const outputFrame = uniforms.uOutputFrame;
        const inputSize = uniforms.uInputSize;
        const inputPixel = uniforms.uInputPixel;
        const inputClamp = uniforms.uInputClamp;
        const globalFrame = uniforms.uGlobalFrame;
        const outputTexture = uniforms.uOutputTexture;
        if (isFinalTarget) {
          let lastIndex = this._filterStackIndex;
          while (lastIndex > 0) {
            lastIndex--;
            const filterData2 = this._filterStack[this._filterStackIndex - 1];
            if (!filterData2.skip) {
              offset.x = filterData2.bounds.minX;
              offset.y = filterData2.bounds.minY;
              break;
            }
          }
          outputFrame[0] = bounds.minX - offset.x;
          outputFrame[1] = bounds.minY - offset.y;
        } else {
          outputFrame[0] = 0;
          outputFrame[1] = 0;
        }
        outputFrame[2] = input.frame.width;
        outputFrame[3] = input.frame.height;
        inputSize[0] = input.source.width;
        inputSize[1] = input.source.height;
        inputSize[2] = 1 / inputSize[0];
        inputSize[3] = 1 / inputSize[1];
        inputPixel[0] = input.source.pixelWidth;
        inputPixel[1] = input.source.pixelHeight;
        inputPixel[2] = 1 / inputPixel[0];
        inputPixel[3] = 1 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
        inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        globalFrame[0] = offset.x * resolution;
        globalFrame[1] = offset.y * resolution;
        globalFrame[2] = rootTexture.source.width * resolution;
        globalFrame[3] = rootTexture.source.height * resolution;
        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);
        renderer.renderTarget.bind(output, !!clear);
        if (output instanceof Texture) {
          outputTexture[0] = output.frame.width;
          outputTexture[1] = output.frame.height;
        } else {
          outputTexture[0] = renderTarget.width;
          outputTexture[1] = renderTarget.height;
        }
        outputTexture[2] = renderTarget.isRoot ? -1 : 1;
        filterUniforms.update();
        if (renderer.renderPipes.uniformBatch) {
          const batchUniforms = renderer.renderPipes.uniformBatch.getUboResource(filterUniforms);
          this._globalFilterBindGroup.setResource(batchUniforms, 0);
        } else {
          this._globalFilterBindGroup.setResource(filterUniforms, 0);
        }
        this._globalFilterBindGroup.setResource(input.source, 1);
        this._globalFilterBindGroup.setResource(input.source.style, 2);
        filter3.groups[0] = this._globalFilterBindGroup;
        renderer.encoder.draw({
          geometry: quadGeometry,
          shader: filter3,
          state: filter3._state,
          topology: "triangle-list"
        });
        if (renderer.type === RendererType.WEBGL) {
          renderer.renderTarget.finishRenderPass();
        }
      }
      _getFilterData() {
        return {
          skip: false,
          inputTexture: null,
          bounds: new Bounds(),
          container: null,
          filterEffect: null,
          blendRequired: false,
          previousRenderSurface: null
        };
      }
      /**
       * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.
       *
       * Use `outputMatrix * vTextureCoord` in the shader.
       * @param outputMatrix - The matrix to output to.
       * @param {Sprite} sprite - The sprite to map to.
       * @returns The mapped matrix.
       */
      calculateSpriteMatrix(outputMatrix, sprite) {
        const data = this._activeFilterData;
        const mappedMatrix = outputMatrix.set(
          data.inputTexture._source.width,
          0,
          0,
          data.inputTexture._source.height,
          data.bounds.minX,
          data.bounds.minY
        );
        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(
          1 / sprite.texture.frame.width,
          1 / sprite.texture.frame.height
        );
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
      }
    };
    FilterSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "filter"
    };
  }
});

// node_modules/pixi.js/lib/filters/init.mjs
var init_init13 = __esm({
  "node_modules/pixi.js/lib/filters/init.mjs"() {
    init_Extensions();
    init_FilterPipe();
    init_FilterSystem();
    extensions.add(FilterSystem);
    extensions.add(FilterPipe);
  }
});

// node_modules/pixi.js/lib/environment-browser/browserAll.mjs
var browserAll_exports = {};
var init_browserAll = __esm({
  "node_modules/pixi.js/lib/environment-browser/browserAll.mjs"() {
    init_init();
    init_init2();
    init_init3();
    init_init4();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
  }
});

// node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs
var webworkerAll_exports = {};
var init_webworkerAll = __esm({
  "node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs"() {
    init_init2();
    init_init4();
    init_init5();
    init_init6();
    init_init7();
    init_init8();
    init_init9();
    init_init10();
    init_init11();
    init_init12();
    init_init13();
  }
});

// node_modules/pixi.js/lib/filters/Filter.mjs
var _Filter, Filter;
var init_Filter = __esm({
  "node_modules/pixi.js/lib/filters/Filter.mjs"() {
    init_GlProgram();
    init_GpuProgram();
    init_Shader();
    init_State();
    _Filter = class _Filter2 extends Shader {
      /**
       * @param options - The optional parameters of this filter.
       */
      constructor(options) {
        options = { ..._Filter2.defaultOptions, ...options };
        super(options);
        this.enabled = true;
        this._state = State.for2d();
        this.blendMode = options.blendMode;
        this.padding = options.padding;
        if (typeof options.antialias === "boolean") {
          this.antialias = options.antialias ? "on" : "off";
        } else {
          this.antialias = options.antialias;
        }
        this.resolution = options.resolution;
        this.blendRequired = options.blendRequired;
        this.addResource("uTexture", 0, 1);
      }
      /**
       * Applies the filter
       * @param filterManager - The renderer to retrieve the filter from
       * @param input - The input render target.
       * @param output - The target to output to.
       * @param clearMode - Should the output be cleared before rendering to it
       */
      apply(filterManager, input, output, clearMode) {
        filterManager.applyFilter(this, input, output, clearMode);
      }
      /**
       * Get the blend mode of the filter.
       * @default "normal"
       */
      get blendMode() {
        return this._state.blendMode;
      }
      /** Sets the blend mode of the filter. */
      set blendMode(value) {
        this._state.blendMode = value;
      }
      /**
       * A short hand function to create a filter based of a vertex and fragment shader src.
       * @param options
       * @returns A shiny new PixiJS filter!
       */
      static from(options) {
        const { gpu, gl, ...rest } = options;
        let gpuProgram3;
        let glProgram3;
        if (gpu) {
          gpuProgram3 = GpuProgram.from(gpu);
        }
        if (gl) {
          glProgram3 = GlProgram.from(gl);
        }
        return new _Filter2({
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          ...rest
        });
      }
    };
    _Filter.defaultOptions = {
      blendMode: "normal",
      resolution: 1,
      padding: 0,
      antialias: "off",
      blendRequired: false
    };
    Filter = _Filter;
  }
});

// node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i2 = 0; i2 < environments.length; i2++) {
    const env = environments[i2];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
var environments;
var init_autoDetectEnvironment = __esm({
  "node_modules/pixi.js/lib/environment/autoDetectEnvironment.mjs"() {
    init_Extensions();
    environments = [];
    extensions.handleByNamedList(ExtensionType.Environment, environments);
  }
});

// node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (e3) {
    unsafeEval = false;
  }
  return unsafeEval;
}
var unsafeEval;
var init_unsafeEvalSupported = __esm({
  "node_modules/pixi.js/lib/utils/browser/unsafeEvalSupported.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs
var CLEAR;
var init_const7 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs"() {
    "use strict";
    CLEAR = /* @__PURE__ */ ((CLEAR2) => {
      CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
      CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
      CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
      CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
      CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
      CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
      CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
      CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
      return CLEAR2;
    })(CLEAR || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs
var SystemRunner;
var init_SystemRunner = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs"() {
    "use strict";
    SystemRunner = class {
      /**
       * @param name - The function name that will be executed on the listeners added to this Runner.
       */
      constructor(name) {
        this.items = [];
        this._name = name;
      }
      /* eslint-disable jsdoc/require-param, jsdoc/check-param-names */
      /**
       * Dispatch/Broadcast Runner to all listeners added to the queue.
       * @param {...any} params - (optional) parameters to pass to each listener
       */
      /*  eslint-enable jsdoc/require-param, jsdoc/check-param-names */
      emit(a0, a1, a22, a3, a4, a5, a6, a7) {
        const { name, items } = this;
        for (let i2 = 0, len = items.length; i2 < len; i2++) {
          items[i2][name](a0, a1, a22, a3, a4, a5, a6, a7);
        }
        return this;
      }
      /**
       * Add a listener to the Runner
       *
       * Runners do not need to have scope or functions passed to them.
       * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
       * as the name provided to the Runner when it was created.
       *
       * Eg A listener passed to this Runner will require a 'complete' function.
       *
       * ```
       * import { Runner } from 'pixi.js';
       *
       * const complete = new Runner('complete');
       * ```
       *
       * The scope used will be the object itself.
       * @param {any} item - The object that will be listening.
       */
      add(item) {
        if (item[this._name]) {
          this.remove(item);
          this.items.push(item);
        }
        return this;
      }
      /**
       * Remove a single listener from the dispatch queue.
       * @param {any} item - The listener that you would like to remove.
       */
      remove(item) {
        const index2 = this.items.indexOf(item);
        if (index2 !== -1) {
          this.items.splice(index2, 1);
        }
        return this;
      }
      /**
       * Check to see if the listener is already in the Runner
       * @param {any} item - The listener that you would like to check.
       */
      contains(item) {
        return this.items.indexOf(item) !== -1;
      }
      /** Remove all listeners from the Runner */
      removeAll() {
        this.items.length = 0;
        return this;
      }
      /** Remove all references, don't use after this. */
      destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
      }
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get empty() {
        return this.items.length === 0;
      }
      /**
       * The name of the runner.
       * @readonly
       */
      get name() {
        return this._name;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs
var defaultRunners, _AbstractRenderer, AbstractRenderer;
var init_AbstractRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs"() {
    init_Color();
    init_autoDetectEnvironment();
    init_Container();
    init_unsafeEvalSupported();
    init_deprecation();
    init_const7();
    init_SystemRunner();
    init_eventemitter3();
    defaultRunners = [
      "init",
      "destroy",
      "contextChange",
      "resolutionChange",
      "reset",
      "renderEnd",
      "renderStart",
      "render",
      "update",
      "postrender",
      "prerender"
    ];
    _AbstractRenderer = class _AbstractRenderer2 extends eventemitter3_default {
      /**
       * Set up a system with a collection of SystemClasses and runners.
       * Systems are attached dynamically to this class when added.
       * @param config - the config for the system manager
       */
      constructor(config) {
        super();
        this.runners = /* @__PURE__ */ Object.create(null);
        this.renderPipes = /* @__PURE__ */ Object.create(null);
        this._initOptions = {};
        this._systemsHash = /* @__PURE__ */ Object.create(null);
        this.type = config.type;
        this.name = config.name;
        this.config = config;
        const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
        this._addRunners(...combinedRunners);
        this._unsafeEvalCheck();
      }
      /**
       * Initialize the renderer.
       * @param options - The options to use to create the renderer.
       */
      async init(options = {}) {
        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
        await loadEnvironmentExtensions(skip);
        this._addSystems(this.config.systems);
        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
        for (const systemName in this._systemsHash) {
          const system = this._systemsHash[systemName];
          const defaultSystemOptions = system.constructor.defaultOptions;
          options = { ...defaultSystemOptions, ...options };
        }
        options = { ..._AbstractRenderer2.defaultOptions, ...options };
        this._roundPixels = options.roundPixels ? 1 : 0;
        for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
          await this.runners.init.items[i2].init(options);
        }
        this._initOptions = options;
      }
      render(args, deprecated) {
        let options = args;
        if (options instanceof Container) {
          options = { container: options };
          if (deprecated) {
            deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
            options.target = deprecated.renderTexture;
          }
        }
        options.target || (options.target = this.view.renderTarget);
        if (options.target === this.view.renderTarget) {
          this._lastObjectRendered = options.container;
          options.clearColor = this.background.colorRgba;
        }
        if (options.clearColor) {
          const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
          options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
        }
        if (!options.transform) {
          options.container.updateLocalTransform();
          options.transform = options.container.localTransform;
        }
        this.runners.prerender.emit(options);
        this.runners.renderStart.emit(options);
        this.runners.render.emit(options);
        this.runners.renderEnd.emit(options);
        this.runners.postrender.emit(options);
      }
      /**
       * Resizes the WebGL view to the specified width and height.
       * @param desiredScreenWidth - The desired width of the screen.
       * @param desiredScreenHeight - The desired height of the screen.
       * @param resolution - The resolution / device pixel ratio of the renderer.
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        const previousResolution = this.view.resolution;
        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
        if (resolution !== void 0 && resolution !== previousResolution) {
          this.runners.resolutionChange.emit(resolution);
        }
      }
      clear(options = {}) {
        const renderer = this;
        options.target || (options.target = renderer.renderTarget.renderTarget);
        options.clearColor || (options.clearColor = this.background.colorRgba);
        options.clear ?? (options.clear = CLEAR.ALL);
        const { clear, clearColor, target } = options;
        Color.shared.setValue(clearColor ?? this.background.colorRgba);
        renderer.renderTarget.clear(target, clear, Color.shared.toArray());
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.view.resolution;
      }
      set resolution(value) {
        this.view.resolution = value;
        this.runners.resolutionChange.emit(value);
      }
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get width() {
        return this.view.texture.frame.width;
      }
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @default 600
       */
      get height() {
        return this.view.texture.frame.height;
      }
      // NOTE: this was `view` in v7
      /**
       * The canvas element that everything is drawn to.
       * @type {environment.ICanvas}
       */
      get canvas() {
        return this.view.canvas;
      }
      /**
       * the last object rendered by the renderer. Useful for other plugins like interaction managers
       * @readonly
       */
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      /**
       * Flag if we are rendering to the screen vs renderTexture
       * @readonly
       * @default true
       */
      get renderingToScreen() {
        const renderer = this;
        return renderer.renderTarget.renderingToScreen;
      }
      /**
       * Measurements of the screen. (0, 0, screenWidth, screenHeight).
       *
       * Its safe to use as filterArea or hitArea for the whole stage.
       */
      get screen() {
        return this.view.screen;
      }
      /**
       * Create a bunch of runners based of a collection of ids
       * @param runnerIds - the runner ids to add
       */
      _addRunners(...runnerIds) {
        runnerIds.forEach((runnerId) => {
          this.runners[runnerId] = new SystemRunner(runnerId);
        });
      }
      _addSystems(systems3) {
        let i2;
        for (i2 in systems3) {
          const val = systems3[i2];
          this._addSystem(val.value, val.name);
        }
      }
      /**
       * Add a new system to the renderer.
       * @param ClassRef - Class reference
       * @param name - Property name for system, if not specified
       *        will use a static `name` property on the class itself. This
       *        name will be assigned as s property on the Renderer so make
       *        sure it doesn't collide with properties on Renderer.
       * @returns Return instance of renderer
       */
      _addSystem(ClassRef, name) {
        const system = new ClassRef(this);
        if (this[name]) {
          throw new Error(`Whoops! The name "${name}" is already in use`);
        }
        this[name] = system;
        this._systemsHash[name] = system;
        for (const i2 in this.runners) {
          this.runners[i2].add(system);
        }
        return this;
      }
      _addPipes(pipes, pipeAdaptors) {
        const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
          acc[adaptor.name] = adaptor.value;
          return acc;
        }, {});
        pipes.forEach((pipe) => {
          const PipeClass = pipe.value;
          const name = pipe.name;
          const Adaptor = adaptors[name];
          this.renderPipes[name] = new PipeClass(
            this,
            Adaptor ? new Adaptor() : null
          );
        });
      }
      destroy(options = false) {
        this.runners.destroy.items.reverse();
        this.runners.destroy.emit(options);
        Object.values(this.runners).forEach((runner) => {
          runner.destroy();
        });
        this._systemsHash = null;
        this.renderPipes = null;
      }
      /**
       * Generate a texture from a container.
       * @param options - options or container target to use when generating the texture
       * @returns a texture
       */
      generateTexture(options) {
        return this.textureGenerator.generateTexture(options);
      }
      /**
       * Whether the renderer will round coordinates to whole pixels when rendering.
       * Can be overridden on a per scene item basis.
       */
      get roundPixels() {
        return !!this._roundPixels;
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       * @ignore
       */
      _unsafeEvalCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
    };
    _AbstractRenderer.defaultOptions = {
      /**
       * Default resolution / device pixel ratio of the renderer.
       * @default 1
       */
      resolution: 1,
      /**
       * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
       * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
       * performance issues when using WebGL.
       *
       * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
       * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
       * driver version blacklisted by the
       * browser.
       *
       * If your application requires high performance rendering, you may wish to set this to false.
       * We recommend one of two options if you decide to set this flag to false:
       *
       * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
       *    not supported.
       *
       * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
       *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
       *    device & browser combination does not support high performance WebGL.
       *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
       * @default false
       */
      failIfMajorPerformanceCaveat: false,
      /**
       * Should round pixels be forced when rendering?
       * @default false
       */
      roundPixels: false
    };
    AbstractRenderer = _AbstractRenderer;
  }
});

// node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs
var GpuGraphicsAdaptor;
var init_GpuGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gpu/GpuGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_maxRecommendedTextures();
    init_getTextureBatchBindGroup();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_Shader();
    init_UniformGroup();
    GpuGraphicsAdaptor = class {
      init() {
        const localUniforms = new UniformGroup({
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "graphics",
          bits: [
            colorBit,
            generateTextureBatchBit(getMaxTexturesPerBatch()),
            localUniformBitGroup2,
            roundPixelsBit
          ]
        });
        this.shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            // added on the fly!
            localUniforms
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context2);
        const encoder = renderer.encoder;
        encoder.setPipelineFromGeometryProgramAndState(
          geometry,
          shader.gpuProgram,
          graphicsPipe.state
        );
        encoder.setGeometry(geometry, shader.gpuProgram);
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);
        const localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);
        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);
        const batches = instructions.instructions;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          shader.groups[1] = batch.bindGroup;
          if (!batch.gpuBindGroup) {
            const textureBatch = batch.textures;
            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
            batch.gpuBindGroup = renderer.bindGroup.getBindGroup(
              batch.bindGroup,
              shader.gpuProgram,
              1
            );
          }
          encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);
          encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GpuGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs
var textureBit, textureBitGl;
var init_textureBit = __esm({
  "node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs"() {
    "use strict";
    textureBit = {
      name: "texture-bit",
      vertex: {
        header: (
          /* wgsl */
          `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `
        ),
        main: (
          /* wgsl */
          `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* wgsl */
          `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;

         
        `
        ),
        main: (
          /* wgsl */
          `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        )
      }
    };
    textureBitGl = {
      name: "texture-bit",
      vertex: {
        header: (
          /* glsl */
          `
            uniform mat3 uTextureMatrix;
        `
        ),
        main: (
          /* glsl */
          `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        )
      },
      fragment: {
        header: (
          /* glsl */
          `
        uniform sampler2D uTexture;

         
        `
        ),
        main: (
          /* glsl */
          `
            outColor = texture(uTexture, vUV);
        `
        )
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs
var GpuMeshAdapter;
var init_GpuMeshAdapter = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gpu/GpuMeshAdapter.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GpuMeshAdapter = class {
      init() {
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "mesh",
          bits: [
            localUniformBit,
            textureBit,
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram: gpuProgram3,
          resources: {
            uTexture: Texture.EMPTY._source,
            uSampler: Texture.EMPTY._source.style,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
        } else if (!shader.gpuProgram) {
          warn("Mesh shader has no gpuProgram", mesh.shader);
          return;
        }
        const gpuProgram3 = shader.gpuProgram;
        if (gpuProgram3.autoAssignGlobalUniforms) {
          shader.groups[0] = renderer.globalUniforms.bindGroup;
        }
        if (gpuProgram3.autoAssignLocalUniforms) {
          const localUniforms = meshPipe.localUniforms;
          shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);
        }
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuMeshAdapter.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs
var tempState, GpuBatchAdaptor;
var init_GpuBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gpu/GpuBatchAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_Shader();
    init_State();
    init_maxRecommendedTextures();
    init_getTextureBatchBindGroup();
    tempState = State.for2d();
    GpuBatchAdaptor = class {
      init() {
        const gpuProgram3 = compileHighShaderGpuProgram({
          name: "batch",
          bits: [
            colorBit,
            generateTextureBatchBit(getMaxTexturesPerBatch()),
            roundPixelsBit
          ]
        });
        this._shader = new Shader({
          gpuProgram: gpuProgram3,
          groups: {
            // these will be dynamically allocated
          }
        });
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        const program = this._shader.gpuProgram;
        this._geometry = geometry;
        encoder.setGeometry(geometry, program);
        tempState.blendMode = "normal";
        renderer.pipeline.getPipeline(
          geometry,
          program,
          tempState
        );
        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;
        encoder.resetBindGroup(1);
        encoder.setBindGroup(0, globalUniformsBindGroup, program);
      }
      execute(batchPipe, batch) {
        const program = this._shader.gpuProgram;
        const renderer = batchPipe.renderer;
        const encoder = renderer.encoder;
        if (!batch.bindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
        }
        tempState.blendMode = batch.blendMode;
        const gpuBindGroup = renderer.bindGroup.getBindGroup(
          batch.bindGroup,
          program,
          1
        );
        const pipeline = renderer.pipeline.getPipeline(
          this._geometry,
          program,
          tempState
        );
        batch.bindGroup._touch(renderer.textureGC.count);
        encoder.setPipeline(pipeline);
        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);
        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GpuBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGPUPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs
var CustomRenderPipe;
var init_CustomRenderPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs"() {
    init_Extensions();
    CustomRenderPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderable(container, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(container);
      }
      execute(container) {
        if (!container.isRenderable)
          return;
        container.render(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    };
    CustomRenderPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "customRender"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs
function executeInstructions(renderGroup, renderer) {
  const instructionSet = renderGroup.instructionSet;
  const instructions = instructionSet.instructions;
  for (let i2 = 0; i2 < instructionSet.instructionSize; i2++) {
    const instruction = instructions[i2];
    renderer[instruction.renderPipeId].execute(instruction);
  }
}
var init_executeInstructions = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs
var RenderGroupPipe;
var init_RenderGroupPipe = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs"() {
    init_Extensions();
    init_executeInstructions();
    RenderGroupPipe = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      addRenderGroup(renderGroup, instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add(renderGroup);
      }
      execute(renderGroup) {
        if (!renderGroup.isRenderable)
          return;
        this._renderer.globalUniforms.push({
          worldTransformMatrix: renderGroup.worldTransform,
          worldColor: renderGroup.worldColorAlpha
        });
        executeInstructions(renderGroup, this._renderer.renderPipes);
        this._renderer.globalUniforms.pop();
      }
      destroy() {
        this._renderer = null;
      }
    };
    RenderGroupPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs
function buildInstructions(renderGroup, rendererOrPipes) {
  const root3 = renderGroup.root;
  const instructionSet = renderGroup.instructionSet;
  instructionSet.reset();
  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
  const renderPipes3 = renderer.renderPipes;
  renderPipes3.batch.buildStart(instructionSet);
  renderPipes3.blendMode.buildStart();
  renderPipes3.colorMask.buildStart();
  if (root3.sortableChildren) {
    root3.sortChildren();
  }
  collectAllRenderablesAdvanced(root3, instructionSet, renderer, true);
  renderPipes3.batch.buildEnd(instructionSet);
  renderPipes3.blendMode.buildEnd(instructionSet);
}
function collectAllRenderables(container, instructionSet, rendererOrPipes) {
  const renderer = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
  if (container.globalDisplayStatus < 7 || !container.includeInBuild)
    return;
  if (container.sortableChildren) {
    container.sortChildren();
  }
  if (container.isSimple) {
    collectAllRenderablesSimple(container, instructionSet, renderer);
  } else {
    collectAllRenderablesAdvanced(container, instructionSet, renderer, false);
  }
}
function collectAllRenderablesSimple(container, instructionSet, renderer) {
  if (container.renderPipeId) {
    const { renderPipes: renderPipes3, renderableGC } = renderer;
    renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
    container.didViewUpdate = false;
    const rp = renderPipes3;
    rp[container.renderPipeId].addRenderable(container, instructionSet);
    renderableGC.addRenderable(container, instructionSet);
  }
  if (!container.renderGroup) {
    const children2 = container.children;
    const length = children2.length;
    for (let i2 = 0; i2 < length; i2++) {
      collectAllRenderables(children2[i2], instructionSet, renderer);
    }
  }
}
function collectAllRenderablesAdvanced(container, instructionSet, renderer, isRoot) {
  const { renderPipes: renderPipes3, renderableGC } = renderer;
  if (!isRoot && container.renderGroup) {
    renderPipes3.renderGroup.addRenderGroup(container.renderGroup, instructionSet);
  } else {
    for (let i2 = 0; i2 < container.effects.length; i2++) {
      const effect = container.effects[i2];
      const pipe = renderPipes3[effect.pipe];
      pipe.push(effect, container, instructionSet);
    }
    const renderPipeId = container.renderPipeId;
    if (renderPipeId) {
      renderPipes3.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);
      container.didViewUpdate = false;
      const pipe = renderPipes3[renderPipeId];
      pipe.addRenderable(container, instructionSet);
      renderableGC.addRenderable(container, instructionSet);
    }
    const children2 = container.children;
    if (children2.length) {
      for (let i2 = 0; i2 < children2.length; i2++) {
        collectAllRenderables(children2[i2], instructionSet, renderer);
      }
    }
    for (let i2 = container.effects.length - 1; i2 >= 0; i2--) {
      const effect = container.effects[i2];
      const pipe = renderPipes3[effect.pipe];
      pipe.pop(effect, container, instructionSet);
    }
  }
}
var init_buildInstructions = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/clearList.mjs
function clearList(list, index2) {
  index2 || (index2 = 0);
  for (let j3 = index2; j3 < list.length; j3++) {
    if (list[j3]) {
      list[j3] = null;
    } else {
      break;
    }
  }
}
var init_clearList = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/clearList.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs
function collectRenderGroups(renderGroup, out2 = []) {
  out2.push(renderGroup);
  for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
    collectRenderGroups(renderGroup.renderGroupChildren[i2], out2);
  }
  return out2;
}
var init_collectRenderGroups = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs
function mixHexColors(color1, color2, ratio) {
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 + (r2 - r1) * ratio;
  const g3 = g1 + (g2 - g1) * ratio;
  const b3 = b1 + (b2 - b1) * ratio;
  return (r3 << 16) + (g3 << 8) + b3;
}
var init_mixHexColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs
function mixColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {
    return localBGRColor + parentBGRColor - WHITE_BGR;
  }
  return mixHexColors(localBGRColor, parentBGRColor, 0.5);
}
var WHITE_BGR;
var init_mixColors = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs"() {
    init_mixHexColors();
    WHITE_BGR = 16777215;
  }
});

// node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs
function updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {
  updateRenderGroupTransform(renderGroup);
  const childrenToUpdate = renderGroup.childrenToUpdate;
  const updateTick = renderGroup.updateTick++;
  for (const j3 in childrenToUpdate) {
    const renderGroupDepth = Number(j3);
    const childrenAtDepth = childrenToUpdate[j3];
    const list = childrenAtDepth.list;
    const index2 = childrenAtDepth.index;
    for (let i2 = 0; i2 < index2; i2++) {
      const child = list[i2];
      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {
        updateTransformAndChildren(child, updateTick, 0);
      }
    }
    clearList(list, index2);
    childrenAtDepth.index = 0;
  }
  if (updateChildRenderGroups) {
    for (let i2 = 0; i2 < renderGroup.renderGroupChildren.length; i2++) {
      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i2], updateChildRenderGroups);
    }
  }
}
function updateRenderGroupTransform(renderGroup) {
  const root3 = renderGroup.root;
  let worldAlpha;
  if (renderGroup.renderGroupParent) {
    const renderGroupParent = renderGroup.renderGroupParent;
    renderGroup.worldTransform.appendFrom(
      root3.relativeGroupTransform,
      renderGroupParent.worldTransform
    );
    renderGroup.worldColor = mixColors(
      root3.groupColor,
      renderGroupParent.worldColor
    );
    worldAlpha = root3.groupAlpha * renderGroupParent.worldAlpha;
  } else {
    renderGroup.worldTransform.copyFrom(root3.localTransform);
    renderGroup.worldColor = root3.localColor;
    worldAlpha = root3.localAlpha;
  }
  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;
  renderGroup.worldAlpha = worldAlpha;
  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);
}
function updateTransformAndChildren(container, updateTick, updateFlags) {
  if (updateTick === container.updateTick)
    return;
  container.updateTick = updateTick;
  container.didChange = false;
  const localTransform = container.localTransform;
  container.updateLocalTransform();
  const parent2 = container.parent;
  if (parent2 && !parent2.renderGroup) {
    updateFlags = updateFlags | container._updateFlags;
    container.relativeGroupTransform.appendFrom(
      localTransform,
      parent2.relativeGroupTransform
    );
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, parent2, updateFlags);
    }
  } else {
    updateFlags = container._updateFlags;
    container.relativeGroupTransform.copyFrom(localTransform);
    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {
      updateColorBlendVisibility(container, tempContainer, updateFlags);
    }
  }
  if (!container.renderGroup) {
    const children2 = container.children;
    const length = children2.length;
    for (let i2 = 0; i2 < length; i2++) {
      updateTransformAndChildren(children2[i2], updateTick, updateFlags);
    }
    const renderGroup = container.parentRenderGroup;
    if (container.renderPipeId && !renderGroup.structureDidChange) {
      renderGroup.updateRenderable(container);
    }
  }
}
function updateColorBlendVisibility(container, parent2, updateFlags) {
  if (updateFlags & UPDATE_COLOR) {
    container.groupColor = mixColors(
      container.localColor,
      parent2.groupColor
    );
    let groupAlpha = container.localAlpha * parent2.groupAlpha;
    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;
    container.groupAlpha = groupAlpha;
    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);
  }
  if (updateFlags & UPDATE_BLEND) {
    container.groupBlendMode = container.localBlendMode === "inherit" ? parent2.groupBlendMode : container.localBlendMode;
  }
  if (updateFlags & UPDATE_VISIBLE) {
    container.globalDisplayStatus = container.localDisplayStatus & parent2.globalDisplayStatus;
  }
  container._updateFlags = 0;
}
var tempContainer, UPDATE_BLEND_COLOR_VISIBLE;
var init_updateRenderGroupTransforms = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs"() {
    init_Container();
    init_clearList();
    init_mixColors();
    tempContainer = new Container();
    UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;
  }
});

// node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs
function validateRenderables(renderGroup, renderPipes3) {
  const { list, index: index2 } = renderGroup.childrenRenderablesToUpdate;
  let rebuildRequired = false;
  for (let i2 = 0; i2 < index2; i2++) {
    const container = list[i2];
    const renderable = container;
    const pipe = renderPipes3[renderable.renderPipeId];
    rebuildRequired = pipe.validateRenderable(container);
    if (rebuildRequired) {
      break;
    }
  }
  renderGroup.structureDidChange = rebuildRequired;
  return rebuildRequired;
}
var init_validateRenderables = __esm({
  "node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs
function updateRenderables(renderGroup) {
  const { list, index: index2 } = renderGroup.childrenRenderablesToUpdate;
  for (let i2 = 0; i2 < index2; i2++) {
    const container = list[i2];
    if (container.didViewUpdate) {
      renderGroup.updateRenderable(container);
    }
  }
  clearList(list, index2);
}
var tempMatrix5, RenderGroupSystem;
var init_RenderGroupSystem = __esm({
  "node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_buildInstructions();
    init_clearList();
    init_collectRenderGroups();
    init_executeInstructions();
    init_updateRenderGroupTransforms();
    init_validateRenderables();
    tempMatrix5 = new Matrix();
    RenderGroupSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      render({ container, transform: transform4 }) {
        container.isRenderGroup = true;
        const parent2 = container.parent;
        const renderGroupParent = container.renderGroup.renderGroupParent;
        container.parent = null;
        container.renderGroup.renderGroupParent = null;
        const renderer = this._renderer;
        const renderGroups = collectRenderGroups(container.renderGroup, []);
        let originalLocalTransform = tempMatrix5;
        if (transform4) {
          originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);
          container.renderGroup.localTransform.copyFrom(transform4);
        }
        const renderPipes3 = renderer.renderPipes;
        for (let i2 = 0; i2 < renderGroups.length; i2++) {
          const renderGroup = renderGroups[i2];
          renderGroup.runOnRender();
          renderGroup.instructionSet.renderPipes = renderPipes3;
          if (!renderGroup.structureDidChange) {
            validateRenderables(renderGroup, renderPipes3);
          } else {
            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);
          }
          updateRenderGroupTransforms(renderGroup);
          if (renderGroup.structureDidChange) {
            renderGroup.structureDidChange = false;
            buildInstructions(renderGroup, renderer);
          } else {
            updateRenderables(renderGroup);
          }
          renderGroup.childrenRenderablesToUpdate.index = 0;
          renderer.renderPipes.batch.upload(renderGroup.instructionSet);
        }
        renderer.globalUniforms.start({
          worldTransformMatrix: transform4 ? container.renderGroup.localTransform : container.renderGroup.worldTransform,
          worldColor: container.renderGroup.worldColorAlpha
        });
        executeInstructions(container.renderGroup, renderPipes3);
        if (renderPipes3.uniformBatch) {
          renderPipes3.uniformBatch.renderEnd();
        }
        if (transform4) {
          container.renderGroup.localTransform.copyFrom(originalLocalTransform);
        }
        container.parent = parent2;
        container.renderGroup.renderGroupParent = renderGroupParent;
      }
      destroy() {
        this._renderer = null;
      }
    };
    RenderGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "renderGroup"
    };
  }
});

// node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs
var SpritePipe;
var init_SpritePipe = __esm({
  "node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs"() {
    init_Extensions();
    init_PoolGroup();
    init_BatchableSprite();
    SpritePipe = class {
      constructor(renderer) {
        this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);
        this._destroyRenderableBound = this.destroyRenderable.bind(this);
        this._renderer = renderer;
      }
      addRenderable(sprite, _instructionSet) {
        const gpuSprite = this._getGpuSprite(sprite);
        if (sprite._didSpriteUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        this._renderer.renderPipes.batch.addToBatch(gpuSprite);
      }
      updateRenderable(sprite) {
        const gpuSprite = this._gpuSpriteHash[sprite.uid];
        if (sprite._didSpriteUpdate)
          this._updateBatchableSprite(sprite, gpuSprite);
        gpuSprite.batcher.updateElement(gpuSprite);
      }
      validateRenderable(sprite) {
        const texture = sprite._texture;
        const gpuSprite = this._getGpuSprite(sprite);
        if (gpuSprite.texture._source !== texture._source) {
          return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);
        }
        return false;
      }
      destroyRenderable(sprite) {
        const batchableSprite = this._gpuSpriteHash[sprite.uid];
        BigPool.return(batchableSprite);
        this._gpuSpriteHash[sprite.uid] = null;
        sprite.off("destroyed", this._destroyRenderableBound);
      }
      _updateBatchableSprite(sprite, batchableSprite) {
        sprite._didSpriteUpdate = false;
        batchableSprite.bounds = sprite.bounds;
        batchableSprite.texture = sprite._texture;
      }
      _getGpuSprite(sprite) {
        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
      }
      _initGPUSprite(sprite) {
        const batchableSprite = BigPool.get(BatchableSprite);
        batchableSprite.renderable = sprite;
        batchableSprite.texture = sprite._texture;
        batchableSprite.bounds = sprite.bounds;
        batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
        this._gpuSpriteHash[sprite.uid] = batchableSprite;
        sprite._didSpriteUpdate = false;
        sprite.on("destroyed", this._destroyRenderableBound);
        return batchableSprite;
      }
      destroy() {
        for (const i2 in this._gpuSpriteHash) {
          BigPool.return(this._gpuSpriteHash[i2]);
        }
        this._gpuSpriteHash = null;
        this._renderer = null;
      }
    };
    SpritePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "sprite"
    };
  }
});

// node_modules/pixi.js/lib/utils/global/globalHooks.mjs
var ApplicationInitHook, RendererInitHook;
var init_globalHooks = __esm({
  "node_modules/pixi.js/lib/utils/global/globalHooks.mjs"() {
    init_Extensions();
    ApplicationInitHook = class {
      static init() {
        globalThis.__PIXI_APP_INIT__?.(this);
      }
      static destroy() {
      }
    };
    ApplicationInitHook.extension = ExtensionType.Application;
    RendererInitHook = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      init() {
        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer);
      }
      destroy() {
        this._renderer = null;
      }
    };
    RendererInitHook.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "initHook",
      priority: -10
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs
var BatcherPipe;
var init_BatcherPipe = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs"() {
    init_Extensions();
    init_State();
    init_Batcher();
    init_BatchGeometry();
    BatcherPipe = class {
      constructor(renderer, adaptor) {
        this.state = State.for2d();
        this._batches = /* @__PURE__ */ Object.create(null);
        this._geometries = /* @__PURE__ */ Object.create(null);
        this.renderer = renderer;
        this._adaptor = adaptor;
        this._adaptor.init(this);
      }
      buildStart(instructionSet) {
        if (!this._batches[instructionSet.uid]) {
          const batcher = new Batcher();
          this._batches[instructionSet.uid] = batcher;
          this._geometries[batcher.uid] = new BatchGeometry();
        }
        this._activeBatch = this._batches[instructionSet.uid];
        this._activeGeometry = this._geometries[this._activeBatch.uid];
        this._activeBatch.begin();
      }
      addToBatch(batchableObject) {
        this._activeBatch.add(batchableObject);
      }
      break(instructionSet) {
        this._activeBatch.break(instructionSet);
      }
      buildEnd(instructionSet) {
        const activeBatch = this._activeBatch;
        const geometry = this._activeGeometry;
        activeBatch.finish(instructionSet);
        geometry.indexBuffer.setDataWithSize(activeBatch.indexBuffer, activeBatch.indexSize, true);
        geometry.buffers[0].setDataWithSize(activeBatch.attributeBuffer.float32View, activeBatch.attributeSize, false);
      }
      upload(instructionSet) {
        const batcher = this._batches[instructionSet.uid];
        const geometry = this._geometries[batcher.uid];
        if (batcher.dirty) {
          batcher.dirty = false;
          geometry.buffers[0].update(batcher.attributeSize * 4);
        }
      }
      execute(batch) {
        if (batch.action === "startBatch") {
          const batcher = batch.batcher;
          const geometry = this._geometries[batcher.uid];
          this._adaptor.start(this, geometry);
        }
        this._adaptor.execute(this, batch);
      }
      destroy() {
        this.state = null;
        this.renderer = null;
        this._adaptor.destroy();
        this._adaptor = null;
        for (const i2 in this._batches) {
          this._batches[i2].destroy();
        }
        this._batches = null;
        for (const i2 in this._geometries) {
          this._geometries[i2].destroy();
        }
        this._geometries = null;
      }
    };
    BatcherPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.frag.mjs
var fragment;
var init_mask_frag = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.frag.mjs"() {
    fragment = "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha; \n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * uAlpha * clip);\n\n    finalColor = original;\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.vert.mjs
var vertex;
var init_mask_vert = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.vert.mjs"() {
    vertex = "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n";
  }
});

// node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs
var source;
var init_mask_wgsl = __esm({
  "node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs"() {
    source = "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb, source.a) * a;\n}";
  }
});

// node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs
var MaskFilter;
var init_MaskFilter = __esm({
  "node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs"() {
    init_Matrix();
    init_GlProgram();
    init_GpuProgram();
    init_UniformGroup();
    init_TextureMatrix();
    init_Filter();
    init_mask_frag();
    init_mask_vert();
    init_mask_wgsl();
    MaskFilter = class extends Filter {
      constructor(options) {
        const { sprite, ...rest } = options;
        const textureMatrix = new TextureMatrix(sprite.texture);
        const filterUniforms = new UniformGroup({
          uFilterMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uMaskClamp: { value: textureMatrix.uClampFrame, type: "vec4<f32>" },
          uAlpha: { value: 1, type: "f32" }
        });
        const gpuProgram3 = GpuProgram.from({
          vertex: {
            source,
            entryPoint: "mainVertex"
          },
          fragment: {
            source,
            entryPoint: "mainFragment"
          }
        });
        const glProgram3 = GlProgram.from({
          vertex,
          fragment,
          name: "mask-filter"
        });
        super({
          ...rest,
          gpuProgram: gpuProgram3,
          glProgram: glProgram3,
          resources: {
            filterUniforms,
            uMaskTexture: sprite.texture.source
          }
        });
        this.sprite = sprite;
        this._textureMatrix = textureMatrix;
      }
      apply(filterManager, input, output, clearMode) {
        this._textureMatrix.texture = this.sprite.texture;
        filterManager.calculateSpriteMatrix(
          this.resources.filterUniforms.uniforms.uFilterMatrix,
          this.sprite
        ).prepend(this._textureMatrix.mapCoord);
        this.resources.uMaskTexture = this.sprite.texture.source;
        filterManager.applyFilter(this, input, output, clearMode);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs
var tempBounds3, AlphaMaskEffect, AlphaMaskPipe;
var init_AlphaMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_MaskFilter();
    init_Bounds();
    init_getGlobalBounds();
    init_buildInstructions();
    init_Sprite();
    init_PoolGroup();
    init_Texture();
    init_TexturePool();
    init_types2();
    tempBounds3 = new Bounds();
    AlphaMaskEffect = class extends FilterEffect {
      constructor() {
        super();
        this.filters = [new MaskFilter({
          sprite: new Sprite(Texture.EMPTY),
          resolution: "inherit",
          antialias: "inherit"
        })];
      }
      get sprite() {
        return this.filters[0].sprite;
      }
      set sprite(value) {
        this.filters[0].sprite = value;
      }
    };
    AlphaMaskPipe = class {
      constructor(renderer) {
        this._activeMaskStage = [];
        this._renderer = renderer;
      }
      push(mask, maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false,
          maskedContainer
        });
        if (mask.renderMaskToTexture) {
          const maskContainer = mask.mask;
          maskContainer.includeInBuild = true;
          collectAllRenderables(
            maskContainer,
            instructionSet,
            renderer
          );
          maskContainer.includeInBuild = false;
        }
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "pushMaskEnd",
          mask,
          maskedContainer,
          canBundle: false
        });
      }
      pop(mask, _maskedContainer, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "alphaMask",
          action: "popMaskEnd",
          mask,
          canBundle: false
        });
      }
      execute(instruction) {
        const renderer = this._renderer;
        const renderMask = instruction.mask.renderMaskToTexture;
        if (instruction.action === "pushMaskBegin") {
          const filterEffect = BigPool.get(AlphaMaskEffect);
          if (renderMask) {
            instruction.mask.mask.measurable = true;
            const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds3);
            instruction.mask.mask.measurable = false;
            bounds.ceil();
            const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
            const filterTexture = TexturePool.getOptimalTexture(
              bounds.width,
              bounds.height,
              colorTextureSource._resolution,
              colorTextureSource.antialias
            );
            renderer.renderTarget.push(filterTexture, true);
            renderer.globalUniforms.push({
              offset: bounds,
              worldColor: 4294967295
            });
            const sprite = filterEffect.sprite;
            sprite.texture = filterTexture;
            sprite.worldTransform.tx = bounds.minX;
            sprite.worldTransform.ty = bounds.minY;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer,
              filterTexture
            });
          } else {
            filterEffect.sprite = instruction.mask.mask;
            this._activeMaskStage.push({
              filterEffect,
              maskedContainer: instruction.maskedContainer
            });
          }
        } else if (instruction.action === "pushMaskEnd") {
          const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];
          if (renderMask) {
            if (renderer.type === RendererType.WEBGL) {
              renderer.renderTarget.finishRenderPass();
            }
            renderer.renderTarget.pop();
            renderer.globalUniforms.pop();
          }
          renderer.filter.push({
            renderPipeId: "filter",
            action: "pushFilter",
            container: maskData.maskedContainer,
            filterEffect: maskData.filterEffect,
            canBundle: false
          });
        } else if (instruction.action === "popMaskEnd") {
          renderer.filter.pop();
          const maskData = this._activeMaskStage.pop();
          if (renderMask) {
            TexturePool.returnTexture(maskData.filterTexture);
          }
          BigPool.return(maskData.filterEffect);
        }
      }
      destroy() {
        this._renderer = null;
        this._activeMaskStage = null;
      }
    };
    AlphaMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "alphaMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs
var ColorMaskPipe;
var init_ColorMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs"() {
    init_Extensions();
    ColorMaskPipe = class {
      constructor(renderer) {
        this._colorStack = [];
        this._colorStackIndex = 0;
        this._currentColor = 0;
        this._renderer = renderer;
      }
      buildStart() {
        this._colorStack[0] = 15;
        this._colorStackIndex = 1;
        this._currentColor = 15;
      }
      push(mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;
        const currentColor = this._colorStack[this._colorStackIndex];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
        this._colorStackIndex++;
      }
      pop(_mask, _container, instructionSet) {
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        const colorStack = this._colorStack;
        this._colorStackIndex--;
        const currentColor = colorStack[this._colorStackIndex - 1];
        if (currentColor !== this._currentColor) {
          this._currentColor = currentColor;
          instructionSet.add({
            renderPipeId: "colorMask",
            colorMask: currentColor,
            canBundle: false
          });
        }
      }
      execute(instruction) {
        const renderer = this._renderer;
        renderer.colorMask.setMask(instruction.colorMask);
      }
      destroy() {
        this._colorStack = null;
      }
    };
    ColorMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs
var StencilMaskPipe;
var init_StencilMaskPipe = __esm({
  "node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs"() {
    init_Extensions();
    init_buildInstructions();
    init_const7();
    init_const3();
    StencilMaskPipe = class {
      constructor(renderer) {
        this._maskStackHash = {};
        this._maskHash = /* @__PURE__ */ new WeakMap();
        this._renderer = renderer;
      }
      push(mask, _container, instructionSet) {
        var _a;
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskBegin",
          mask,
          canBundle: false
        });
        const maskContainer = effect.mask;
        maskContainer.includeInBuild = true;
        if (!this._maskHash.has(effect)) {
          this._maskHash.set(effect, {
            instructionsStart: 0,
            instructionsLength: 0
          });
        }
        const maskData = this._maskHash.get(effect);
        maskData.instructionsStart = instructionSet.instructionSize;
        collectAllRenderables(
          maskContainer,
          instructionSet,
          renderer
        );
        maskContainer.includeInBuild = false;
        renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "pushMaskEnd",
          mask,
          canBundle: false
        });
        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;
        maskData.instructionsLength = instructionsLength;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
      }
      pop(mask, _container, instructionSet) {
        const effect = mask;
        const renderer = this._renderer;
        renderer.renderPipes.batch.break(instructionSet);
        renderer.renderPipes.blendMode.setBlendMode(effect.mask, "none", instructionSet);
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskBegin",
          canBundle: false
        });
        const maskData = this._maskHash.get(mask);
        for (let i2 = 0; i2 < maskData.instructionsLength; i2++) {
          instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];
        }
        instructionSet.add({
          renderPipeId: "stencilMask",
          action: "popMaskEnd",
          canBundle: false
        });
      }
      execute(instruction) {
        var _a;
        const renderer = this._renderer;
        const renderTargetUid = renderer.renderTarget.renderTarget.uid;
        let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);
        if (instruction.action === "pushMaskBegin") {
          renderer.renderTarget.ensureDepthStencil();
          renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);
          maskStackIndex++;
          renderer.colorMask.setMask(0);
        } else if (instruction.action === "pushMaskEnd") {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          renderer.colorMask.setMask(15);
        } else if (instruction.action === "popMaskBegin") {
          renderer.colorMask.setMask(0);
          if (maskStackIndex !== 0) {
            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);
          } else {
            renderer.renderTarget.clear(null, CLEAR.STENCIL);
            renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);
          }
          maskStackIndex--;
        } else if (instruction.action === "popMaskEnd") {
          renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);
          renderer.colorMask.setMask(15);
        }
        this._maskStackHash[renderTargetUid] = maskStackIndex;
      }
      destroy() {
        this._renderer = null;
        this._maskStackHash = null;
        this._maskHash = null;
      }
    };
    StencilMaskPipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "stencilMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs
var _BackgroundSystem, BackgroundSystem;
var init_BackgroundSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs"() {
    init_Color();
    init_Extensions();
    _BackgroundSystem = class _BackgroundSystem2 {
      constructor() {
        this.clearBeforeRender = true;
        this._backgroundColor = new Color(0);
        this.color = this._backgroundColor;
        this.alpha = 1;
      }
      /**
       * initiates the background system
       * @param options - the options for the background colors
       */
      init(options) {
        options = { ..._BackgroundSystem2.defaultOptions, ...options };
        this.clearBeforeRender = options.clearBeforeRender;
        this.color = options.background || options.backgroundColor || this._backgroundColor;
        this.alpha = options.backgroundAlpha;
        this._backgroundColor.setAlpha(options.backgroundAlpha);
      }
      /** The background color to fill if not transparent */
      get color() {
        return this._backgroundColor;
      }
      set color(value) {
        this._backgroundColor.setValue(value);
      }
      /** The background color alpha. Setting this to 0 will make the canvas transparent. */
      get alpha() {
        return this._backgroundColor.alpha;
      }
      set alpha(value) {
        this._backgroundColor.setAlpha(value);
      }
      /** The background color as an [R, G, B, A] array. */
      get colorRgba() {
        return this._backgroundColor.toArray();
      }
      /**
       * destroys the background system
       * @internal
       * @ignore
       */
      destroy() {
      }
    };
    _BackgroundSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "background",
      priority: 0
    };
    _BackgroundSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.backgroundAlpha}
       * @default 1
       */
      backgroundAlpha: 1,
      /**
       * {@link WebGLOptions.backgroundColor}
       * @default 0x000000
       */
      backgroundColor: 0,
      /**
       * {@link WebGLOptions.clearBeforeRender}
       * @default true
       */
      clearBeforeRender: true
    };
    BackgroundSystem = _BackgroundSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs
var BLEND_MODE_FILTERS, BlendModePipe;
var init_BlendModePipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs"() {
    init_Extensions();
    init_FilterEffect();
    init_warn();
    BLEND_MODE_FILTERS = {};
    extensions.handle(ExtensionType.BlendMode, (value) => {
      if (!value.name) {
        throw new Error("BlendMode extension must have a name property");
      }
      BLEND_MODE_FILTERS[value.name] = value.ref;
    }, (value) => {
      delete BLEND_MODE_FILTERS[value.name];
    });
    BlendModePipe = class {
      constructor(renderer) {
        this._isAdvanced = false;
        this._filterHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      /**
       * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.
       * @param renderable - The renderable we are adding to the instruction set
       * @param blendMode - The blend mode of the renderable
       * @param instructionSet - The instruction set we are adding to
       */
      setBlendMode(renderable, blendMode, instructionSet) {
        if (this._activeBlendMode === blendMode) {
          if (this._isAdvanced)
            this._renderableList.push(renderable);
          return;
        }
        this._activeBlendMode = blendMode;
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];
        if (this._isAdvanced) {
          this._beginAdvancedBlendMode(instructionSet);
          this._renderableList.push(renderable);
        }
      }
      _beginAdvancedBlendMode(instructionSet) {
        this._renderer.renderPipes.batch.break(instructionSet);
        const blendMode = this._activeBlendMode;
        if (!BLEND_MODE_FILTERS[blendMode]) {
          warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
          return;
        }
        let filterEffect = this._filterHash[blendMode];
        if (!filterEffect) {
          filterEffect = this._filterHash[blendMode] = new FilterEffect();
          filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];
        }
        const instruction = {
          renderPipeId: "filter",
          action: "pushFilter",
          renderables: [],
          filterEffect,
          canBundle: false
        };
        this._renderableList = instruction.renderables;
        instructionSet.add(instruction);
      }
      _endAdvancedBlendMode(instructionSet) {
        this._renderableList = null;
        this._renderer.renderPipes.batch.break(instructionSet);
        instructionSet.add({
          renderPipeId: "filter",
          action: "popFilter",
          canBundle: false
        });
      }
      /**
       * called when the instruction build process is starting this will reset internally to the default blend mode
       * @internal
       * @ignore
       */
      buildStart() {
        this._isAdvanced = false;
      }
      /**
       * called when the instruction build process is finished, ensuring that if there is an advanced blend mode
       * active, we add the final render instructions added to the instruction set
       * @param instructionSet - The instruction set we are adding to
       * @internal
       * @ignore
       */
      buildEnd(instructionSet) {
        if (this._isAdvanced) {
          this._endAdvancedBlendMode(instructionSet);
        }
      }
      /**
       * @internal
       * @ignore
       */
      destroy() {
        this._renderer = null;
        this._renderableList = null;
        for (const i2 in this._filterHash) {
          this._filterHash[i2].destroy();
        }
        this._filterHash = null;
      }
    };
    BlendModePipe.extension = {
      type: [
        ExtensionType.WebGLPipes,
        ExtensionType.WebGPUPipes,
        ExtensionType.CanvasPipes
      ],
      name: "blendMode"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs
var imageTypes, _ExtractSystem, ExtractSystem;
var init_ExtractSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs"() {
    init_Extensions();
    init_Container();
    init_Texture();
    imageTypes = {
      png: "image/png",
      jpg: "image/jpeg",
      webp: "image/webp"
    };
    _ExtractSystem = class _ExtractSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
      }
      _normalizeOptions(options, defaults = {}) {
        if (options instanceof Container || options instanceof Texture) {
          return {
            target: options,
            ...defaults
          };
        }
        return {
          ...defaults,
          ...options
        };
      }
      /**
       * Will return a HTML Image of the target
       * @param options - The options for creating the image, or the target to extract
       * @returns - HTML Image of the target
       */
      async image(options) {
        const image = new Image();
        image.src = await this.base64(options);
        return image;
      }
      /**
       * Will return a base64 encoded string of this target. It works by calling
       * `Extract.canvas` and then running toDataURL on that.
       * @param options - The options for creating the image, or the target to extract
       */
      async base64(options) {
        options = this._normalizeOptions(
          options,
          _ExtractSystem2.defaultImageOptions
        );
        const { format: format2, quality } = options;
        const canvas = this.canvas(options);
        if (canvas.toBlob !== void 0) {
          return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (!blob) {
                reject(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }, imageTypes[format2], quality);
          });
        }
        if (canvas.toDataURL !== void 0) {
          return canvas.toDataURL(imageTypes[format2], quality);
        }
        if (canvas.convertToBlob !== void 0) {
          const blob = await canvas.convertToBlob({ type: imageTypes[format2], quality });
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      /**
       * Creates a Canvas element, renders this target to it and then returns it.
       * @param options - The options for creating the canvas, or the target to extract
       * @returns - A Canvas element with the texture rendered on.
       */
      canvas(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        if (target instanceof Texture) {
          return renderer.texture.generateCanvas(target);
        }
        const texture = renderer.textureGenerator.generateTexture(options);
        const canvas = renderer.texture.generateCanvas(texture);
        texture.destroy();
        return canvas;
      }
      /**
       * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
       * order, with integer values between 0 and 255 (included).
       * @param options - The options for extracting the image, or the target to extract
       * @returns - One-dimensional array containing the pixel data of the entire texture
       */
      pixels(options) {
        options = this._normalizeOptions(options);
        const target = options.target;
        const renderer = this._renderer;
        const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);
        const pixelInfo = renderer.texture.getPixels(texture);
        if (target instanceof Container) {
          texture.destroy();
        }
        return pixelInfo;
      }
      /**
       * Will return a texture of the target
       * @param options - The options for creating the texture, or the target to extract
       * @returns - A texture of the target
       */
      texture(options) {
        options = this._normalizeOptions(options);
        if (options.target instanceof Texture)
          return options.target;
        return this._renderer.textureGenerator.generateTexture(options);
      }
      /**
       * Will extract a HTMLImage of the target and download it
       * @param options - The options for downloading and extracting the image, or the target to extract
       */
      download(options) {
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const link = document.createElement("a");
        link.download = options.filename ?? "image.png";
        link.href = canvas.toDataURL("image/png");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      /**
       * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.
       * @param options - The options for logging the image, or the target to log
       */
      log(options) {
        const width = options.width ?? 200;
        options = this._normalizeOptions(options);
        const canvas = this.canvas(options);
        const base64 = canvas.toDataURL();
        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);
        const style = [
          "font-size: 1px;",
          `padding: ${width}px ${300}px;`,
          `background: url(${base64}) no-repeat;`,
          "background-size: contain;"
        ].join(" ");
        console.log("%c ", style);
      }
      destroy() {
        this._renderer = null;
      }
    };
    _ExtractSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "extract"
    };
    _ExtractSystem.defaultImageOptions = {
      /** The format of the image. */
      format: "png",
      /** The quality of the image. */
      quality: 1
    };
    ExtractSystem = _ExtractSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs
var RenderTexture;
var init_RenderTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs"() {
    init_TextureSource();
    init_Texture();
    RenderTexture = class _RenderTexture extends Texture {
      static create(options) {
        return new _RenderTexture({
          source: new TextureSource(options)
        });
      }
      /**
       * Resizes the render texture.
       * @param width - The new width of the render texture.
       * @param height - The new height of the render texture.
       * @param resolution - The new resolution of the render texture.
       * @returns This texture.
       */
      resize(width, height, resolution) {
        this.source.resize(width, height, resolution);
        return this;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs
var tempRect2, tempBounds4, noColor, GenerateTextureSystem;
var init_GenerateTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs"() {
    init_Color();
    init_Extensions();
    init_Matrix();
    init_Rectangle();
    init_Bounds();
    init_getLocalBounds();
    init_Container();
    init_RenderTexture();
    tempRect2 = new Rectangle();
    tempBounds4 = new Bounds();
    noColor = [0, 0, 0, 0];
    GenerateTextureSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * A Useful function that returns a texture of the display object that can then be used to create sprites
       * This can be quite useful if your container is complicated and needs to be reused multiple times.
       * @param {GenerateTextureOptions | Container} options - Generate texture options.
       * @param {Container} [options.container] - If not given, the renderer's resolution is used.
       * @param {Rectangle} options.region - The region of the container, that shall be rendered,
       * @param {number} [options.resolution] - The resolution of the texture being generated.
       *        if no region is specified, defaults to the local bounds of the container.
       * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.
       * @returns a shiny new texture of the container passed in
       */
      generateTexture(options) {
        if (options instanceof Container) {
          options = {
            target: options,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
          };
        }
        const resolution = options.resolution || this._renderer.resolution;
        const antialias = options.antialias || this._renderer.view.antialias;
        const container = options.target;
        let clearColor = options.clearColor;
        if (clearColor) {
          const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;
          clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();
        } else {
          clearColor = noColor;
        }
        const region = options.frame?.copyTo(tempRect2) || getLocalBounds(container, tempBounds4).rectangle;
        region.width = Math.max(region.width, 1 / resolution) | 0;
        region.height = Math.max(region.height, 1 / resolution) | 0;
        const target = RenderTexture.create({
          ...options.textureSourceOptions,
          width: region.width,
          height: region.height,
          resolution,
          antialias
        });
        const transform4 = Matrix.shared.translate(-region.x, -region.y);
        this._renderer.render({
          container,
          transform: transform4,
          target,
          clearColor
        });
        target.source.updateMipmaps();
        return target;
      }
      destroy() {
        this._renderer = null;
      }
    };
    GenerateTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGenerator"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs
var GlobalUniformSystem;
var init_GlobalUniformSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs"() {
    init_Extensions();
    init_Matrix();
    init_Point();
    init_colorToUniform();
    init_BindGroup();
    init_types2();
    init_UniformGroup();
    GlobalUniformSystem = class {
      constructor(renderer) {
        this._stackIndex = 0;
        this._globalUniformDataStack = [];
        this._uniformsPool = [];
        this._activeUniforms = [];
        this._bindGroupPool = [];
        this._activeBindGroups = [];
        this._renderer = renderer;
      }
      reset() {
        this._stackIndex = 0;
        for (let i2 = 0; i2 < this._activeUniforms.length; i2++) {
          this._uniformsPool.push(this._activeUniforms[i2]);
        }
        for (let i2 = 0; i2 < this._activeBindGroups.length; i2++) {
          this._bindGroupPool.push(this._activeBindGroups[i2]);
        }
        this._activeUniforms.length = 0;
        this._activeBindGroups.length = 0;
      }
      start(options) {
        this.reset();
        this.push(options);
      }
      bind({
        size,
        projectionMatrix,
        worldTransformMatrix,
        worldColor,
        offset
      }) {
        const renderTarget = this._renderer.renderTarget.renderTarget;
        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
          projectionData: renderTarget,
          worldTransformMatrix: new Matrix(),
          worldColor: 4294967295,
          offset: new Point()
        };
        const globalUniformData = {
          projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,
          resolution: size || renderTarget.size,
          worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,
          worldColor: worldColor || currentGlobalUniformData.worldColor,
          offset: offset || currentGlobalUniformData.offset,
          bindGroup: null
        };
        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(uniformGroup);
        const uniforms = uniformGroup.uniforms;
        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;
        uniforms.uResolution = globalUniformData.resolution;
        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);
        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;
        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;
        color32BitToUniform(
          globalUniformData.worldColor,
          uniforms.uWorldColorAlpha,
          0
        );
        uniformGroup.update();
        let bindGroup;
        if (this._renderer.renderPipes.uniformBatch) {
          bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);
        } else {
          bindGroup = this._bindGroupPool.pop() || new BindGroup();
          this._activeBindGroups.push(bindGroup);
          bindGroup.setResource(uniformGroup, 0);
        }
        globalUniformData.bindGroup = bindGroup;
        this._currentGlobalUniformData = globalUniformData;
      }
      push(options) {
        this.bind(options);
        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;
      }
      pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];
        if (this._renderer.type === RendererType.WEBGL) {
          this._currentGlobalUniformData.bindGroup.resources[0].update();
        }
      }
      get bindGroup() {
        return this._currentGlobalUniformData.bindGroup;
      }
      get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0];
      }
      _createUniforms() {
        const globalUniforms = new UniformGroup({
          uProjectionMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uWorldTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>
          uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
          uResolution: { value: [0, 0], type: "vec2<f32>" }
        }, {
          isStatic: true
        });
        return globalUniforms;
      }
      destroy() {
        this._renderer = null;
      }
    };
    GlobalUniformSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "globalUniforms"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs
var uid2, SchedulerSystem;
var init_SchedulerSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/SchedulerSystem.mjs"() {
    init_Extensions();
    init_Ticker();
    uid2 = 1;
    SchedulerSystem = class {
      constructor() {
        this._tasks = [];
      }
      /** Initializes the scheduler system and starts the ticker. */
      init() {
        Ticker.system.add(this._update, this);
      }
      /**
       * Schedules a repeating task.
       * @param func - The function to execute.
       * @param duration - The interval duration in milliseconds.
       * @returns The unique identifier for the scheduled task.
       */
      repeat(func, duration) {
        const id2 = uid2++;
        this._tasks.push({
          func,
          duration,
          start: performance.now(),
          last: performance.now(),
          repeat: true,
          id: id2
        });
        return id2;
      }
      /**
       * Cancels a scheduled task.
       * @param id - The unique identifier of the task to cancel.
       */
      cancel(id2) {
        for (let i2 = 0; i2 < this._tasks.length; i2++) {
          if (this._tasks[i2].id === id2) {
            this._tasks.splice(i2, 1);
            return;
          }
        }
      }
      /**
       * Updates and executes the scheduled tasks.
       * @private
       */
      _update() {
        const now2 = performance.now();
        for (let i2 = 0; i2 < this._tasks.length; i2++) {
          const task = this._tasks[i2];
          if (now2 - task.last >= task.duration) {
            const elapsed = now2 - task.start;
            task.func(elapsed);
            task.last = now2;
          }
        }
      }
      /**
       * Destroys the scheduler system and removes all tasks.
       * @internal
       * @ignore
       */
      destroy() {
        Ticker.system.remove(this._update, this);
        this._tasks.length = 0;
      }
    };
    SchedulerSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "scheduler",
      priority: 0
    };
  }
});

// node_modules/pixi.js/lib/utils/sayHello.mjs
function sayHello(type2) {
  if (saidHello) {
    return;
  }
  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
    const args = [
      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type2}) http://www.pixijs.com/

`,
      "background: #E72264; padding:5px 0;",
      "background: #6CA2EA; padding:5px 0;",
      "background: #B5D33D; padding:5px 0;",
      "background: #FED23F; padding:5px 0;",
      "color: #FFFFFF; background: #E72264; padding:5px 0;",
      "color: #E72264; background: #FFFFFF; padding:5px 0;"
    ];
    globalThis.console.log(...args);
  } else if (globalThis.console) {
    globalThis.console.log(`PixiJS ${VERSION} - ${type2} - http://www.pixijs.com/`);
  }
  saidHello = true;
}
var saidHello, VERSION;
var init_sayHello = __esm({
  "node_modules/pixi.js/lib/utils/sayHello.mjs"() {
    init_adapter();
    saidHello = false;
    VERSION = "8.3.4";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs
var HelloSystem;
var init_HelloSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs"() {
    init_Extensions();
    init_sayHello();
    init_types2();
    HelloSystem = class {
      constructor(renderer) {
        this._renderer = renderer;
      }
      /**
       * It all starts here! This initiates every system, passing in the options for any system by name.
       * @param options - the config for the renderer and all its systems
       */
      init(options) {
        if (options.hello) {
          let name = this._renderer.name;
          if (this._renderer.type === RendererType.WEBGL) {
            name += ` ${this._renderer.context.webGLVersion}`;
          }
          sayHello(name);
        }
      }
    };
    HelloSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "hello",
      priority: -2
    };
    HelloSystem.defaultOptions = {
      /** {@link WebGLOptions.hello} */
      hello: false
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs
var _RenderableGCSystem, RenderableGCSystem;
var init_RenderableGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderableGCSystem.mjs"() {
    init_Extensions();
    _RenderableGCSystem = class _RenderableGCSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._managedRenderables = [];
        this._renderer = renderer;
      }
      init(options) {
        options = { ..._RenderableGCSystem2.defaultOptions, ...options };
        this.maxUnusedTime = options.renderableGCMaxUnusedTime;
        this._frequency = options.renderableGCFrequency;
        this.enabled = options.renderableGCActive;
      }
      get enabled() {
        return !!this._handler;
      }
      set enabled(value) {
        if (this.enabled === value)
          return;
        if (value) {
          this._handler = this._renderer.scheduler.repeat(
            () => this.run(),
            this._frequency
          );
        } else {
          this._renderer.scheduler.cancel(this._handler);
        }
      }
      prerender() {
        this._now = performance.now();
      }
      addRenderable(renderable, instructionSet) {
        if (!this.enabled)
          return;
        renderable._lastUsed = this._now;
        if (renderable._lastInstructionTick === -1) {
          this._managedRenderables.push(renderable);
          renderable.once("destroyed", this._removeRenderable, this);
        }
        renderable._lastInstructionTick = instructionSet.tick;
      }
      /** Runs the scheduled garbage collection */
      run() {
        const now2 = performance.now();
        const managedRenderables = this._managedRenderables;
        const renderPipes3 = this._renderer.renderPipes;
        let offset = 0;
        for (let i2 = 0; i2 < managedRenderables.length; i2++) {
          const renderable = managedRenderables[i2];
          if (renderable === null) {
            offset++;
            continue;
          }
          const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
          const currentIndex = renderGroup?.instructionSet?.tick ?? -1;
          if (renderable._lastInstructionTick !== currentIndex && now2 - renderable._lastUsed > this.maxUnusedTime) {
            if (!renderable.destroyed) {
              const rp = renderPipes3;
              rp[renderable.renderPipeId].destroyRenderable(renderable);
            }
            renderable._lastInstructionTick = -1;
            offset++;
            renderable.off("destroyed", this._removeRenderable, this);
          } else {
            managedRenderables[i2 - offset] = renderable;
          }
        }
        managedRenderables.length = managedRenderables.length - offset;
      }
      destroy() {
        this.enabled = false;
        this._renderer = null;
        this._managedRenderables.length = 0;
      }
      _removeRenderable(renderable) {
        const index2 = this._managedRenderables.indexOf(renderable);
        if (index2 >= 0) {
          renderable.off("destroyed", this._removeRenderable, this);
          this._managedRenderables[index2] = null;
        }
      }
    };
    _RenderableGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "renderableGC"
    };
    _RenderableGCSystem.defaultOptions = {
      /**
       * If set to true, this will enable the garbage collector on the GPU.
       * @default true
       */
      renderableGCActive: true,
      /**
       * The maximum idle frames before a texture is destroyed by garbage collection.
       * @default 60 * 60
       */
      renderableGCMaxUnusedTime: 6e4,
      /**
       * Frames between two garbage collections.
       * @default 600
       */
      renderableGCFrequency: 3e4
    };
    RenderableGCSystem = _RenderableGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs
var _TextureGCSystem, TextureGCSystem;
var init_TextureGCSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs"() {
    init_Extensions();
    _TextureGCSystem = class _TextureGCSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._renderer = renderer;
        this.count = 0;
        this.checkCount = 0;
      }
      init(options) {
        options = { ..._TextureGCSystem2.defaultOptions, ...options };
        this.checkCountMax = options.textureGCCheckCountMax;
        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;
        this.active = options.textureGCActive;
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      postrender() {
        if (!this._renderer.renderingToScreen) {
          return;
        }
        this.count++;
        if (!this.active)
          return;
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
          this.checkCount = 0;
          this.run();
        }
      }
      /**
       * Checks to see when the last time a texture was used.
       * If the texture has not been used for a specified amount of time, it will be removed from the GPU.
       */
      run() {
        const managedTextures = this._renderer.texture.managedTextures;
        for (let i2 = 0; i2 < managedTextures.length; i2++) {
          const texture = managedTextures[i2];
          if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {
            texture._touched = -1;
            texture.unload();
          }
        }
      }
      destroy() {
        this._renderer = null;
      }
    };
    _TextureGCSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem
      ],
      name: "textureGC"
    };
    _TextureGCSystem.defaultOptions = {
      /**
       * If set to true, this will enable the garbage collector on the GPU.
       * @default true
       */
      textureGCActive: true,
      /**
       * @deprecated since 8.3.0
       * @see {@link TextureGCSystem.textureGCMaxIdle}
       */
      textureGCAMaxIdle: null,
      /**
       * The maximum idle frames before a texture is destroyed by garbage collection.
       * @default 60 * 60
       */
      textureGCMaxIdle: 60 * 60,
      /**
       * Frames between two garbage collections.
       * @default 600
       */
      textureGCCheckCountMax: 600
    };
    TextureGCSystem = _TextureGCSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs
var _RenderTarget, RenderTarget;
var init_RenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs"() {
    init_uid();
    init_TextureSource();
    init_Texture();
    _RenderTarget = class _RenderTarget2 {
      /**
       * @param [descriptor] - Options for creating a render target.
       */
      constructor(descriptor = {}) {
        this.uid = uid("renderTarget");
        this.colorTextures = [];
        this.dirtyId = 0;
        this.isRoot = false;
        this._size = new Float32Array(2);
        this._managedColorTextures = false;
        descriptor = { ..._RenderTarget2.defaultOptions, ...descriptor };
        this.stencil = descriptor.stencil;
        this.depth = descriptor.depth;
        this.isRoot = descriptor.isRoot;
        if (typeof descriptor.colorTextures === "number") {
          this._managedColorTextures = true;
          for (let i2 = 0; i2 < descriptor.colorTextures; i2++) {
            this.colorTextures.push(
              new TextureSource({
                width: descriptor.width,
                height: descriptor.height,
                resolution: descriptor.resolution,
                antialias: descriptor.antialias
              })
            );
          }
        } else {
          this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];
          const colorSource = this.colorTexture.source;
          this.resize(colorSource.width, colorSource.height, colorSource._resolution);
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this);
        if (descriptor.depthStencilTexture || this.stencil) {
          if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {
            this.depthStencilTexture = descriptor.depthStencilTexture.source;
          } else {
            this.ensureDepthStencilTexture();
          }
        }
      }
      get size() {
        const _size = this._size;
        _size[0] = this.pixelWidth;
        _size[1] = this.pixelHeight;
        return _size;
      }
      get width() {
        return this.colorTexture.source.width;
      }
      get height() {
        return this.colorTexture.source.height;
      }
      get pixelWidth() {
        return this.colorTexture.source.pixelWidth;
      }
      get pixelHeight() {
        return this.colorTexture.source.pixelHeight;
      }
      get resolution() {
        return this.colorTexture.source._resolution;
      }
      get colorTexture() {
        return this.colorTextures[0];
      }
      onSourceResize(source2) {
        this.resize(source2.width, source2.height, source2._resolution, true);
      }
      /**
       * This will ensure a depthStencil texture is created for this render target.
       * Most likely called by the mask system to make sure we have stencil buffer added.
       * @internal
       * @ignore
       */
      ensureDepthStencilTexture() {
        if (!this.depthStencilTexture) {
          this.depthStencilTexture = new TextureSource({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: false,
            antialias: false,
            mipLevelCount: 1
            // sampleCount: handled by the render target system..
          });
        }
      }
      resize(width, height, resolution = this.resolution, skipColorTexture = false) {
        this.dirtyId++;
        this.colorTextures.forEach((colorTexture, i2) => {
          if (skipColorTexture && i2 === 0)
            return;
          colorTexture.source.resize(width, height, resolution);
        });
        if (this.depthStencilTexture) {
          this.depthStencilTexture.source.resize(width, height, resolution);
        }
      }
      destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this);
        if (this._managedColorTextures) {
          this.colorTextures.forEach((texture) => {
            texture.destroy();
          });
        }
        if (this.depthStencilTexture) {
          this.depthStencilTexture.destroy();
          delete this.depthStencilTexture;
        }
      }
    };
    _RenderTarget.defaultOptions = {
      /** the width of the RenderTarget */
      width: 0,
      /** the height of the RenderTarget */
      height: 0,
      /** the resolution of the RenderTarget */
      resolution: 1,
      /** an array of textures, or a number indicating how many color textures there should be */
      colorTextures: 1,
      /** should this render target have a stencil buffer? */
      stencil: false,
      /** should this render target have a depth buffer? */
      depth: false,
      /** should this render target be antialiased? */
      antialias: false,
      // save on perf by default!
      /** is this a root element, true if this is gl context owners render target */
      isRoot: false
    };
    RenderTarget = _RenderTarget;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs
function getCanvasTexture(canvas, options) {
  if (!canvasCache.has(canvas)) {
    const texture = new Texture({
      source: new CanvasSource({
        resource: canvas,
        ...options
      })
    });
    const onDestroy = () => {
      if (canvasCache.get(canvas) === texture) {
        canvasCache.delete(canvas);
      }
    };
    texture.once("destroy", onDestroy);
    texture.source.once("destroy", onDestroy);
    canvasCache.set(canvas, texture);
  }
  return canvasCache.get(canvas);
}
var canvasCache;
var init_getCanvasTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"() {
    init_CanvasSource();
    init_Texture();
    canvasCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs
var _ViewSystem, ViewSystem;
var init_ViewSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_Rectangle();
    init_deprecation();
    init_RenderTarget();
    init_getCanvasTexture();
    _ViewSystem = class _ViewSystem2 {
      /**
       * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.
       * @member {boolean}
       */
      get autoDensity() {
        return this.texture.source.autoDensity;
      }
      set autoDensity(value) {
        this.texture.source.autoDensity = value;
      }
      /** The resolution / device pixel ratio of the renderer. */
      get resolution() {
        return this.texture.source._resolution;
      }
      set resolution(value) {
        this.texture.source.resize(
          this.texture.source.width,
          this.texture.source.height,
          value
        );
      }
      /**
       * initiates the view system
       * @param options - the options for the view
       */
      init(options) {
        options = {
          ..._ViewSystem2.defaultOptions,
          ...options
        };
        if (options.view) {
          deprecation(v8_0_0, "ViewSystem.view has been renamed to ViewSystem.canvas");
          options.canvas = options.view;
        }
        this.screen = new Rectangle(0, 0, options.width, options.height);
        this.canvas = options.canvas || DOMAdapter.get().createCanvas();
        this.antialias = !!options.antialias;
        this.texture = getCanvasTexture(this.canvas, options);
        this.renderTarget = new RenderTarget({
          colorTextures: [this.texture],
          depth: !!options.depth,
          isRoot: true
        });
        this.texture.source.transparent = options.backgroundAlpha < 1;
        this.multiView = !!options.multiView;
        this.resolution = options.resolution;
      }
      /**
       * Resizes the screen and canvas to the specified dimensions.
       * @param desiredScreenWidth - The new width of the screen.
       * @param desiredScreenHeight - The new height of the screen.
       * @param resolution
       */
      resize(desiredScreenWidth, desiredScreenHeight, resolution) {
        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);
        this.screen.width = this.texture.frame.width;
        this.screen.height = this.texture.frame.height;
      }
      /**
       * Destroys this System and optionally removes the canvas from the dom.
       * @param {options | false} options - The options for destroying the view, or "false".
       * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.
       */
      destroy(options = false) {
        const removeView = typeof options === "boolean" ? options : !!options?.removeView;
        if (removeView && this.canvas.parentNode) {
          this.canvas.parentNode.removeChild(this.canvas);
        }
      }
    };
    _ViewSystem.extension = {
      type: [
        ExtensionType.WebGLSystem,
        ExtensionType.WebGPUSystem,
        ExtensionType.CanvasSystem
      ],
      name: "view",
      priority: 0
    };
    _ViewSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.width}
       * @default 800
       */
      width: 800,
      /**
       * {@link WebGLOptions.height}
       * @default 600
       */
      height: 600,
      /**
       * {@link WebGLOptions.autoDensity}
       * @default false
       */
      autoDensity: false,
      /**
       * {@link WebGLOptions.antialias}
       * @default false
       */
      antialias: false
    };
    ViewSystem = _ViewSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs
var SharedSystems, SharedRenderPipes;
var init_SharedSystems = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs"() {
    init_CustomRenderPipe();
    init_RenderGroupPipe();
    init_RenderGroupSystem();
    init_SpritePipe();
    init_globalHooks();
    init_BatcherPipe();
    init_AlphaMaskPipe();
    init_ColorMaskPipe();
    init_StencilMaskPipe();
    init_BackgroundSystem();
    init_BlendModePipe();
    init_ExtractSystem();
    init_GenerateTextureSystem();
    init_GlobalUniformSystem();
    init_SchedulerSystem();
    init_HelloSystem();
    init_RenderableGCSystem();
    init_TextureGCSystem();
    init_ViewSystem();
    SharedSystems = [
      BackgroundSystem,
      GlobalUniformSystem,
      HelloSystem,
      ViewSystem,
      RenderGroupSystem,
      TextureGCSystem,
      GenerateTextureSystem,
      ExtractSystem,
      RendererInitHook,
      RenderableGCSystem,
      SchedulerSystem
    ];
    SharedRenderPipes = [
      BlendModePipe,
      BatcherPipe,
      SpritePipe,
      RenderGroupPipe,
      AlphaMaskPipe,
      StencilMaskPipe,
      ColorMaskPipe,
      CustomRenderPipe
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs
var BindGroupSystem;
var init_BindGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/BindGroupSystem.mjs"() {
    init_Extensions();
    BindGroupSystem = class {
      constructor(renderer) {
        this._hash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getBindGroup(bindGroup, program, groupIndex) {
        bindGroup._updateKey();
        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);
        return gpuBindGroup;
      }
      _createBindGroup(group, program, groupIndex) {
        const device = this._gpu.device;
        const groupLayout = program.layout[groupIndex];
        const entries = [];
        const renderer = this._renderer;
        for (const j3 in groupLayout) {
          const resource = group.resources[j3] ?? group.resources[groupLayout[j3]];
          let gpuResource;
          if (resource._resourceType === "uniformGroup") {
            const uniformGroup = resource;
            renderer.ubo.updateUniformGroup(uniformGroup);
            const buffer = uniformGroup.buffer;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "buffer") {
            const buffer = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(buffer),
              offset: 0,
              size: buffer.descriptor.size
            };
          } else if (resource._resourceType === "bufferResource") {
            const bufferResource = resource;
            gpuResource = {
              buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),
              offset: bufferResource.offset,
              size: bufferResource.size
            };
          } else if (resource._resourceType === "textureSampler") {
            const sampler = resource;
            gpuResource = renderer.texture.getGpuSampler(sampler);
          } else if (resource._resourceType === "textureSource") {
            const texture = resource;
            gpuResource = renderer.texture.getGpuSource(texture).createView({});
          }
          entries.push({
            binding: groupLayout[j3],
            resource: gpuResource
          });
        }
        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];
        const gpuBindGroup = device.createBindGroup({
          layout,
          entries
        });
        this._hash[group._key] = gpuBindGroup;
        return gpuBindGroup;
      }
      destroy() {
        for (const key of Object.keys(this._hash)) {
          this._hash[key] = null;
        }
        this._hash = null;
        this._renderer = null;
      }
    };
    BindGroupSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "bindGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs
var GpuBufferSystem;
var init_GpuBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/GpuBufferSystem.mjs"() {
    init_Extensions();
    init_fastCopy();
    GpuBufferSystem = class {
      constructor() {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._managedBuffers = [];
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      getGPUBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
      }
      updateBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);
        const data = buffer.data;
        if (buffer._updateID && data) {
          buffer._updateID = 0;
          this._gpu.device.queue.writeBuffer(
            gpuBuffer,
            0,
            data.buffer,
            0,
            // round to the nearest 4 bytes
            (buffer._updateSize || data.byteLength) + 3 & ~3
          );
        }
        return gpuBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        for (const id2 in this._gpuBuffers) {
          this._gpuBuffers[id2].destroy();
        }
        this._gpuBuffers = {};
      }
      createGPUBuffer(buffer) {
        if (!this._gpuBuffers[buffer.uid]) {
          buffer.on("update", this.updateBuffer, this);
          buffer.on("change", this.onBufferChange, this);
          buffer.on("destroy", this.onBufferDestroy, this);
          this._managedBuffers.push(buffer);
        }
        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);
        buffer._updateID = 0;
        if (buffer.data) {
          fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());
          gpuBuffer.unmap();
        }
        this._gpuBuffers[buffer.uid] = gpuBuffer;
        return gpuBuffer;
      }
      onBufferChange(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer._updateID = 0;
        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);
      }
      /**
       * Disposes buffer
       * @param buffer - buffer with data
       */
      onBufferDestroy(buffer) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);
        this._destroyBuffer(buffer);
      }
      destroy() {
        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));
        this._managedBuffers = null;
        this._gpuBuffers = null;
      }
      _destroyBuffer(buffer) {
        const gpuBuffer = this._gpuBuffers[buffer.uid];
        gpuBuffer.destroy();
        buffer.off("update", this.updateBuffer, this);
        buffer.off("change", this.onBufferChange, this);
        buffer.off("destroy", this.onBufferDestroy, this);
        this._gpuBuffers[buffer.uid] = null;
      }
    };
    GpuBufferSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs
var GpuColorMaskSystem;
var init_GpuColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuColorMaskSystem.mjs"() {
    init_Extensions();
    GpuColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.pipeline.setColorMask(colorMask);
      }
      destroy() {
        this._renderer = null;
        this._colorMaskCache = null;
      }
    };
    GpuColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs
var GpuDeviceSystem;
var init_GpuDeviceSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuDeviceSystem.mjs"() {
    init_adapter();
    init_Extensions();
    GpuDeviceSystem = class {
      /**
       * @param {WebGPURenderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._renderer = renderer;
      }
      async init(options) {
        if (this._initPromise)
          return this._initPromise;
        this._initPromise = this._createDeviceAndAdaptor(options).then((gpu) => {
          this.gpu = gpu;
          this._renderer.runners.contextChange.emit(this.gpu);
        });
        return this._initPromise;
      }
      /**
       * Handle the context change event
       * @param gpu
       */
      contextChange(gpu) {
        this._renderer.gpu = gpu;
      }
      /**
       * Helper class to create a WebGL Context
       * @param {object} options - An options object that gets passed in to the canvas element containing the
       *    context attributes
       * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
       * @returns {WebGLRenderingContext} the WebGL context
       */
      async _createDeviceAndAdaptor(options) {
        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({
          powerPreference: options.powerPreference,
          forceFallbackAdapter: options.forceFallbackAdapter
        });
        const requiredFeatures = [
          "texture-compression-bc",
          "texture-compression-astc",
          "texture-compression-etc2"
        ].filter((feature) => adapter.features.has(feature));
        const device = await adapter.requestDevice({
          requiredFeatures
        });
        return { adapter, device };
      }
      destroy() {
        this.gpu = null;
        this._renderer = null;
      }
    };
    GpuDeviceSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "device"
    };
    GpuDeviceSystem.defaultOptions = {
      /**
       * {@link WebGPUOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * Force the use of the fallback adapter
       * @default false
       */
      forceFallbackAdapter: false
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs
var GpuEncoderSystem;
var init_GpuEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuEncoderSystem.mjs"() {
    init_Extensions();
    GpuEncoderSystem = class {
      constructor(renderer) {
        this._boundBindGroup = /* @__PURE__ */ Object.create(null);
        this._boundVertexBuffer = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      renderStart() {
        this.commandFinished = new Promise((resolve) => {
          this._resolveCommandFinished = resolve;
        });
        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      }
      beginRenderPass(gpuRenderTarget) {
        this.endRenderPass();
        this._clearCache();
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
      }
      endRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
        }
        this.renderPassEncoder = null;
      }
      setViewport(viewport) {
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      }
      setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
        this.setPipeline(pipeline);
      }
      setPipeline(pipeline) {
        if (this._boundPipeline === pipeline)
          return;
        this._boundPipeline = pipeline;
        this.renderPassEncoder.setPipeline(pipeline);
      }
      _setVertexBuffer(index2, buffer) {
        if (this._boundVertexBuffer[index2] === buffer)
          return;
        this._boundVertexBuffer[index2] = buffer;
        this.renderPassEncoder.setVertexBuffer(index2, this._renderer.buffer.updateBuffer(buffer));
      }
      _setIndexBuffer(buffer) {
        if (this._boundIndexBuffer === buffer)
          return;
        this._boundIndexBuffer = buffer;
        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
      }
      resetBindGroup(index2) {
        this._boundBindGroup[index2] = null;
      }
      setBindGroup(index2, bindGroup, program) {
        if (this._boundBindGroup[index2] === bindGroup)
          return;
        this._boundBindGroup[index2] = bindGroup;
        bindGroup._touch(this._renderer.textureGC.count);
        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index2);
        this.renderPassEncoder.setBindGroup(index2, gpuBindGroup);
      }
      setGeometry(geometry, program) {
        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
        for (const i2 in buffersToBind) {
          this._setVertexBuffer(i2, geometry.attributes[buffersToBind[i2]].buffer);
        }
        if (geometry.indexBuffer) {
          this._setIndexBuffer(geometry.indexBuffer);
        }
      }
      _setShaderBindGroups(shader, skipSync) {
        for (const i2 in shader.groups) {
          const bindGroup = shader.groups[i2];
          if (!skipSync) {
            this._syncBindGroup(bindGroup);
          }
          this.setBindGroup(i2, bindGroup, shader.gpuProgram);
        }
      }
      _syncBindGroup(bindGroup) {
        for (const j3 in bindGroup.resources) {
          const resource = bindGroup.resources[j3];
          if (resource.isUniformGroup) {
            this._renderer.ubo.updateUniformGroup(resource);
          }
        }
      }
      draw(options) {
        const { geometry, shader, state, topology, size, start: start2, instanceCount, skipSync } = options;
        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
        this.setGeometry(geometry, shader.gpuProgram);
        this._setShaderBindGroups(shader, skipSync);
        if (geometry.indexBuffer) {
          this.renderPassEncoder.drawIndexed(
            size || geometry.indexBuffer.data.length,
            instanceCount || geometry.instanceCount,
            start2 || 0
          );
        } else {
          this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount || geometry.instanceCount, start2 || 0);
        }
      }
      finishRenderPass() {
        if (this.renderPassEncoder) {
          this.renderPassEncoder.end();
          this.renderPassEncoder = null;
        }
      }
      postrender() {
        this.finishRenderPass();
        this._gpu.device.queue.submit([this.commandEncoder.finish()]);
        this._resolveCommandFinished();
        this.commandEncoder = null;
      }
      // restores a render pass if finishRenderPass was called
      // not optimised as really used for debugging!
      // used when we want to stop drawing and log a texture..
      restoreRenderPass() {
        const descriptor = this._renderer.renderTarget.adaptor.getDescriptor(
          this._renderer.renderTarget.renderTarget,
          false,
          [0, 0, 0, 1]
        );
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
        const boundPipeline = this._boundPipeline;
        const boundVertexBuffer = { ...this._boundVertexBuffer };
        const boundIndexBuffer = this._boundIndexBuffer;
        const boundBindGroup = { ...this._boundBindGroup };
        this._clearCache();
        const viewport = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
        this.setPipeline(boundPipeline);
        for (const i2 in boundVertexBuffer) {
          this._setVertexBuffer(i2, boundVertexBuffer[i2]);
        }
        for (const i2 in boundBindGroup) {
          this.setBindGroup(i2, boundBindGroup[i2], null);
        }
        this._setIndexBuffer(boundIndexBuffer);
      }
      _clearCache() {
        for (let i2 = 0; i2 < 16; i2++) {
          this._boundBindGroup[i2] = null;
          this._boundVertexBuffer[i2] = null;
        }
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      destroy() {
        this._renderer = null;
        this._gpu = null;
        this._boundBindGroup = null;
        this._boundVertexBuffer = null;
        this._boundIndexBuffer = null;
        this._boundPipeline = null;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
    };
    GpuEncoderSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "encoder",
      priority: 1
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs
var GpuStencilSystem;
var init_GpuStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuStencilSystem.mjs"() {
    init_Extensions();
    init_const3();
    GpuStencilSystem = class {
      constructor(renderer) {
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(renderTarget) {
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this._activeRenderTarget = renderTarget;
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        const renderer = this._renderer;
        renderer.pipeline.setStencilMode(stencilMode);
        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);
      }
      destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this);
        this._renderer = null;
        this._activeRenderTarget = null;
        this._renderTargetStencilState = null;
      }
    };
    GpuStencilSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs
var UboSystem;
var init_UboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs"() {
    init_unsafeEvalSupported();
    init_Buffer();
    init_const4();
    UboSystem = class {
      constructor(adaptor) {
        this._syncFunctionHash = /* @__PURE__ */ Object.create(null);
        this._adaptor = adaptor;
        this._systemCheck();
      }
      /**
       * Overridable function by `pixi.js/unsafe-eval` to silence
       * throwing an error if platform doesn't support unsafe-evals.
       * @private
       */
      _systemCheck() {
        if (!unsafeEvalSupported()) {
          throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
        }
      }
      ensureUniformGroup(uniformGroup) {
        const uniformData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
      }
      getUniformGroupData(uniformGroup) {
        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
      }
      _initUniformGroup(uniformGroup) {
        const uniformGroupSignature = uniformGroup._signature;
        let uniformData = this._syncFunctionHash[uniformGroupSignature];
        if (!uniformData) {
          const elements = Object.keys(uniformGroup.uniformStructures).map((i2) => uniformGroup.uniformStructures[i2]);
          const layout = this._adaptor.createUboElements(elements);
          const syncFunction = this._generateUboSync(layout.uboElements);
          uniformData = this._syncFunctionHash[uniformGroupSignature] = {
            layout,
            syncFunction
          };
        }
        return this._syncFunctionHash[uniformGroupSignature];
      }
      _generateUboSync(uboElements) {
        return this._adaptor.generateUboSync(uboElements);
      }
      syncUniformGroup(uniformGroup, data, offset) {
        const uniformGroupData = this.getUniformGroupData(uniformGroup);
        uniformGroup.buffer || (uniformGroup.buffer = new Buffer2({
          data: new Float32Array(uniformGroupData.layout.size / 4),
          usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST
        }));
        data || (data = uniformGroup.buffer.data);
        offset || (offset = 0);
        uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);
        return true;
      }
      updateUniformGroup(uniformGroup) {
        if (uniformGroup.isStatic && !uniformGroup._dirtyId)
          return false;
        uniformGroup._dirtyId = 0;
        const synced = this.syncUniformGroup(uniformGroup);
        uniformGroup.buffer.update();
        return synced;
      }
      destroy() {
        this._syncFunctionHash = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs
function createUboElementsWGSL(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;
    const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;
    if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type]) {
      throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, align) * uboElement.data.size;
    }
    offset = Math.ceil(offset / align) * align;
    uboElement.size = size;
    uboElement.offset = offset;
    offset += size;
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_ALIGN_SIZE_DATA;
var init_createUboElementsWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.mjs"() {
    "use strict";
    WGSL_ALIGN_SIZE_DATA = {
      i32: { align: 4, size: 4 },
      u32: { align: 4, size: 4 },
      f32: { align: 4, size: 4 },
      f16: { align: 2, size: 2 },
      "vec2<i32>": { align: 8, size: 8 },
      "vec2<u32>": { align: 8, size: 8 },
      "vec2<f32>": { align: 8, size: 8 },
      "vec2<f16>": { align: 4, size: 4 },
      "vec3<i32>": { align: 16, size: 12 },
      "vec3<u32>": { align: 16, size: 12 },
      "vec3<f32>": { align: 16, size: 12 },
      "vec3<f16>": { align: 8, size: 6 },
      "vec4<i32>": { align: 16, size: 16 },
      "vec4<u32>": { align: 16, size: 16 },
      "vec4<f32>": { align: 16, size: 16 },
      "vec4<f16>": { align: 8, size: 8 },
      "mat2x2<f32>": { align: 8, size: 16 },
      "mat2x2<f16>": { align: 4, size: 8 },
      "mat3x2<f32>": { align: 8, size: 24 },
      "mat3x2<f16>": { align: 4, size: 12 },
      "mat4x2<f32>": { align: 8, size: 32 },
      "mat4x2<f16>": { align: 4, size: 16 },
      "mat2x3<f32>": { align: 16, size: 32 },
      "mat2x3<f16>": { align: 8, size: 16 },
      "mat3x3<f32>": { align: 16, size: 48 },
      "mat3x3<f16>": { align: 8, size: 24 },
      "mat4x3<f32>": { align: 16, size: 64 },
      "mat4x3<f16>": { align: 8, size: 32 },
      "mat2x4<f32>": { align: 16, size: 32 },
      "mat2x4<f16>": { align: 8, size: 16 },
      "mat3x4<f32>": { align: 16, size: 48 },
      "mat3x4<f16>": { align: 8, size: 24 },
      "mat4x4<f32>": { align: 16, size: 64 },
      "mat4x4<f16>": { align: 8, size: 32 }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs
var uniformParsers;
var init_uniformParsers = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs"() {
    "use strict";
    uniformParsers = [
      // uploading pixi matrix object to mat3
      {
        type: "mat3x3<f32>",
        test: (data) => {
          const value = data.value;
          return value.a !== void 0;
        },
        ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
        uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
      },
      // uploading a pixi rectangle as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.width !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
      },
      // uploading a pixi point as a vec2
      {
        type: "vec2<f32>",
        test: (data) => data.type === "vec2<f32>" && data.size === 1 && data.value.x !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
      },
      // uploading a pixi color as a vec4
      {
        type: "vec4<f32>",
        test: (data) => data.type === "vec4<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
      },
      // uploading a pixi color as a vec3
      {
        type: "vec3<f32>",
        test: (data) => data.type === "vec3<f32>" && data.size === 1 && data.value.red !== void 0,
        ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
        uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
      }
    ];
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs
function createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {
  const funcFragments = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
  let prev = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    const name = uboElement.data.name;
    let parsed = false;
    let offset = 0;
    for (let j3 = 0; j3 < uniformParsers.length; j3++) {
      const uniformParser = uniformParsers[j3];
      if (uniformParser.test(uboElement.data)) {
        offset = uboElement.offset / 4;
        funcFragments.push(
          `name = "${name}";`,
          `offset += ${offset - prev};`,
          uniformParsers[j3][parserCode] || uniformParsers[j3].ubo
        );
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      if (uboElement.data.size > 1) {
        offset = uboElement.offset / 4;
        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));
      } else {
        const template = singleSettersMap[uboElement.data.type];
        offset = uboElement.offset / 4;
        funcFragments.push(
          /* wgsl */
          `
                    v = uv.${name};
                    offset += ${offset - prev};
                    ${template};
                `
        );
      }
    }
    prev = offset;
  }
  const fragmentSrc = funcFragments.join("\n");
  return new Function(
    "uv",
    "data",
    "offset",
    fragmentSrc
  );
}
var init_createUboSyncFunction = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs"() {
    init_uniformParsers();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs
function loopMatrix(col, row) {
  const total = col * row;
  return `
        for (let i = 0; i < ${total}; i++) {
            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];
        }
    `;
}
var uboSyncFunctionsSTD40, uboSyncFunctionsWGSL;
var init_uboSyncFunctions = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs"() {
    "use strict";
    uboSyncFunctionsSTD40 = {
      f32: `
        data[offset] = v;`,
      i32: `
        data[offset] = v;`,
      "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
      "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
      "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
      "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
      "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
      "mat3x2<f32>": loopMatrix(3, 2),
      "mat4x2<f32>": loopMatrix(4, 2),
      "mat2x3<f32>": loopMatrix(2, 3),
      "mat4x3<f32>": loopMatrix(4, 3),
      "mat2x4<f32>": loopMatrix(2, 4),
      "mat3x4<f32>": loopMatrix(3, 4)
    };
    uboSyncFunctionsWGSL = {
      ...uboSyncFunctionsSTD40,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs
function generateArraySyncWGSL(uboElement, offsetToAdd) {
  const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];
  const remainder = (align - size) / 4;
  return `
         v = uv.${uboElement.data.name};
         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)
         {
             for(var j = 0; j < ${size / 4}; j++)
             {
                 data[arrayOffset++] = v[t++];
             }
             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
         }
     `;
}
var init_generateArraySyncWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.mjs"() {
    init_createUboElementsWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs
function createUboSyncFunctionWGSL(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboWgsl",
    generateArraySyncWGSL,
    uboSyncFunctionsWGSL
  );
}
var init_createUboSyncFunctionWGSL = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.mjs"() {
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncWGSL();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs
var GpuUboSystem;
var init_GpuUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUboSystem.mjs"() {
    init_Extensions();
    init_UboSystem();
    init_createUboElementsWGSL();
    init_createUboSyncFunctionWGSL();
    GpuUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsWGSL,
          generateUboSync: createUboSyncFunctionWGSL
        });
      }
    };
    GpuUboSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs
var BufferResource;
var init_BufferResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs"() {
    init_eventemitter3();
    init_uid();
    BufferResource = class extends eventemitter3_default {
      /**
       * Create a new Buffer Resource.
       * @param options - The options for the buffer resource
       * @param options.buffer - The underlying buffer that this resource is using
       * @param options.offset - The offset of the buffer this resource is using.
       * If not provided, then it will use the offset of the buffer.
       * @param options.size - The size of the buffer this resource is using.
       * If not provided, then it will use the size of the buffer.
       */
      constructor({ buffer, offset, size }) {
        super();
        this.uid = uid("buffer");
        this._resourceType = "bufferResource";
        this._touched = 0;
        this._resourceId = uid("resource");
        this._bufferResource = true;
        this.destroyed = false;
        this.buffer = buffer;
        this.offset = offset | 0;
        this.size = size;
        this.buffer.on("change", this.onBufferChange, this);
      }
      onBufferChange() {
        this._resourceId = uid("resource");
        this.emit("change", this);
      }
      /**
       * Destroys this resource. Make sure the underlying buffer is not used anywhere else
       * if you want to destroy it as well, or code will explode
       * @param destroyBuffer - Should the underlying buffer be destroyed as well?
       */
      destroy(destroyBuffer = false) {
        this.destroyed = true;
        if (destroyBuffer) {
          this.buffer.destroy();
        }
        this.emit("change", this);
        this.buffer = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs
var UboBatch;
var init_UboBatch = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/buffer/UboBatch.mjs"() {
    "use strict";
    UboBatch = class {
      constructor({ minUniformOffsetAlignment: minUniformOffsetAlignment2 }) {
        this._minUniformOffsetAlignment = 256;
        this.byteIndex = 0;
        this._minUniformOffsetAlignment = minUniformOffsetAlignment2;
        this.data = new Float32Array(65535);
      }
      clear() {
        this.byteIndex = 0;
      }
      addEmptyGroup(size) {
        if (size > this._minUniformOffsetAlignment / 4) {
          throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);
        }
        const start2 = this.byteIndex;
        let newSize = start2 + size * 4;
        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;
        if (newSize > this.data.length * 4) {
          throw new Error("UniformBufferBatch: ubo batch got too big");
        }
        this.byteIndex = newSize;
        return start2;
      }
      addGroup(array2) {
        const offset = this.addEmptyGroup(array2.length);
        for (let i2 = 0; i2 < array2.length; i2++) {
          this.data[offset / 4 + i2] = array2[i2];
        }
        return offset;
      }
      destroy() {
        this._buffer.destroy();
        this._buffer = null;
        this.data = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs
var minUniformOffsetAlignment, GpuUniformBatchPipe;
var init_GpuUniformBatchPipe = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/GpuUniformBatchPipe.mjs"() {
    init_Extensions();
    init_Buffer();
    init_BufferResource();
    init_const4();
    init_UboBatch();
    init_BindGroup();
    minUniformOffsetAlignment = 128;
    GpuUniformBatchPipe = class {
      constructor(renderer) {
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._buffers = [];
        this._bindGroups = [];
        this._bufferResources = [];
        this._renderer = renderer;
        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });
        const totalBuffers = 256 / minUniformOffsetAlignment;
        for (let i2 = 0; i2 < totalBuffers; i2++) {
          let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;
          if (i2 === 0)
            usage |= BufferUsage.COPY_SRC;
          this._buffers.push(new Buffer2({
            data: this._batchBuffer.data,
            usage
          }));
        }
      }
      renderEnd() {
        this._uploadBindGroups();
        this._resetBindGroups();
      }
      _resetBindGroups() {
        for (const i2 in this._bindGroupHash) {
          this._bindGroupHash[i2] = null;
        }
        this._batchBuffer.clear();
      }
      // just works for single bind groups for now
      getUniformBindGroup(group, duplicate) {
        if (!duplicate && this._bindGroupHash[group.uid]) {
          return this._bindGroupHash[group.uid];
        }
        this._renderer.ubo.ensureUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addEmptyGroup(data.length);
        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);
        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);
        return this._bindGroupHash[group.uid];
      }
      getUboResource(group) {
        this._renderer.ubo.updateUniformGroup(group);
        const data = group.buffer.data;
        const offset = this._batchBuffer.addGroup(data);
        return this._getBufferResource(offset / minUniformOffsetAlignment);
      }
      getArrayBindGroup(data) {
        const offset = this._batchBuffer.addGroup(data);
        return this._getBindGroup(offset / minUniformOffsetAlignment);
      }
      getArrayBufferResource(data) {
        const offset = this._batchBuffer.addGroup(data);
        const index2 = offset / minUniformOffsetAlignment;
        return this._getBufferResource(index2);
      }
      _getBufferResource(index2) {
        if (!this._bufferResources[index2]) {
          const buffer = this._buffers[index2 % 2];
          this._bufferResources[index2] = new BufferResource({
            buffer,
            offset: (index2 / 2 | 0) * 256,
            size: minUniformOffsetAlignment
          });
        }
        return this._bufferResources[index2];
      }
      _getBindGroup(index2) {
        if (!this._bindGroups[index2]) {
          const bindGroup = new BindGroup({
            0: this._getBufferResource(index2)
          });
          this._bindGroups[index2] = bindGroup;
        }
        return this._bindGroups[index2];
      }
      _uploadBindGroups() {
        const bufferSystem = this._renderer.buffer;
        const firstBuffer = this._buffers[0];
        firstBuffer.update(this._batchBuffer.byteIndex);
        bufferSystem.updateBuffer(firstBuffer);
        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
        for (let i2 = 1; i2 < this._buffers.length; i2++) {
          const buffer = this._buffers[i2];
          commandEncoder.copyBufferToBuffer(
            bufferSystem.getGPUBuffer(firstBuffer),
            minUniformOffsetAlignment,
            bufferSystem.getGPUBuffer(buffer),
            0,
            this._batchBuffer.byteIndex
          );
        }
        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      }
      destroy() {
        for (let i2 = 0; i2 < this._bindGroups.length; i2++) {
          this._bindGroups[i2].destroy();
        }
        this._bindGroups = null;
        this._bindGroupHash = null;
        for (let i2 = 0; i2 < this._buffers.length; i2++) {
          this._buffers[i2].destroy();
        }
        this._buffers = null;
        for (let i2 = 0; i2 < this._bufferResources.length; i2++) {
          this._bufferResources[i2].destroy();
        }
        this._bufferResources = null;
        this._batchBuffer.destroy();
        this._bindGroupHash = null;
        this._renderer = null;
      }
    };
    GpuUniformBatchPipe.extension = {
      type: [
        ExtensionType.WebGPUPipes
      ],
      name: "uniformBatch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs
function ensureAttributes(geometry, extractedData) {
  for (const i2 in geometry.attributes) {
    const attribute = geometry.attributes[i2];
    const attributeData = extractedData[i2];
    if (attributeData) {
      attribute.format ?? (attribute.format = attributeData.format);
      attribute.offset ?? (attribute.offset = attributeData.offset);
      attribute.instance ?? (attribute.instance = attributeData.instance);
    } else {
      warn(`Attribute ${i2} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);
    }
  }
  ensureStartAndStride(geometry);
}
function ensureStartAndStride(geometry) {
  const { buffers, attributes } = geometry;
  const tempStride = {};
  const tempStart = {};
  for (const j3 in buffers) {
    const buffer = buffers[j3];
    tempStride[buffer.uid] = 0;
    tempStart[buffer.uid] = 0;
  }
  for (const j3 in attributes) {
    const attribute = attributes[j3];
    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
  for (const j3 in attributes) {
    const attribute = attributes[j3];
    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);
    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);
    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;
  }
}
var init_ensureAttributes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs"() {
    init_warn();
    init_getAttributeInfoFromFormat();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs
var GpuStencilModesToPixi;
var init_GpuStencilModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs"() {
    init_const3();
    GpuStencilModesToPixi = [];
    GpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;
    GpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {
      stencilWriteMask: 0,
      stencilReadMask: 0
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {
      stencilFront: {
        compare: "equal",
        passOp: "increment-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "increment-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {
      stencilFront: {
        compare: "equal",
        passOp: "decrement-clamp"
      },
      stencilBack: {
        compare: "equal",
        passOp: "decrement-clamp"
      }
    };
    GpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: {
        compare: "equal",
        passOp: "keep"
      },
      stencilBack: {
        compare: "equal",
        passOp: "keep"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs
function getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {
  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;
}
function getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {
  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;
}
var topologyStringToId, PipelineSystem;
var init_PipelineSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/pipeline/PipelineSystem.mjs"() {
    init_Extensions();
    init_warn();
    init_ensureAttributes();
    init_const3();
    init_createIdFromString();
    init_GpuStencilModesToPixi();
    topologyStringToId = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 2,
      "triangle-list": 3,
      "triangle-strip": 4
    };
    PipelineSystem = class {
      constructor(renderer) {
        this._moduleCache = /* @__PURE__ */ Object.create(null);
        this._bufferLayoutsCache = /* @__PURE__ */ Object.create(null);
        this._bindingNamesCache = /* @__PURE__ */ Object.create(null);
        this._pipeCache = /* @__PURE__ */ Object.create(null);
        this._pipeStateCaches = /* @__PURE__ */ Object.create(null);
        this._colorMask = 15;
        this._multisampleCount = 1;
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.setStencilMode(STENCIL_MODES.DISABLED);
        this._updatePipeHash();
      }
      setMultisampleCount(multisampleCount) {
        if (this._multisampleCount === multisampleCount)
          return;
        this._multisampleCount = multisampleCount;
        this._updatePipeHash();
      }
      setRenderTarget(renderTarget) {
        this._multisampleCount = renderTarget.msaaSamples;
        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;
        this._updatePipeHash();
      }
      setColorMask(colorMask) {
        if (this._colorMask === colorMask)
          return;
        this._colorMask = colorMask;
        this._updatePipeHash();
      }
      setStencilMode(stencilMode) {
        if (this._stencilMode === stencilMode)
          return;
        this._stencilMode = stencilMode;
        this._stencilState = GpuStencilModesToPixi[stencilMode];
        this._updatePipeHash();
      }
      setPipeline(geometry, program, state, passEncoder) {
        const pipeline = this.getPipeline(geometry, program, state);
        passEncoder.setPipeline(pipeline);
      }
      getPipeline(geometry, program, state, topology) {
        if (!geometry._layoutKey) {
          ensureAttributes(geometry, program.attributeData);
          this._generateBufferKey(geometry);
        }
        topology = topology || geometry.topology;
        const key = getGraphicsStateKey(
          geometry._layoutKey,
          program._layoutKey,
          state.data,
          state._blendModeId,
          topologyStringToId[topology]
        );
        if (this._pipeCache[key])
          return this._pipeCache[key];
        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);
        return this._pipeCache[key];
      }
      _createPipeline(geometry, program, state, topology) {
        const device = this._gpu.device;
        const buffers = this._createVertexBufferLayouts(geometry, program);
        const blendModes = this._renderer.state.getColorTargets(state);
        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const layout = this._renderer.shader.getProgramData(program).pipeline;
        const descriptor = {
          // TODO later check if its helpful to create..
          // layout,
          vertex: {
            module: this._getModule(program.vertex.source),
            entryPoint: program.vertex.entryPoint,
            // geometry..
            buffers
          },
          fragment: {
            module: this._getModule(program.fragment.source),
            entryPoint: program.fragment.entryPoint,
            targets: blendModes
          },
          primitive: {
            topology,
            cullMode: state.cullMode
          },
          layout,
          multisample: {
            count: this._multisampleCount
          },
          // depthStencil,
          label: `PIXI Pipeline`
        };
        if (this._depthStencilAttachment) {
          descriptor.depthStencil = {
            ...this._stencilState,
            format: "depth24plus-stencil8",
            depthWriteEnabled: state.depthTest,
            depthCompare: state.depthTest ? "less" : "always"
          };
        }
        const pipeline = device.createRenderPipeline(descriptor);
        return pipeline;
      }
      _getModule(code) {
        return this._moduleCache[code] || this._createModule(code);
      }
      _createModule(code) {
        const device = this._gpu.device;
        this._moduleCache[code] = device.createShaderModule({
          code
        });
        return this._moduleCache[code];
      }
      _generateBufferKey(geometry) {
        const keyGen = [];
        let index2 = 0;
        const attributeKeys = Object.keys(geometry.attributes).sort();
        for (let i2 = 0; i2 < attributeKeys.length; i2++) {
          const attribute = geometry.attributes[attributeKeys[i2]];
          keyGen[index2++] = attribute.offset;
          keyGen[index2++] = attribute.format;
          keyGen[index2++] = attribute.stride;
          keyGen[index2++] = attribute.instance;
        }
        const stringKey = keyGen.join("|");
        geometry._layoutKey = createIdFromString(stringKey, "geometry");
        return geometry._layoutKey;
      }
      _generateAttributeLocationsKey(program) {
        const keyGen = [];
        let index2 = 0;
        const attributeKeys = Object.keys(program.attributeData).sort();
        for (let i2 = 0; i2 < attributeKeys.length; i2++) {
          const attribute = program.attributeData[attributeKeys[i2]];
          keyGen[index2++] = attribute.location;
        }
        const stringKey = keyGen.join("|");
        program._attributeLocationsKey = createIdFromString(stringKey, "programAttributes");
        return program._attributeLocationsKey;
      }
      /**
       * Returns a hash of buffer names mapped to bind locations.
       * This is used to bind the correct buffer to the correct location in the shader.
       * @param geometry - The geometry where to get the buffer names
       * @param program - The program where to get the buffer names
       * @returns An object of buffer names mapped to the bind location.
       */
      getBufferNamesToBind(geometry, program) {
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bindingNamesCache[key])
          return this._bindingNamesCache[key];
        const data = this._createVertexBufferLayouts(geometry, program);
        const bufferNamesToBind = /* @__PURE__ */ Object.create(null);
        const attributeData = program.attributeData;
        for (let i2 = 0; i2 < data.length; i2++) {
          for (const j3 in attributeData) {
            if (attributeData[j3].location === i2) {
              bufferNamesToBind[i2] = j3;
              break;
            }
          }
        }
        this._bindingNamesCache[key] = bufferNamesToBind;
        return bufferNamesToBind;
      }
      _createVertexBufferLayouts(geometry, program) {
        if (!program._attributeLocationsKey)
          this._generateAttributeLocationsKey(program);
        const key = geometry._layoutKey << 16 | program._attributeLocationsKey;
        if (this._bufferLayoutsCache[key]) {
          return this._bufferLayoutsCache[key];
        }
        const vertexBuffersLayout = [];
        geometry.buffers.forEach((buffer) => {
          const bufferEntry = {
            arrayStride: 0,
            stepMode: "vertex",
            attributes: []
          };
          const bufferEntryAttributes = bufferEntry.attributes;
          for (const i2 in program.attributeData) {
            const attribute = geometry.attributes[i2];
            if ((attribute.divisor ?? 1) !== 1) {
              warn(`Attribute ${i2} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);
            }
            if (attribute.buffer === buffer) {
              bufferEntry.arrayStride = attribute.stride;
              bufferEntry.stepMode = attribute.instance ? "instance" : "vertex";
              bufferEntryAttributes.push({
                shaderLocation: program.attributeData[i2].location,
                offset: attribute.offset,
                format: attribute.format
              });
            }
          }
          if (bufferEntryAttributes.length) {
            vertexBuffersLayout.push(bufferEntry);
          }
        });
        this._bufferLayoutsCache[key] = vertexBuffersLayout;
        return vertexBuffersLayout;
      }
      _updatePipeHash() {
        const key = getGlobalStateKey(
          this._stencilMode,
          this._multisampleCount,
          this._colorMask,
          this._depthStencilAttachment
        );
        if (!this._pipeStateCaches[key]) {
          this._pipeStateCaches[key] = /* @__PURE__ */ Object.create(null);
        }
        this._pipeCache = this._pipeStateCaches[key];
      }
      destroy() {
        this._renderer = null;
        this._bufferLayoutsCache = null;
      }
    };
    PipelineSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "pipeline"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs
function calculateProjection(pm, x5, y4, width, height, flipY) {
  const sign = flipY ? 1 : -1;
  pm.identity();
  pm.a = 1 / width * 2;
  pm.d = sign * (1 / height * 2);
  pm.tx = -1 - x5 * pm.a;
  pm.ty = -sign - y4 * pm.d;
  return pm;
}
var init_calculateProjection = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs
function isRenderingToScreen(renderTarget) {
  const resource = renderTarget.colorTexture.source.resource;
  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);
}
var init_isRenderingToScreen = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs
var RenderTargetSystem;
var init_RenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs"() {
    init_Matrix();
    init_Rectangle();
    init_const7();
    init_calculateProjection();
    init_SystemRunner();
    init_CanvasSource();
    init_TextureSource();
    init_Texture();
    init_getCanvasTexture();
    init_isRenderingToScreen();
    init_RenderTarget();
    RenderTargetSystem = class {
      constructor(renderer) {
        this.rootViewPort = new Rectangle();
        this.viewport = new Rectangle();
        this.onRenderTargetChange = new SystemRunner("onRenderTargetChange");
        this.projectionMatrix = new Matrix();
        this.defaultClearColor = [0, 0, 0, 0];
        this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
        this._renderTargetStack = [];
        this._renderer = renderer;
      }
      /** called when dev wants to finish a render pass */
      finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget);
      }
      /**
       * called when the renderer starts to render a scene.
       * @param options
       * @param options.target - the render target to render to
       * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param options.clearColor - the color to clear to
       * @param options.frame - the frame to render to
       */
      renderStart({
        target,
        clear,
        clearColor,
        frame: frame2
      }) {
        this._renderTargetStack.length = 0;
        this.push(
          target,
          clear,
          clearColor,
          frame2
        );
        this.rootViewPort.copyFrom(this.viewport);
        this.rootRenderTarget = this.renderTarget;
        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);
      }
      /**
       * Binding a render surface! This is the main function of the render target system.
       * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.
       * Once bound all draw calls will be rendered to the render surface.
       *
       * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.
       * @param renderSurface - the render surface to bind
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to render to
       * @returns the render target that was bound
       */
      bind(renderSurface, clear = true, clearColor, frame2) {
        const renderTarget = this.getRenderTarget(renderSurface);
        const didChange = this.renderTarget !== renderTarget;
        this.renderTarget = renderTarget;
        this.renderSurface = renderSurface;
        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
        if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
          this.adaptor.resizeGpuRenderTarget(renderTarget);
          gpuRenderTarget.width = renderTarget.pixelWidth;
          gpuRenderTarget.height = renderTarget.pixelHeight;
        }
        const source2 = renderTarget.colorTexture;
        const viewport = this.viewport;
        const pixelWidth = source2.pixelWidth;
        const pixelHeight = source2.pixelHeight;
        if (!frame2 && renderSurface instanceof Texture) {
          frame2 = renderSurface.frame;
        }
        if (frame2) {
          const resolution = source2._resolution;
          viewport.x = frame2.x * resolution + 0.5 | 0;
          viewport.y = frame2.y * resolution + 0.5 | 0;
          viewport.width = frame2.width * resolution + 0.5 | 0;
          viewport.height = frame2.height * resolution + 0.5 | 0;
        } else {
          viewport.x = 0;
          viewport.y = 0;
          viewport.width = pixelWidth;
          viewport.height = pixelHeight;
        }
        calculateProjection(
          this.projectionMatrix,
          0,
          0,
          viewport.width / source2.resolution,
          viewport.height / source2.resolution,
          !renderTarget.isRoot
        );
        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
        if (didChange) {
          this.onRenderTargetChange.emit(renderTarget);
        }
        return renderTarget;
      }
      clear(target, clear = CLEAR.ALL, clearColor) {
        if (!clear)
          return;
        if (target) {
          target = this.getRenderTarget(target);
        }
        this.adaptor.clear(
          target || this.renderTarget,
          clear,
          clearColor,
          this.viewport
        );
      }
      contextChange() {
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Push a render surface to the renderer. This will bind the render surface to the renderer,
       * @param renderSurface - the render surface to push
       * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111
       * @param clearColor - the color to clear to
       * @param frame - the frame to use when rendering to the render surface
       */
      push(renderSurface, clear = CLEAR.ALL, clearColor, frame2) {
        const renderTarget = this.bind(renderSurface, clear, clearColor, frame2);
        this._renderTargetStack.push({
          renderTarget,
          frame: frame2
        });
        return renderTarget;
      }
      /** Pops the current render target from the renderer and restores the previous render target. */
      pop() {
        this._renderTargetStack.pop();
        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);
      }
      /**
       * Gets the render target from the provide render surface. Eg if its a texture,
       * it will return the render target for the texture.
       * If its a render target, it will return the same render target.
       * @param renderSurface - the render surface to get the render target for
       * @returns the render target for the render surface
       */
      getRenderTarget(renderSurface) {
        if (renderSurface.isTexture) {
          renderSurface = renderSurface.source;
        }
        return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
      }
      /**
       * Copies a render surface to another texture
       * @param sourceRenderSurfaceTexture - the render surface to copy from
       * @param destinationTexture - the texture to copy to
       * @param originSrc - the origin of the copy
       * @param originSrc.x - the x origin of the copy
       * @param originSrc.y - the y origin of the copy
       * @param size - the size of the copy
       * @param size.width - the width of the copy
       * @param size.height - the height of the copy
       * @param originDest - the destination origin (top left to paste from!)
       * @param originDest.x - the x origin of the paste
       * @param originDest.y - the y origin of the paste
       */
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        if (originSrc.x < 0) {
          size.width += originSrc.x;
          originDest.x -= originSrc.x;
          originSrc.x = 0;
        }
        if (originSrc.y < 0) {
          size.height += originSrc.y;
          originDest.y -= originSrc.y;
          originSrc.y = 0;
        }
        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;
        size.width = Math.min(size.width, pixelWidth - originSrc.x);
        size.height = Math.min(size.height, pixelHeight - originSrc.y);
        return this.adaptor.copyToTexture(
          sourceRenderSurfaceTexture,
          destinationTexture,
          originSrc,
          size,
          originDest
        );
      }
      /**
       * ensures that we have a depth stencil buffer available to render to
       * This is used by the mask system to make sure we have a stencil buffer.
       */
      ensureDepthStencil() {
        if (!this.renderTarget.stencil) {
          this.renderTarget.stencil = true;
          this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);
        }
      }
      /** nukes the render target system */
      destroy() {
        this._renderer = null;
        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
          if (renderTarget !== key) {
            renderTarget.destroy();
          }
        });
        this._renderSurfaceToRenderTargetHash.clear();
        this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);
      }
      _initRenderTarget(renderSurface) {
        let renderTarget = null;
        if (CanvasSource.test(renderSurface)) {
          renderSurface = getCanvasTexture(renderSurface).source;
        }
        if (renderSurface instanceof RenderTarget) {
          renderTarget = renderSurface;
        } else if (renderSurface instanceof TextureSource) {
          renderTarget = new RenderTarget({
            colorTextures: [renderSurface]
          });
          if (CanvasSource.test(renderSurface.source.resource)) {
            renderTarget.isRoot = true;
          }
          renderSurface.once("destroy", () => {
            renderTarget.destroy();
            this._renderSurfaceToRenderTargetHash.delete(renderSurface);
            const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
            if (gpuRenderTarget) {
              this._gpuRenderTargetHash[renderTarget.uid] = null;
              this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);
            }
          });
        }
        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
        return renderTarget;
      }
      getGpuRenderTarget(renderTarget) {
        return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs
var GpuRenderTarget;
var init_GpuRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTarget.mjs"() {
    "use strict";
    GpuRenderTarget = class {
      constructor() {
        this.contexts = [];
        this.msaaTextures = [];
        this.msaaSamples = 1;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs
var GpuRenderTargetAdaptor;
var init_GpuRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.mjs"() {
    init_const7();
    init_CanvasSource();
    init_TextureSource();
    init_GpuRenderTarget();
    GpuRenderTargetAdaptor = class {
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderer = this._renderer;
        const baseGpuTexture = this._getGpuColorTexture(
          sourceRenderSurfaceTexture
        );
        const backGpuTexture = renderer.texture.getGpuSource(
          destinationTexture.source
        );
        renderer.encoder.commandEncoder.copyTextureToTexture(
          {
            texture: baseGpuTexture,
            origin: originSrc
          },
          {
            texture: backGpuTexture,
            origin: originDest
          },
          size
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);
        gpuRenderTarget.descriptor = descriptor;
        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
        this._renderer.encoder.beginRenderPass(gpuRenderTarget);
        this._renderer.encoder.setViewport(viewport);
      }
      finishRenderPass() {
        this._renderer.encoder.endRenderPass();
      }
      /**
       * returns the gpu texture for the first color texture in the render target
       * mainly used by the filter manager to get copy the texture for blending
       * @param renderTarget
       * @returns a gpu texture
       */
      _getGpuColorTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (gpuRenderTarget.contexts[0]) {
          return gpuRenderTarget.contexts[0].getCurrentTexture();
        }
        return this._renderer.texture.getGpuSource(
          renderTarget.colorTextures[0].source
        );
      }
      getDescriptor(renderTarget, clear, clearValue) {
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const renderTargetSystem = this._renderTargetSystem;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        const colorAttachments = renderTarget.colorTextures.map(
          (texture, i2) => {
            const context2 = gpuRenderTarget.contexts[i2];
            let view;
            let resolveTarget;
            if (context2) {
              const currentTexture = context2.getCurrentTexture();
              const canvasTextureView = currentTexture.createView();
              view = canvasTextureView;
            } else {
              view = this._renderer.texture.getGpuSource(texture).createView({
                mipLevelCount: 1
              });
            }
            if (gpuRenderTarget.msaaTextures[i2]) {
              resolveTarget = view;
              view = this._renderer.texture.getTextureView(
                gpuRenderTarget.msaaTextures[i2]
              );
            }
            const loadOp = clear & CLEAR.COLOR ? "clear" : "load";
            clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
            return {
              view,
              resolveTarget,
              clearValue,
              storeOp: "store",
              loadOp
            };
          }
        );
        let depthStencilAttachment;
        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture) {
          renderTarget.ensureDepthStencilTexture();
          renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;
        }
        if (renderTarget.depthStencilTexture) {
          const stencilLoadOp = clear & CLEAR.STENCIL ? "clear" : "load";
          const depthLoadOp = clear & CLEAR.DEPTH ? "clear" : "load";
          depthStencilAttachment = {
            view: this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(),
            stencilStoreOp: "store",
            stencilLoadOp,
            depthClearValue: 1,
            depthLoadOp,
            depthStoreOp: "store"
          };
        }
        const descriptor = {
          colorAttachments,
          depthStencilAttachment
        };
        return descriptor;
      }
      clear(renderTarget, clear = true, clearColor, viewport) {
        if (!clear)
          return;
        const { gpu, encoder } = this._renderer;
        const device = gpu.device;
        const standAlone = encoder.commandEncoder === null;
        if (standAlone) {
          const commandEncoder = device.createCommandEncoder();
          const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);
          const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
          passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          passEncoder.end();
          const gpuCommands = commandEncoder.finish();
          device.queue.submit([gpuCommands]);
        } else {
          this.startRenderPass(renderTarget, clear, clearColor, viewport);
        }
      }
      initGpuRenderTarget(renderTarget) {
        renderTarget.isRoot = true;
        const gpuRenderTarget = new GpuRenderTarget();
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (CanvasSource.test(colorTexture.resource)) {
            const context2 = colorTexture.resource.getContext(
              "webgpu"
            );
            const alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
            try {
              context2.configure({
                device: this._renderer.gpu.device,
                // eslint-disable-next-line max-len
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode
              });
            } catch (e3) {
              console.error(e3);
            }
            gpuRenderTarget.contexts[i2] = context2;
          }
          gpuRenderTarget.msaa = colorTexture.source.antialias;
          if (colorTexture.source.antialias) {
            const msaaTexture = new TextureSource({
              width: 0,
              height: 0,
              sampleCount: 4
            });
            gpuRenderTarget.msaaTextures[i2] = msaaTexture;
          }
        });
        if (gpuRenderTarget.msaa) {
          gpuRenderTarget.msaaSamples = 4;
          if (renderTarget.depthStencilTexture) {
            renderTarget.depthStencilTexture.source.sampleCount = 4;
          }
        }
        return gpuRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        gpuRenderTarget.contexts.forEach((context2) => {
          context2.unconfigure();
        });
        gpuRenderTarget.msaaTextures.forEach((texture) => {
          texture.destroy();
        });
        gpuRenderTarget.msaaTextures.length = 0;
        gpuRenderTarget.contexts.length = 0;
      }
      ensureDepthStencilTexture(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa) {
          renderTarget.depthStencilTexture.source.sampleCount = 4;
        }
      }
      resizeGpuRenderTarget(renderTarget) {
        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        gpuRenderTarget.width = renderTarget.width;
        gpuRenderTarget.height = renderTarget.height;
        if (gpuRenderTarget.msaa) {
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const msaaTexture = gpuRenderTarget.msaaTextures[i2];
            msaaTexture?.resize(
              colorTexture.source.width,
              colorTexture.source.height,
              colorTexture.source._resolution
            );
          });
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs
var GpuRenderTargetSystem;
var init_GpuRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.mjs"() {
    init_Extensions();
    init_RenderTargetSystem();
    init_GpuRenderTargetAdaptor();
    GpuRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GpuRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GpuRenderTargetSystem.extension = {
      type: [ExtensionType.WebGPUSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs
var GpuShaderSystem;
var init_GpuShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuShaderSystem.mjs"() {
    init_Extensions();
    GpuShaderSystem = class {
      constructor() {
        this._gpuProgramData = /* @__PURE__ */ Object.create(null);
      }
      contextChange(gpu) {
        this._gpu = gpu;
        this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;
      }
      getProgramData(program) {
        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);
      }
      _createGPUProgramData(program) {
        const device = this._gpu.device;
        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));
        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };
        this._gpuProgramData[program._layoutKey] = {
          bindGroups,
          pipeline: device.createPipelineLayout(pipelineLayoutDesc)
        };
        return this._gpuProgramData[program._layoutKey];
      }
      destroy() {
        this._gpu = null;
        this._gpuProgramData = null;
      }
    };
    GpuShaderSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs
var GpuBlendModesToPixi;
var init_GpuBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuBlendModesToPixi.mjs"() {
    "use strict";
    GpuBlendModesToPixi = {};
    GpuBlendModesToPixi.normal = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["add-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
      }
    };
    GpuBlendModesToPixi["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
      }
    };
    GpuBlendModesToPixi.min = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
      }
    };
    GpuBlendModesToPixi.max = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      },
      color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs
var GpuStateSystem;
var init_GpuStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_GpuBlendModesToPixi();
    GpuStateSystem = class {
      constructor() {
        this.defaultState = new State();
        this.defaultState.blend = true;
      }
      contextChange(gpu) {
        this.gpu = gpu;
      }
      /**
       * Gets the blend mode data for the current state
       * @param state - The state to get the blend mode from
       */
      getColorTargets(state) {
        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;
        return [
          {
            format: "bgra8unorm",
            writeMask: 0,
            blend
          }
        ];
      }
      destroy() {
        this.gpu = null;
      }
    };
    GpuStateSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "state"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs
var gpuUploadBufferImageResource;
var init_gpuUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.mjs"() {
    "use strict";
    gpuUploadBufferImageResource = {
      type: "image",
      upload(source2, gpuTexture, gpu) {
        const resource = source2.resource;
        const total = (source2.pixelWidth | 0) * (source2.pixelHeight | 0);
        const bytesPerPixel = resource.byteLength / total;
        gpu.device.queue.writeTexture(
          { texture: gpuTexture },
          resource,
          {
            offset: 0,
            rowsPerImage: source2.pixelHeight,
            bytesPerRow: source2.pixelHeight * bytesPerPixel
          },
          {
            width: source2.pixelWidth,
            height: source2.pixelHeight,
            depthOrArrayLayers: 1
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs
var blockDataMap, defaultBlockData, gpuUploadCompressedTextureResource;
var init_gpuUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.mjs"() {
    "use strict";
    blockDataMap = {
      "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 }
    };
    defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
    gpuUploadCompressedTextureResource = {
      type: "compressed",
      upload(source2, gpuTexture, gpu) {
        let mipWidth = source2.pixelWidth;
        let mipHeight = source2.pixelHeight;
        const blockData = blockDataMap[source2.format] || defaultBlockData;
        for (let i2 = 0; i2 < source2.resource.length; i2++) {
          const levelBuffer = source2.resource[i2];
          const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;
          gpu.device.queue.writeTexture(
            {
              texture: gpuTexture,
              mipLevel: i2
            },
            levelBuffer,
            {
              offset: 0,
              bytesPerRow
            },
            {
              width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,
              height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,
              depthOrArrayLayers: 1
            }
          );
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs
var gpuUploadImageResource;
var init_gpuUploadImageSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.mjs"() {
    "use strict";
    gpuUploadImageResource = {
      type: "image",
      upload(source2, gpuTexture, gpu) {
        const resource = source2.resource;
        if (!resource)
          return;
        const width = Math.min(gpuTexture.width, source2.resourceWidth || source2.pixelWidth);
        const height = Math.min(gpuTexture.height, source2.resourceHeight || source2.pixelHeight);
        const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
        gpu.device.queue.copyExternalImageToTexture(
          { source: resource },
          { texture: gpuTexture, premultipliedAlpha },
          {
            width,
            height
          }
        );
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs
var gpuUploadVideoResource;
var init_gpuUploadVideoSource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.mjs"() {
    init_gpuUploadImageSource();
    gpuUploadVideoResource = {
      type: "video",
      upload(source2, gpuTexture, gpu) {
        gpuUploadImageResource.upload(source2, gpuTexture, gpu);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs
var GpuMipmapGenerator;
var init_GpuMipmapGenerator = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.mjs"() {
    "use strict";
    GpuMipmapGenerator = class {
      constructor(device) {
        this.device = device;
        this.sampler = device.createSampler({ minFilter: "linear" });
        this.pipelines = {};
      }
      _getMipmapPipeline(format2) {
        let pipeline = this.pipelines[format2];
        if (!pipeline) {
          if (!this.mipmapShaderModule) {
            this.mipmapShaderModule = this.device.createShaderModule({
              code: (
                /* wgsl */
                `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
              )
            });
          }
          pipeline = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain"
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format: format2 }]
            }
          });
          this.pipelines[format2] = pipeline;
        }
        return pipeline;
      }
      /**
       * Generates mipmaps for the given GPUTexture from the data in level 0.
       * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.
       * @returns {module:External.GPUTexture} - The originally passed texture
       */
      generateMipmap(texture) {
        const pipeline = this._getMipmapPipeline(texture.format);
        if (texture.dimension === "3d" || texture.dimension === "1d") {
          throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        }
        let mipTexture = texture;
        const arrayLayerCount = texture.depthOrArrayLayers || 1;
        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!renderToSource) {
          const mipTextureDescriptor = {
            size: {
              width: Math.ceil(texture.width / 2),
              height: Math.ceil(texture.height / 2),
              depthOrArrayLayers: arrayLayerCount
            },
            format: texture.format,
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
            mipLevelCount: texture.mipLevelCount - 1
          };
          mipTexture = this.device.createTexture(mipTextureDescriptor);
        }
        const commandEncoder = this.device.createCommandEncoder({});
        const bindGroupLayout = pipeline.getBindGroupLayout(0);
        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
          let srcView = texture.createView({
            baseMipLevel: 0,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: arrayLayer,
            arrayLayerCount: 1
          });
          let dstMipLevel = renderToSource ? 1 : 0;
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            const dstView = mipTexture.createView({
              baseMipLevel: dstMipLevel++,
              mipLevelCount: 1,
              dimension: "2d",
              baseArrayLayer: arrayLayer,
              arrayLayerCount: 1
            });
            const passEncoder = commandEncoder.beginRenderPass({
              colorAttachments: [{
                view: dstView,
                storeOp: "store",
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0, a: 0 }
              }]
            });
            const bindGroup = this.device.createBindGroup({
              layout: bindGroupLayout,
              entries: [{
                binding: 0,
                resource: this.sampler
              }, {
                binding: 1,
                resource: srcView
              }]
            });
            passEncoder.setPipeline(pipeline);
            passEncoder.setBindGroup(0, bindGroup);
            passEncoder.draw(3, 1, 0, 0);
            passEncoder.end();
            srcView = dstView;
          }
        }
        if (!renderToSource) {
          const mipLevelSize = {
            width: Math.ceil(texture.width / 2),
            height: Math.ceil(texture.height / 2),
            depthOrArrayLayers: arrayLayerCount
          };
          for (let i2 = 1; i2 < texture.mipLevelCount; ++i2) {
            commandEncoder.copyTextureToTexture({
              texture: mipTexture,
              mipLevel: i2 - 1
            }, {
              texture,
              mipLevel: i2
            }, mipLevelSize);
            mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);
            mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);
          }
        }
        this.device.queue.submit([commandEncoder.finish()]);
        if (!renderToSource) {
          mipTexture.destroy();
        }
        return texture;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs
var GpuTextureSystem;
var init_GpuTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/texture/GpuTextureSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_UniformGroup();
    init_CanvasPool();
    init_BindGroup();
    init_gpuUploadBufferImageResource();
    init_gpuUploadCompressedTextureResource();
    init_gpuUploadImageSource();
    init_gpuUploadVideoSource();
    init_GpuMipmapGenerator();
    GpuTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._gpuSources = /* @__PURE__ */ Object.create(null);
        this._gpuSamplers = /* @__PURE__ */ Object.create(null);
        this._bindGroupHash = /* @__PURE__ */ Object.create(null);
        this._textureViewHash = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: gpuUploadImageResource,
          buffer: gpuUploadBufferImageResource,
          video: gpuUploadVideoResource,
          compressed: gpuUploadCompressedTextureResource
        };
        this._renderer = renderer;
      }
      contextChange(gpu) {
        this._gpu = gpu;
      }
      initSource(source2) {
        if (source2.autoGenerateMipmaps) {
          const biggestDimension = Math.max(source2.pixelWidth, source2.pixelHeight);
          source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        if (source2.uploadMethodId !== "compressed") {
          usage |= GPUTextureUsage.RENDER_ATTACHMENT;
          usage |= GPUTextureUsage.COPY_SRC;
        }
        const blockData = blockDataMap[source2.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };
        const width = Math.ceil(source2.pixelWidth / blockData.blockWidth) * blockData.blockWidth;
        const height = Math.ceil(source2.pixelHeight / blockData.blockHeight) * blockData.blockHeight;
        const textureDescriptor = {
          label: source2.label,
          size: { width, height },
          format: source2.format,
          sampleCount: source2.sampleCount,
          mipLevelCount: source2.mipLevelCount,
          dimension: source2.dimension,
          usage
        };
        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);
        this._gpuSources[source2.uid] = gpuTexture;
        if (!this.managedTextures.includes(source2)) {
          source2.on("update", this.onSourceUpdate, this);
          source2.on("resize", this.onSourceResize, this);
          source2.on("destroy", this.onSourceDestroy, this);
          source2.on("unload", this.onSourceUnload, this);
          source2.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source2);
        }
        this.onSourceUpdate(source2);
        return gpuTexture;
      }
      onSourceUpdate(source2) {
        const gpuTexture = this.getGpuSource(source2);
        if (!gpuTexture)
          return;
        if (this._uploads[source2.uploadMethodId]) {
          this._uploads[source2.uploadMethodId].upload(source2, gpuTexture, this._gpu);
        }
        if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
          this.onUpdateMipmaps(source2);
        }
      }
      onSourceUnload(source2) {
        const gpuTexture = this._gpuSources[source2.uid];
        if (gpuTexture) {
          this._gpuSources[source2.uid] = null;
          gpuTexture.destroy();
        }
      }
      onUpdateMipmaps(source2) {
        if (!this._mipmapGenerator) {
          this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);
        }
        const gpuTexture = this.getGpuSource(source2);
        this._mipmapGenerator.generateMipmap(gpuTexture);
      }
      onSourceDestroy(source2) {
        source2.off("update", this.onSourceUpdate, this);
        source2.off("unload", this.onSourceUnload, this);
        source2.off("destroy", this.onSourceDestroy, this);
        source2.off("resize", this.onSourceResize, this);
        source2.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
        this.onSourceUnload(source2);
      }
      onSourceResize(source2) {
        const gpuTexture = this._gpuSources[source2.uid];
        if (!gpuTexture) {
          this.initSource(source2);
        } else if (gpuTexture.width !== source2.pixelWidth || gpuTexture.height !== source2.pixelHeight) {
          this._textureViewHash[source2.uid] = null;
          this._bindGroupHash[source2.uid] = null;
          this.onSourceUnload(source2);
          this.initSource(source2);
        }
      }
      _initSampler(sampler) {
        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
        return this._gpuSamplers[sampler._resourceId];
      }
      getGpuSampler(sampler) {
        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGpuSource(source2) {
        return this._gpuSources[source2.uid] || this.initSource(source2);
      }
      /**
       * this returns s bind group for a specific texture, the bind group contains
       * - the texture source
       * - the texture style
       * - the texture matrix
       * This is cached so the bind group should only be created once per texture
       * @param texture - the texture you want the bindgroup for
       * @returns the bind group for the texture
       */
      getTextureBindGroup(texture) {
        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
      }
      _createTextureBindGroup(texture) {
        const source2 = texture.source;
        this._bindGroupHash[texture.uid] = new BindGroup({
          0: source2,
          1: source2.style,
          2: new UniformGroup({
            uTextureMatrix: { type: "mat3x3<f32>", value: texture.textureMatrix.mapCoord }
          })
        });
        return this._bindGroupHash[texture.uid];
      }
      getTextureView(texture) {
        const source2 = texture.source;
        return this._textureViewHash[source2.uid] ?? this._createTextureView(source2);
      }
      _createTextureView(texture) {
        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
        return this._textureViewHash[texture.uid];
      }
      generateCanvas(texture) {
        const renderer = this._renderer;
        const commandEncoder = renderer.gpu.device.createCommandEncoder();
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = texture.source.pixelWidth;
        canvas.height = texture.source.pixelHeight;
        const context2 = canvas.getContext("webgpu");
        context2.configure({
          device: renderer.gpu.device,
          // eslint-disable-next-line max-len
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),
          alphaMode: "premultiplied"
        });
        commandEncoder.copyTextureToTexture({
          texture: renderer.texture.getGpuSource(texture.source),
          origin: {
            x: 0,
            y: 0
          }
        }, {
          texture: context2.getCurrentTexture()
        }, {
          width: canvas.width,
          height: canvas.height
        });
        renderer.gpu.device.queue.submit([commandEncoder.finish()]);
        return canvas;
      }
      getPixels(texture) {
        const webGPUCanvas = this.generateCanvas(texture);
        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
        const context2 = canvasAndContext.context;
        context2.drawImage(webGPUCanvas, 0, 0);
        const { width, height } = webGPUCanvas;
        const imageData = context2.getImageData(0, 0, width, height);
        const pixels = new Uint8ClampedArray(imageData.data.buffer);
        CanvasPool.returnCanvasAndContext(canvasAndContext);
        return { pixels, width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
        this.managedTextures = null;
        for (const k3 of Object.keys(this._bindGroupHash)) {
          const key = Number(k3);
          const bindGroup = this._bindGroupHash[key];
          bindGroup?.destroy();
          this._bindGroupHash[key] = null;
        }
        this._gpu = null;
        this._mipmapGenerator = null;
        this._gpuSources = null;
        this._bindGroupHash = null;
        this._textureViewHash = null;
        this._gpuSamplers = null;
      }
    };
    GpuTextureSystem.extension = {
      type: [
        ExtensionType.WebGPUSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs
var WebGPURenderer_exports = {};
__export(WebGPURenderer_exports, {
  WebGPURenderer: () => WebGPURenderer
});
var DefaultWebGPUSystems, DefaultWebGPUPipes, DefaultWebGPUAdapters, systems, renderPipes, renderPipeAdaptors, WebGPURenderer;
var init_WebGPURenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gpu/WebGPURenderer.mjs"() {
    init_Extensions();
    init_GpuGraphicsAdaptor();
    init_GpuMeshAdapter();
    init_GpuBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_BindGroupSystem();
    init_GpuBufferSystem();
    init_GpuColorMaskSystem();
    init_GpuDeviceSystem();
    init_GpuEncoderSystem();
    init_GpuStencilSystem();
    init_GpuUboSystem();
    init_GpuUniformBatchPipe();
    init_PipelineSystem();
    init_GpuRenderTargetSystem();
    init_GpuShaderSystem();
    init_GpuStateSystem();
    init_GpuTextureSystem();
    DefaultWebGPUSystems = [
      ...SharedSystems,
      GpuUboSystem,
      GpuEncoderSystem,
      GpuDeviceSystem,
      GpuBufferSystem,
      GpuTextureSystem,
      GpuRenderTargetSystem,
      GpuShaderSystem,
      GpuStateSystem,
      PipelineSystem,
      GpuColorMaskSystem,
      GpuStencilSystem,
      BindGroupSystem
    ];
    DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];
    DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];
    systems = [];
    renderPipes = [];
    renderPipeAdaptors = [];
    extensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);
    extensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);
    extensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);
    extensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);
    WebGPURenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgpu",
          type: RendererType.WEBGPU,
          systems,
          renderPipes,
          renderPipeAdaptors
        };
        super(systemConfig);
      }
    };
  }
});

// node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs
var GlGraphicsAdaptor;
var init_GlGraphicsAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/graphics/gl/GlGraphicsAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_maxRecommendedTextures();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_localUniformBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_UniformGroup();
    GlGraphicsAdaptor = class {
      init() {
        const uniforms = new UniformGroup({
          uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
          uTransformMatrix: { value: new Matrix(), type: "mat3x3<f32>" },
          uRound: { value: 0, type: "f32" }
        });
        const maxTextures2 = getMaxTexturesPerBatch();
        const glProgram3 = compileHighShaderGlProgram({
          name: "graphics",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            localUniformBitGl,
            roundPixelsBitGl
          ]
        });
        this.shader = new Shader({
          glProgram: glProgram3,
          resources: {
            localUniforms: uniforms,
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
      }
      execute(graphicsPipe, renderable) {
        const context2 = renderable.context;
        const shader = context2.customShader || this.shader;
        const renderer = graphicsPipe.renderer;
        const contextSystem = renderer.graphicsContext;
        const {
          geometry,
          instructions
        } = contextSystem.getContextRenderData(context2);
        shader.groups[0] = renderer.globalUniforms.bindGroup;
        renderer.state.set(graphicsPipe.state);
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader.glProgram);
        const batches = instructions.instructions;
        for (let i2 = 0; i2 < instructions.instructionSize; i2++) {
          const batch = batches[i2];
          if (batch.size) {
            for (let j3 = 0; j3 < batch.textures.count; j3++) {
              renderer.texture.bind(batch.textures.textures[j3], j3);
            }
            renderer.geometry.draw("triangle-list", batch.size, batch.start);
          }
        }
      }
      destroy() {
        this.shader.destroy(true);
        this.shader = null;
      }
    };
    GlGraphicsAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "graphics"
    };
  }
});

// node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs
var GlMeshAdaptor;
var init_GlMeshAdaptor = __esm({
  "node_modules/pixi.js/lib/scene/mesh/gl/GlMeshAdaptor.mjs"() {
    init_Extensions();
    init_Matrix();
    init_compileHighShaderToProgram();
    init_localUniformBit();
    init_roundPixelsBit();
    init_textureBit();
    init_Shader();
    init_Texture();
    init_warn();
    GlMeshAdaptor = class {
      init() {
        const glProgram3 = compileHighShaderGlProgram({
          name: "mesh",
          bits: [
            localUniformBitGl,
            textureBitGl,
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram: glProgram3,
          resources: {
            uTexture: Texture.EMPTY.source,
            textureUniforms: {
              uTextureMatrix: { type: "mat3x3<f32>", value: new Matrix() }
            }
          }
        });
      }
      execute(meshPipe, mesh) {
        const renderer = meshPipe.renderer;
        let shader = mesh._shader;
        if (!shader) {
          shader = this._shader;
          const texture = mesh.texture;
          const source2 = texture.source;
          shader.resources.uTexture = source2;
          shader.resources.uSampler = source2.style;
          shader.resources.textureUniforms.uniforms.uTextureMatrix = texture.textureMatrix.mapCoord;
        } else if (!shader.glProgram) {
          warn("Mesh shader has no glProgram", mesh.shader);
          return;
        }
        shader.groups[100] = renderer.globalUniforms.bindGroup;
        shader.groups[101] = meshPipe.localUniformsBindGroup;
        renderer.encoder.draw({
          geometry: mesh._geometry,
          shader,
          state: mesh.state
        });
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlMeshAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "mesh"
    };
  }
});

// node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs
var GlBatchAdaptor;
var init_GlBatchAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/batcher/gl/GlBatchAdaptor.mjs"() {
    init_Extensions();
    init_compileHighShaderToProgram();
    init_colorBit();
    init_generateTextureBatchBit();
    init_roundPixelsBit();
    init_getBatchSamplersUniformGroup();
    init_Shader();
    init_State();
    init_maxRecommendedTextures();
    GlBatchAdaptor = class {
      constructor() {
        this._didUpload = false;
        this._tempState = State.for2d();
      }
      init(batcherPipe) {
        const maxTextures2 = getMaxTexturesPerBatch();
        const glProgram3 = compileHighShaderGlProgram({
          name: "batch",
          bits: [
            colorBitGl,
            generateTextureBatchBitGl(maxTextures2),
            roundPixelsBitGl
          ]
        });
        this._shader = new Shader({
          glProgram: glProgram3,
          resources: {
            batchSamplers: getBatchSamplersUniformGroup(maxTextures2)
          }
        });
        batcherPipe.renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._didUpload = false;
      }
      start(batchPipe, geometry) {
        const renderer = batchPipe.renderer;
        renderer.shader.bind(this._shader, this._didUpload);
        renderer.shader.updateUniformGroup(renderer.globalUniforms.uniformGroup);
        renderer.geometry.bind(geometry, this._shader.glProgram);
      }
      execute(batchPipe, batch) {
        const renderer = batchPipe.renderer;
        this._didUpload = true;
        this._tempState.blendMode = batch.blendMode;
        renderer.state.set(this._tempState);
        const textures = batch.textures.textures;
        for (let i2 = 0; i2 < batch.textures.count; i2++) {
          renderer.texture.bind(textures[i2], i2);
        }
        renderer.geometry.draw("triangle-list", batch.size, batch.start);
      }
      destroy() {
        this._shader.destroy(true);
        this._shader = null;
      }
    };
    GlBatchAdaptor.extension = {
      type: [
        ExtensionType.WebGLPipesAdaptor
      ],
      name: "batch"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs
var BUFFER_TYPE;
var init_const8 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/const.mjs"() {
    "use strict";
    BUFFER_TYPE = /* @__PURE__ */ ((BUFFER_TYPE2) => {
      BUFFER_TYPE2[BUFFER_TYPE2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BUFFER_TYPE2[BUFFER_TYPE2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
      return BUFFER_TYPE2;
    })(BUFFER_TYPE || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs
var GlBuffer;
var init_GlBuffer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBuffer.mjs"() {
    "use strict";
    GlBuffer = class {
      constructor(buffer, type2) {
        this.buffer = buffer || null;
        this.updateID = -1;
        this.byteLength = -1;
        this.type = type2;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs
var GlBufferSystem;
var init_GlBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/buffer/GlBufferSystem.mjs"() {
    init_Extensions();
    init_const4();
    init_const8();
    init_GlBuffer();
    GlBufferSystem = class {
      /**
       * @param {Renderer} renderer - The renderer this System works for.
       */
      constructor(renderer) {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._boundBufferBases = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      /**
       * @ignore
       */
      destroy() {
        this._renderer = null;
        this._gl = null;
        this._gpuBuffers = null;
        this._boundBufferBases = null;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
        this._gl = this._renderer.gl;
      }
      getGlBuffer(buffer) {
        return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
      }
      /**
       * This binds specified buffer. On first run, it will create the webGL buffers for the context too
       * @param buffer - the buffer to bind to the renderer
       */
      bind(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      }
      /**
       * Binds an uniform buffer to at the given index.
       *
       * A cache is used so a buffer will not be bound again if already bound.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind it to.
       */
      bindBufferBase(buffer, index2) {
        const { _gl: gl } = this;
        if (this._boundBufferBases[index2] !== buffer) {
          const glBuffer = this.getGlBuffer(buffer);
          this._boundBufferBases[index2] = buffer;
          gl.bindBufferBase(gl.UNIFORM_BUFFER, index2, glBuffer.buffer);
        }
      }
      /**
       * Binds a buffer whilst also binding its range.
       * This will make the buffer start from the offset supplied rather than 0 when it is read.
       * @param buffer - the buffer to bind
       * @param index - the base index to bind at, defaults to 0
       * @param offset - the offset to bind at (this is blocks of 256). 0 = 0, 1 = 256, 2 = 512 etc
       */
      bindBufferRange(buffer, index2, offset) {
        const { _gl: gl } = this;
        offset = offset || 0;
        const glBuffer = this.getGlBuffer(buffer);
        gl.bindBufferRange(gl.UNIFORM_BUFFER, index2 || 0, glBuffer.buffer, offset * 256, 256);
      }
      /**
       * Will ensure the data in the buffer is uploaded to the GPU.
       * @param {Buffer} buffer - the buffer to update
       */
      updateBuffer(buffer) {
        const { _gl: gl } = this;
        const glBuffer = this.getGlBuffer(buffer);
        if (buffer._updateID === glBuffer.updateID) {
          return glBuffer;
        }
        glBuffer.updateID = buffer._updateID;
        gl.bindBuffer(glBuffer.type, glBuffer.buffer);
        const data = buffer.data;
        if (glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT);
        } else {
          const drawType = buffer.descriptor.usage & BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = data.byteLength;
          gl.bufferData(glBuffer.type, data, drawType);
        }
        return glBuffer;
      }
      /** dispose all WebGL resources of all managed buffers */
      destroyAll() {
        const gl = this._gl;
        for (const id2 in this._gpuBuffers) {
          gl.deleteBuffer(this._gpuBuffers[id2].buffer);
        }
        this._gpuBuffers = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Disposes buffer
       * @param {Buffer} buffer - buffer with data
       * @param {boolean} [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onBufferDestroy(buffer, contextLost) {
        const glBuffer = this._gpuBuffers[buffer.uid];
        const gl = this._gl;
        if (!contextLost) {
          gl.deleteBuffer(glBuffer.buffer);
        }
        this._gpuBuffers[buffer.uid] = null;
      }
      /**
       * creates and attaches a GLBuffer object tied to the current context.
       * @param buffer
       * @protected
       */
      createGLBuffer(buffer) {
        const { _gl: gl } = this;
        let type2 = BUFFER_TYPE.ARRAY_BUFFER;
        if (buffer.descriptor.usage & BufferUsage.INDEX) {
          type2 = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        } else if (buffer.descriptor.usage & BufferUsage.UNIFORM) {
          type2 = BUFFER_TYPE.UNIFORM_BUFFER;
        }
        const glBuffer = new GlBuffer(gl.createBuffer(), type2);
        this._gpuBuffers[buffer.uid] = glBuffer;
        buffer.on("destroy", this.onBufferDestroy, this);
        return glBuffer;
      }
    };
    GlBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "buffer"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs
var _GlContextSystem, GlContextSystem;
var init_GlContextSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/context/GlContextSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_warn();
    _GlContextSystem = class _GlContextSystem2 {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this.supports = {
          /** Support for 32-bit indices buffer. */
          uint32Indices: true,
          /** Support for UniformBufferObjects */
          uniformBufferObject: true,
          /** Support for VertexArrayObjects */
          vertexArrayObject: true,
          /** Support for SRGB texture format */
          srgbTextures: true,
          /** Support for wrapping modes if a texture is non-power of two */
          nonPowOf2wrapping: true,
          /** Support for MSAA (antialiasing of dynamic textures) */
          msaa: true,
          /** Support for mipmaps if a texture is non-power of two */
          nonPowOf2mipmaps: true
        };
        this._renderer = renderer;
        this.extensions = /* @__PURE__ */ Object.create(null);
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
      }
      /**
       * `true` if the context is lost
       * @readonly
       */
      get isLost() {
        return !this.gl || this.gl.isContextLost();
      }
      /**
       * Handles the context change event.
       * @param {WebGLRenderingContext} gl - New WebGL context.
       */
      contextChange(gl) {
        this.gl = gl;
        this._renderer.gl = gl;
      }
      init(options) {
        options = { ..._GlContextSystem2.defaultOptions, ...options };
        if (options.context) {
          this.initFromContext(options.context);
        } else {
          const alpha = this._renderer.background.alpha < 1;
          const premultipliedAlpha = options.premultipliedAlpha ?? true;
          const antialias = options.antialias && !this._renderer.backBuffer.useBackBuffer;
          this.createContext(options.preferWebGLVersion, {
            alpha,
            premultipliedAlpha,
            antialias,
            stencil: true,
            preserveDrawingBuffer: options.preserveDrawingBuffer,
            powerPreference: options.powerPreference ?? "default"
          });
        }
      }
      /**
       * Initializes the context.
       * @protected
       * @param {WebGLRenderingContext} gl - WebGL context
       */
      initFromContext(gl) {
        this.gl = gl;
        this.webGLVersion = gl instanceof DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
        this.getExtensions();
        this.validateContext(gl);
        this._renderer.runners.contextChange.emit(gl);
        const element = this._renderer.view.canvas;
        element.addEventListener("webglcontextlost", this.handleContextLost, false);
        element.addEventListener("webglcontextrestored", this.handleContextRestored, false);
      }
      /**
       * Initialize from context options
       * @protected
       * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
       * @param preferWebGLVersion
       * @param {object} options - context attributes
       */
      createContext(preferWebGLVersion, options) {
        let gl;
        const canvas = this._renderer.view.canvas;
        if (preferWebGLVersion === 2) {
          gl = canvas.getContext("webgl2", options);
        }
        if (!gl) {
          gl = canvas.getContext("webgl", options);
          if (!gl) {
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
          }
        }
        this.gl = gl;
        this.initFromContext(this.gl);
      }
      /** Auto-populate the {@link GlContextSystem.extensions extensions}. */
      getExtensions() {
        const { gl } = this;
        const common = {
          anisotropicFiltering: gl.getExtension("EXT_texture_filter_anisotropic"),
          floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
          s3tc: gl.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          // eslint-disable-line camelcase
          etc: gl.getExtension("WEBGL_compressed_texture_etc"),
          etc1: gl.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc: gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: gl.getExtension("WEBGL_compressed_texture_atc"),
          astc: gl.getExtension("WEBGL_compressed_texture_astc"),
          bptc: gl.getExtension("EXT_texture_compression_bptc"),
          rgtc: gl.getExtension("EXT_texture_compression_rgtc"),
          loseContext: gl.getExtension("WEBGL_lose_context")
        };
        if (this.webGLVersion === 1) {
          this.extensions = {
            ...common,
            drawBuffers: gl.getExtension("WEBGL_draw_buffers"),
            depthTexture: gl.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: gl.getExtension("OES_element_index_uint"),
            // Floats and half-floats
            floatTexture: gl.getExtension("OES_texture_float"),
            floatTextureLinear: gl.getExtension("OES_texture_float_linear"),
            textureHalfFloat: gl.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: gl.getExtension("OES_texture_half_float_linear"),
            vertexAttribDivisorANGLE: gl.getExtension("ANGLE_instanced_arrays"),
            srgb: gl.getExtension("EXT_sRGB")
          };
        } else {
          this.extensions = {
            ...common,
            colorBufferFloat: gl.getExtension("EXT_color_buffer_float")
          };
          const provokeExt = gl.getExtension("WEBGL_provoking_vertex");
          if (provokeExt) {
            provokeExt.provokingVertexWEBGL(provokeExt.FIRST_VERTEX_CONVENTION_WEBGL);
          }
        }
      }
      /**
       * Handles a lost webgl context
       * @param {WebGLContextEvent} event - The context lost event.
       */
      handleContextLost(event) {
        event.preventDefault();
        if (this._contextLossForced) {
          this._contextLossForced = false;
          setTimeout(() => {
            if (this.gl.isContextLost()) {
              this.extensions.loseContext?.restoreContext();
            }
          }, 0);
        }
      }
      /** Handles a restored webgl context. */
      handleContextRestored() {
        this._renderer.runners.contextChange.emit(this.gl);
      }
      destroy() {
        const element = this._renderer.view.canvas;
        this._renderer = null;
        element.removeEventListener("webglcontextlost", this.handleContextLost);
        element.removeEventListener("webglcontextrestored", this.handleContextRestored);
        this.gl.useProgram(null);
        this.extensions.loseContext?.loseContext();
      }
      /**
       * this function can be called to force a webGL context loss
       * this will release all resources on the GPU.
       * Useful if you need to put Pixi to sleep, and save some GPU memory
       *
       * As soon as render is called - all resources will be created again.
       */
      forceContextLoss() {
        this.extensions.loseContext?.loseContext();
        this._contextLossForced = true;
      }
      /**
       * Validate context.
       * @param {WebGLRenderingContext} gl - Render context.
       */
      validateContext(gl) {
        const attributes = gl.getContextAttributes();
        if (attributes && !attributes.stencil) {
          warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        }
        const supports = this.supports;
        const isWebGl2 = this.webGLVersion === 2;
        const extensions2 = this.extensions;
        supports.uint32Indices = isWebGl2 || !!extensions2.uint32ElementIndex;
        supports.uniformBufferObject = isWebGl2;
        supports.vertexArrayObject = isWebGl2 || !!extensions2.vertexArrayObject;
        supports.srgbTextures = isWebGl2 || !!extensions2.srgb;
        supports.nonPowOf2wrapping = isWebGl2;
        supports.nonPowOf2mipmaps = isWebGl2;
        supports.msaa = isWebGl2;
        if (!supports.uint32Indices) {
          warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
        }
      }
    };
    _GlContextSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "context"
    };
    _GlContextSystem.defaultOptions = {
      /**
       * {@link WebGLOptions.context}
       * @default null
       */
      context: null,
      /**
       * {@link WebGLOptions.premultipliedAlpha}
       * @default true
       */
      premultipliedAlpha: true,
      /**
       * {@link WebGLOptions.preserveDrawingBuffer}
       * @default false
       */
      preserveDrawingBuffer: false,
      /**
       * {@link WebGLOptions.powerPreference}
       * @default default
       */
      powerPreference: void 0,
      /**
       * {@link WebGLOptions.webGLVersion}
       * @default 2
       */
      preferWebGLVersion: 2
    };
    GlContextSystem = _GlContextSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs
var GL_FORMATS, GL_TARGETS, GL_TYPES;
var init_const9 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/const.mjs"() {
    "use strict";
    GL_FORMATS = /* @__PURE__ */ ((GL_FORMATS2) => {
      GL_FORMATS2[GL_FORMATS2["RGBA"] = 6408] = "RGBA";
      GL_FORMATS2[GL_FORMATS2["RGB"] = 6407] = "RGB";
      GL_FORMATS2[GL_FORMATS2["RG"] = 33319] = "RG";
      GL_FORMATS2[GL_FORMATS2["RED"] = 6403] = "RED";
      GL_FORMATS2[GL_FORMATS2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RG_INTEGER"] = 33320] = "RG_INTEGER";
      GL_FORMATS2[GL_FORMATS2["RED_INTEGER"] = 36244] = "RED_INTEGER";
      GL_FORMATS2[GL_FORMATS2["ALPHA"] = 6406] = "ALPHA";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE"] = 6409] = "LUMINANCE";
      GL_FORMATS2[GL_FORMATS2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      GL_FORMATS2[GL_FORMATS2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      GL_FORMATS2[GL_FORMATS2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      return GL_FORMATS2;
    })(GL_FORMATS || {});
    GL_TARGETS = /* @__PURE__ */ ((GL_TARGETS2) => {
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      GL_TARGETS2[GL_TARGETS2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      return GL_TARGETS2;
    })(GL_TARGETS || {});
    GL_TYPES = /* @__PURE__ */ ((GL_TYPES2) => {
      GL_TYPES2[GL_TYPES2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      GL_TYPES2[GL_TYPES2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
      GL_TYPES2[GL_TYPES2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
      GL_TYPES2[GL_TYPES2["BYTE"] = 5120] = "BYTE";
      GL_TYPES2[GL_TYPES2["SHORT"] = 5122] = "SHORT";
      GL_TYPES2[GL_TYPES2["INT"] = 5124] = "INT";
      GL_TYPES2[GL_TYPES2["FLOAT"] = 5126] = "FLOAT";
      GL_TYPES2[GL_TYPES2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
      GL_TYPES2[GL_TYPES2["HALF_FLOAT"] = 36193] = "HALF_FLOAT";
      return GL_TYPES2;
    })(GL_TYPES || {});
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs
function getGlTypeFromFormat(format2) {
  return infoMap[format2] ?? infoMap.float32;
}
var infoMap;
var init_getGlTypeFromFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/utils/getGlTypeFromFormat.mjs"() {
    init_const9();
    infoMap = {
      uint8x2: GL_TYPES.UNSIGNED_BYTE,
      uint8x4: GL_TYPES.UNSIGNED_BYTE,
      sint8x2: GL_TYPES.BYTE,
      sint8x4: GL_TYPES.BYTE,
      unorm8x2: GL_TYPES.UNSIGNED_BYTE,
      unorm8x4: GL_TYPES.UNSIGNED_BYTE,
      snorm8x2: GL_TYPES.BYTE,
      snorm8x4: GL_TYPES.BYTE,
      uint16x2: GL_TYPES.UNSIGNED_SHORT,
      uint16x4: GL_TYPES.UNSIGNED_SHORT,
      sint16x2: GL_TYPES.SHORT,
      sint16x4: GL_TYPES.SHORT,
      unorm16x2: GL_TYPES.UNSIGNED_SHORT,
      unorm16x4: GL_TYPES.UNSIGNED_SHORT,
      snorm16x2: GL_TYPES.SHORT,
      snorm16x4: GL_TYPES.SHORT,
      float16x2: GL_TYPES.HALF_FLOAT,
      float16x4: GL_TYPES.HALF_FLOAT,
      float32: GL_TYPES.FLOAT,
      float32x2: GL_TYPES.FLOAT,
      float32x3: GL_TYPES.FLOAT,
      float32x4: GL_TYPES.FLOAT,
      uint32: GL_TYPES.UNSIGNED_INT,
      uint32x2: GL_TYPES.UNSIGNED_INT,
      uint32x3: GL_TYPES.UNSIGNED_INT,
      uint32x4: GL_TYPES.UNSIGNED_INT,
      sint32: GL_TYPES.INT,
      sint32x2: GL_TYPES.INT,
      sint32x3: GL_TYPES.INT,
      sint32x4: GL_TYPES.INT
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs
var topologyToGlMap, GlGeometrySystem;
var init_GlGeometrySystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/geometry/GlGeometrySystem.mjs"() {
    init_Extensions();
    init_getAttributeInfoFromFormat();
    init_ensureAttributes();
    init_getGlTypeFromFormat();
    topologyToGlMap = {
      "point-list": 0,
      "line-list": 1,
      "line-strip": 3,
      "triangle-list": 4,
      "triangle-strip": 5
    };
    GlGeometrySystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
        this._activeGeometry = null;
        this._activeVao = null;
        this.hasVao = true;
        this.hasInstance = true;
      }
      /** Sets up the renderer context and necessary buffers. */
      contextChange() {
        const gl = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) {
          throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        }
        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;
        if (nativeVaoExtension) {
          gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES();
          gl.bindVertexArray = (vao) => nativeVaoExtension.bindVertexArrayOES(vao);
          gl.deleteVertexArray = (vao) => nativeVaoExtension.deleteVertexArrayOES(vao);
        }
        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        if (nativeInstancedExtension) {
          gl.drawArraysInstanced = (a3, b2, c3, d3) => {
            nativeInstancedExtension.drawArraysInstancedANGLE(a3, b2, c3, d3);
          };
          gl.drawElementsInstanced = (a3, b2, c3, d3, e3) => {
            nativeInstancedExtension.drawElementsInstancedANGLE(a3, b2, c3, d3, e3);
          };
          gl.vertexAttribDivisor = (a3, b2) => nativeInstancedExtension.vertexAttribDivisorANGLE(a3, b2);
        }
        this._activeGeometry = null;
        this._activeVao = null;
        this._geometryVaoHash = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Binds geometry so that is can be drawn. Creating a Vao if required
       * @param geometry - Instance of geometry to bind.
       * @param program - Instance of program to use vao for.
       */
      bind(geometry, program) {
        const gl = this.gl;
        this._activeGeometry = geometry;
        const vao = this.getVao(geometry, program);
        if (this._activeVao !== vao) {
          this._activeVao = vao;
          gl.bindVertexArray(vao);
        }
        this.updateBuffers();
      }
      /** Reset and unbind any active VAO and geometry. */
      reset() {
        this.unbind();
      }
      /** Update buffers of the currently bound geometry. */
      updateBuffers() {
        const geometry = this._activeGeometry;
        const bufferSystem = this._renderer.buffer;
        for (let i2 = 0; i2 < geometry.buffers.length; i2++) {
          const buffer = geometry.buffers[i2];
          bufferSystem.updateBuffer(buffer);
        }
      }
      /**
       * Check compatibility between a geometry and a program
       * @param geometry - Geometry instance.
       * @param program - Program instance.
       */
      checkCompatibility(geometry, program) {
        const geometryAttributes = geometry.attributes;
        const shaderAttributes = program._attributeData;
        for (const j3 in shaderAttributes) {
          if (!geometryAttributes[j3]) {
            throw new Error(`shader and geometry incompatible, geometry missing the "${j3}" attribute`);
          }
        }
      }
      /**
       * Takes a geometry and program and generates a unique signature for them.
       * @param geometry - To get signature from.
       * @param program - To test geometry against.
       * @returns - Unique signature of the geometry and program
       */
      getSignature(geometry, program) {
        const attribs = geometry.attributes;
        const shaderAttributes = program._attributeData;
        const strings = ["g", geometry.uid];
        for (const i2 in attribs) {
          if (shaderAttributes[i2]) {
            strings.push(i2, shaderAttributes[i2].location);
          }
        }
        return strings.join("-");
      }
      getVao(geometry, program) {
        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);
      }
      /**
       * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
       * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the
       * attribute locations.
       * @param geometry - Instance of geometry to to generate Vao for.
       * @param program
       * @param _incRefCount - Increment refCount of all geometry buffers.
       */
      initGeometryVao(geometry, program, _incRefCount = true) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        this._renderer.shader._getProgramData(program);
        this.checkCompatibility(geometry, program);
        const signature = this.getSignature(geometry, program);
        if (!this._geometryVaoHash[geometry.uid]) {
          this._geometryVaoHash[geometry.uid] = /* @__PURE__ */ Object.create(null);
          geometry.on("destroy", this.onGeometryDestroy, this);
        }
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        let vao = vaoObjectHash[signature];
        if (vao) {
          vaoObjectHash[program._key] = vao;
          return vao;
        }
        ensureAttributes(geometry, program._attributeData);
        const buffers = geometry.buffers;
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        for (let i2 = 0; i2 < buffers.length; i2++) {
          const buffer = buffers[i2];
          bufferSystem.bind(buffer);
        }
        this.activateVao(geometry, program);
        vaoObjectHash[program._key] = vao;
        vaoObjectHash[signature] = vao;
        gl.bindVertexArray(null);
        return vao;
      }
      /**
       * Disposes geometry.
       * @param geometry - Geometry with buffers. Only VAO will be disposed
       * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray
       */
      onGeometryDestroy(geometry, contextLost) {
        const vaoObjectHash = this._geometryVaoHash[geometry.uid];
        const gl = this.gl;
        if (vaoObjectHash) {
          if (contextLost) {
            for (const i2 in vaoObjectHash) {
              if (this._activeVao !== vaoObjectHash[i2]) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[i2]);
            }
          }
          this._geometryVaoHash[geometry.uid] = null;
        }
      }
      /**
       * Dispose all WebGL resources of all managed geometries.
       * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls
       */
      destroyAll(contextLost = false) {
        const gl = this.gl;
        for (const i2 in this._geometryVaoHash) {
          if (contextLost) {
            for (const j3 in this._geometryVaoHash[i2]) {
              const vaoObjectHash = this._geometryVaoHash[i2];
              if (this._activeVao !== vaoObjectHash) {
                this.unbind();
              }
              gl.deleteVertexArray(vaoObjectHash[j3]);
            }
          }
          this._geometryVaoHash[i2] = null;
        }
      }
      /**
       * Activate vertex array object.
       * @param geometry - Geometry instance.
       * @param program - Shader program instance.
       */
      activateVao(geometry, program) {
        const gl = this._renderer.gl;
        const bufferSystem = this._renderer.buffer;
        const attributes = geometry.attributes;
        if (geometry.indexBuffer) {
          bufferSystem.bind(geometry.indexBuffer);
        }
        let lastBuffer = null;
        for (const j3 in attributes) {
          const attribute = attributes[j3];
          const buffer = attribute.buffer;
          const glBuffer = bufferSystem.getGlBuffer(buffer);
          const programAttrib = program._attributeData[j3];
          if (programAttrib) {
            if (lastBuffer !== glBuffer) {
              bufferSystem.bind(buffer);
              lastBuffer = glBuffer;
            }
            const location = programAttrib.location;
            gl.enableVertexAttribArray(location);
            const attributeInfo = getAttributeInfoFromFormat(attribute.format);
            const type2 = getGlTypeFromFormat(attribute.format);
            if (programAttrib.format?.substring(1, 4) === "int") {
              gl.vertexAttribIPointer(
                location,
                attributeInfo.size,
                type2,
                attribute.stride,
                attribute.offset
              );
            } else {
              gl.vertexAttribPointer(
                location,
                attributeInfo.size,
                type2,
                attributeInfo.normalised,
                attribute.stride,
                attribute.offset
              );
            }
            if (attribute.instance) {
              if (this.hasInstance) {
                const divisor = attribute.divisor ?? 1;
                gl.vertexAttribDivisor(location, divisor);
              } else {
                throw new Error("geometry error, GPU Instancing is not supported on this device");
              }
            }
          }
        }
      }
      /**
       * Draws the currently bound geometry.
       * @param topology - The type primitive to render.
       * @param size - The number of elements to be rendered. If not specified, all vertices after the
       *  starting vertex will be drawn.
       * @param start - The starting vertex in the geometry to start drawing from. If not specified,
       *  drawing will start from the first vertex.
       * @param instanceCount - The number of instances of the set of elements to execute. If not specified,
       *  all instances will be drawn.
       */
      draw(topology, size, start2, instanceCount) {
        const { gl } = this._renderer;
        const geometry = this._activeGeometry;
        const glTopology = topologyToGlMap[geometry.topology || topology];
        instanceCount || (instanceCount = geometry.instanceCount);
        if (geometry.indexBuffer) {
          const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;
          const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
          if (instanceCount > 1) {
            gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize, instanceCount);
          } else {
            gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start2 || 0) * byteSize);
          }
        } else if (instanceCount > 1) {
          gl.drawArraysInstanced(glTopology, start2 || 0, size || geometry.getSize(), instanceCount);
        } else {
          gl.drawArrays(glTopology, start2 || 0, size || geometry.getSize());
        }
        return this;
      }
      /** Unbind/reset everything. */
      unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
      }
      destroy() {
        this._renderer = null;
        this.gl = null;
        this._activeVao = null;
        this._activeGeometry = null;
      }
    };
    GlGeometrySystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "geometry"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs
var bigTriangleGeometry, _GlBackBufferSystem, GlBackBufferSystem;
var init_GlBackBufferSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlBackBufferSystem.mjs"() {
    init_Extensions();
    init_warn();
    init_Geometry();
    init_Shader();
    init_State();
    init_TextureSource();
    init_Texture();
    init_GlProgram();
    bigTriangleGeometry = new Geometry({
      attributes: {
        aPosition: [
          -1,
          -1,
          // Bottom left corner
          3,
          -1,
          // Bottom right corner, extending beyond right edge
          -1,
          3
          // Top left corner, extending beyond top edge
        ]
      }
    });
    _GlBackBufferSystem = class _GlBackBufferSystem2 {
      constructor(renderer) {
        this.useBackBuffer = false;
        this._useBackBufferThisRender = false;
        this._renderer = renderer;
      }
      init(options = {}) {
        const { useBackBuffer, antialias } = { ..._GlBackBufferSystem2.defaultOptions, ...options };
        this.useBackBuffer = useBackBuffer;
        this._antialias = antialias;
        if (!this._renderer.context.supports.msaa) {
          warn("antialiasing, is not supported on when using the back buffer");
          this._antialias = false;
        }
        this._state = State.for2d();
        const bigTriangleProgram = new GlProgram({
          vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
          fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
          name: "big-triangle"
        });
        this._bigTriangleShader = new Shader({
          glProgram: bigTriangleProgram,
          resources: {
            uTexture: Texture.WHITE.source
          }
        });
      }
      /**
       * This is called before the RenderTargetSystem is started. This is where
       * we replace the target with the back buffer if required.
       * @param options - The options for this render.
       */
      renderStart(options) {
        const renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
        this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot;
        if (this._useBackBufferThisRender) {
          const renderTarget2 = this._renderer.renderTarget.getRenderTarget(options.target);
          this._targetTexture = renderTarget2.colorTexture;
          options.target = this._getBackBufferTexture(renderTarget2.colorTexture);
        }
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const renderer = this._renderer;
        renderer.renderTarget.finishRenderPass();
        if (!this._useBackBufferThisRender)
          return;
        renderer.renderTarget.bind(this._targetTexture, false);
        this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source;
        renderer.encoder.draw({
          geometry: bigTriangleGeometry,
          shader: this._bigTriangleShader,
          state: this._state
        });
      }
      _getBackBufferTexture(targetSourceTexture) {
        this._backBufferTexture = this._backBufferTexture || new Texture({
          source: new TextureSource({
            width: targetSourceTexture.width,
            height: targetSourceTexture.height,
            resolution: targetSourceTexture._resolution,
            antialias: this._antialias
          })
        });
        this._backBufferTexture.source.resize(
          targetSourceTexture.width,
          targetSourceTexture.height,
          targetSourceTexture._resolution
        );
        return this._backBufferTexture;
      }
      /** destroys the back buffer */
      destroy() {
        if (this._backBufferTexture) {
          this._backBufferTexture.destroy();
          this._backBufferTexture = null;
        }
      }
    };
    _GlBackBufferSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "backBuffer",
      priority: 1
    };
    _GlBackBufferSystem.defaultOptions = {
      /** if true will use the back buffer where required */
      useBackBuffer: false
    };
    GlBackBufferSystem = _GlBackBufferSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs
var GlColorMaskSystem;
var init_GlColorMaskSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlColorMaskSystem.mjs"() {
    init_Extensions();
    GlColorMaskSystem = class {
      constructor(renderer) {
        this._colorMaskCache = 15;
        this._renderer = renderer;
      }
      setMask(colorMask) {
        if (this._colorMaskCache === colorMask)
          return;
        this._colorMaskCache = colorMask;
        this._renderer.gl.colorMask(
          !!(colorMask & 8),
          !!(colorMask & 4),
          !!(colorMask & 2),
          !!(colorMask & 1)
        );
      }
    };
    GlColorMaskSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "colorMask"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs
var GlEncoderSystem;
var init_GlEncoderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlEncoderSystem.mjs"() {
    init_Extensions();
    GlEncoderSystem = class {
      constructor(renderer) {
        this.commandFinished = Promise.resolve();
        this._renderer = renderer;
      }
      setGeometry(geometry, shader) {
        this._renderer.geometry.bind(geometry, shader.glProgram);
      }
      finishRenderPass() {
      }
      draw(options) {
        const renderer = this._renderer;
        const { geometry, shader, state, skipSync, topology: type2, size, start: start2, instanceCount } = options;
        renderer.shader.bind(shader, skipSync);
        renderer.geometry.bind(geometry, renderer.shader._activeProgram);
        if (state) {
          renderer.state.set(state);
        }
        renderer.geometry.draw(type2, size, start2, instanceCount ?? geometry.instanceCount);
      }
      destroy() {
        this._renderer = null;
      }
    };
    GlEncoderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "encoder"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs
var GlStencilSystem;
var init_GlStencilSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlStencilSystem.mjs"() {
    init_Extensions();
    init_GpuStencilModesToPixi();
    init_const3();
    GlStencilSystem = class {
      constructor(renderer) {
        this._stencilCache = {
          enabled: false,
          stencilReference: 0,
          stencilMode: STENCIL_MODES.NONE
        };
        this._renderTargetStencilState = /* @__PURE__ */ Object.create(null);
        renderer.renderTarget.onRenderTargetChange.add(this);
      }
      contextChange(gl) {
        this._gl = gl;
        this._comparisonFuncMapping = {
          always: gl.ALWAYS,
          never: gl.NEVER,
          equal: gl.EQUAL,
          "not-equal": gl.NOTEQUAL,
          less: gl.LESS,
          "less-equal": gl.LEQUAL,
          greater: gl.GREATER,
          "greater-equal": gl.GEQUAL
        };
        this._stencilOpsMapping = {
          keep: gl.KEEP,
          zero: gl.ZERO,
          replace: gl.REPLACE,
          invert: gl.INVERT,
          "increment-clamp": gl.INCR,
          "decrement-clamp": gl.DECR,
          "increment-wrap": gl.INCR_WRAP,
          "decrement-wrap": gl.DECR_WRAP
        };
        this._stencilCache.enabled = false;
        this._stencilCache.stencilMode = STENCIL_MODES.NONE;
        this._stencilCache.stencilReference = 0;
      }
      onRenderTargetChange(renderTarget) {
        if (this._activeRenderTarget === renderTarget)
          return;
        this._activeRenderTarget = renderTarget;
        let stencilState = this._renderTargetStencilState[renderTarget.uid];
        if (!stencilState) {
          stencilState = this._renderTargetStencilState[renderTarget.uid] = {
            stencilMode: STENCIL_MODES.DISABLED,
            stencilReference: 0
          };
        }
        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);
      }
      setStencilMode(stencilMode, stencilReference) {
        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];
        const gl = this._gl;
        const mode = GpuStencilModesToPixi[stencilMode];
        const _stencilCache = this._stencilCache;
        stencilState.stencilMode = stencilMode;
        stencilState.stencilReference = stencilReference;
        if (stencilMode === STENCIL_MODES.DISABLED) {
          if (this._stencilCache.enabled) {
            this._stencilCache.enabled = false;
            gl.disable(gl.STENCIL_TEST);
          }
          return;
        }
        if (!this._stencilCache.enabled) {
          this._stencilCache.enabled = true;
          gl.enable(gl.STENCIL_TEST);
        }
        if (stencilMode !== _stencilCache.stencilMode || _stencilCache.stencilReference !== stencilReference) {
          _stencilCache.stencilMode = stencilMode;
          _stencilCache.stencilReference = stencilReference;
          gl.stencilFunc(this._comparisonFuncMapping[mode.stencilBack.compare], stencilReference, 255);
          gl.stencilOp(gl.KEEP, gl.KEEP, this._stencilOpsMapping[mode.stencilBack.passOp]);
        }
      }
    };
    GlStencilSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "stencil"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs
function createUboElementsSTD40(uniformData) {
  const uboElements = uniformData.map((data) => ({
    data,
    offset: 0,
    size: 0
  }));
  let size = 0;
  let chunkSize = 0;
  let offset = 0;
  for (let i2 = 0; i2 < uboElements.length; i2++) {
    const uboElement = uboElements[i2];
    size = WGSL_TO_STD40_SIZE[uboElement.data.type];
    if (!size) {
      throw new Error(`Unknown type ${uboElement.data.type}`);
    }
    if (uboElement.data.size > 1) {
      size = Math.max(size, 16) * uboElement.data.size;
    }
    uboElement.size = size;
    if (chunkSize % size !== 0 && chunkSize < 16) {
      const lineUpValue = chunkSize % size % 16;
      chunkSize += lineUpValue;
      offset += lineUpValue;
    }
    if (chunkSize + size > 16) {
      offset = Math.ceil(offset / 16) * 16;
      uboElement.offset = offset;
      offset += size;
      chunkSize = size;
    } else {
      uboElement.offset = offset;
      chunkSize += size;
      offset += size;
    }
  }
  offset = Math.ceil(offset / 16) * 16;
  return { uboElements, size: offset };
}
var WGSL_TO_STD40_SIZE;
var init_createUboElementsSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboElementsSTD40.mjs"() {
    "use strict";
    WGSL_TO_STD40_SIZE = {
      f32: 4,
      "vec2<f32>": 8,
      "vec3<f32>": 12,
      "vec4<f32>": 16,
      "mat2x2<f32>": 16 * 2,
      "mat3x3<f32>": 16 * 3,
      "mat4x4<f32>": 16 * 4
      // TODO - not essential for now but support these in the future
      // int:      4,
      // ivec2:    8,
      // ivec3:    12,
      // ivec4:    16,
      // uint:     4,
      // uvec2:    8,
      // uvec3:    12,
      // uvec4:    16,
      // bool:     4,
      // bvec2:    8,
      // bvec3:    12,
      // bvec4:    16,
      // mat2:     16 * 2,
      // mat3:     16 * 3,
      // mat4:     16 * 4,
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs
function generateArraySyncSTD40(uboElement, offsetToAdd) {
  const rowSize = Math.max(WGSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1);
  const elementSize = uboElement.data.value.length / uboElement.data.size;
  const remainder = (4 - elementSize % 4) % 4;
  return `
        v = uv.${uboElement.data.name};
        offset += ${offsetToAdd};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${uboElement.data.size * rowSize}; i++)
        {
            for(var j = 0; j < ${elementSize}; j++)
            {
                data[arrayOffset++] = v[t++];
            }
            ${remainder !== 0 ? `arrayOffset += ${remainder};` : ""}
        }
    `;
}
var init_generateArraySyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateArraySyncSTD40.mjs"() {
    init_createUboElementsSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs
function createUboSyncFunctionSTD40(uboElements) {
  return createUboSyncFunction(
    uboElements,
    "uboStd40",
    generateArraySyncSTD40,
    uboSyncFunctionsSTD40
  );
}
var init_createUboSyncSTD40 = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/createUboSyncSTD40.mjs"() {
    init_createUboSyncFunction();
    init_uboSyncFunctions();
    init_generateArraySyncSTD40();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs
var GlUboSystem;
var init_GlUboSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlUboSystem.mjs"() {
    init_Extensions();
    init_UboSystem();
    init_createUboElementsSTD40();
    init_createUboSyncSTD40();
    GlUboSystem = class extends UboSystem {
      constructor() {
        super({
          createUboElements: createUboElementsSTD40,
          generateUboSync: createUboSyncFunctionSTD40
        });
      }
    };
    GlUboSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "ubo"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs
var GlRenderTarget;
var init_GlRenderTarget = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/GlRenderTarget.mjs"() {
    "use strict";
    GlRenderTarget = class {
      constructor() {
        this.width = -1;
        this.height = -1;
        this.msaa = false;
        this.msaaRenderBuffer = [];
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs
var GlRenderTargetAdaptor;
var init_GlRenderTargetAdaptor = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetAdaptor.mjs"() {
    init_Rectangle();
    init_warn();
    init_const7();
    init_GlRenderTarget();
    GlRenderTargetAdaptor = class {
      constructor() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      init(renderer, renderTargetSystem) {
        this._renderer = renderer;
        this._renderTargetSystem = renderTargetSystem;
        renderer.runners.contextChange.add(this);
      }
      contextChange() {
        this._clearColorCache = [0, 0, 0, 0];
        this._viewPortCache = new Rectangle();
      }
      copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
        const renderTargetSystem = this._renderTargetSystem;
        const renderer = this._renderer;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture);
        const gl = renderer.gl;
        this.finishRenderPass(sourceRenderSurfaceTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        renderer.texture.bind(destinationTexture, 0);
        gl.copyTexSubImage2D(
          gl.TEXTURE_2D,
          0,
          originDest.x,
          originDest.y,
          originSrc.x,
          originSrc.y,
          size.width,
          size.height
        );
        return destinationTexture;
      }
      startRenderPass(renderTarget, clear = true, clearColor, viewport) {
        const renderTargetSystem = this._renderTargetSystem;
        const source2 = renderTarget.colorTexture;
        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        let viewPortY = viewport.y;
        if (renderTarget.isRoot) {
          viewPortY = source2.pixelHeight - viewport.height;
        }
        renderTarget.colorTextures.forEach((texture) => {
          this._renderer.texture.unbind(texture);
        });
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, gpuRenderTarget.framebuffer);
        const viewPortCache = this._viewPortCache;
        if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
          viewPortCache.x = viewport.x;
          viewPortCache.y = viewPortY;
          viewPortCache.width = viewport.width;
          viewPortCache.height = viewport.height;
          gl.viewport(
            viewport.x,
            viewPortY,
            viewport.width,
            viewport.height
          );
        }
        if (!gpuRenderTarget.depthStencilRenderBuffer && (renderTarget.stencil || renderTarget.depth)) {
          this._initStencil(gpuRenderTarget);
        }
        this.clear(renderTarget, clear, clearColor);
      }
      finishRenderPass(renderTarget) {
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        if (!glRenderTarget.msaa)
          return;
        const gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, glRenderTarget.framebuffer);
        gl.blitFramebuffer(
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          0,
          0,
          glRenderTarget.width,
          glRenderTarget.height,
          gl.COLOR_BUFFER_BIT,
          gl.NEAREST
        );
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
      }
      initGpuRenderTarget(renderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const glRenderTarget = new GlRenderTarget();
        if (renderTarget.colorTexture.resource === renderer.gl.canvas) {
          glRenderTarget.framebuffer = null;
          return glRenderTarget;
        }
        this._initColor(renderTarget, glRenderTarget);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return glRenderTarget;
      }
      destroyGpuRenderTarget(gpuRenderTarget) {
        const gl = this._renderer.gl;
        if (gpuRenderTarget.framebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.framebuffer);
          gpuRenderTarget.framebuffer = null;
        }
        if (gpuRenderTarget.resolveTargetFramebuffer) {
          gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer);
          gpuRenderTarget.resolveTargetFramebuffer = null;
        }
        if (gpuRenderTarget.depthStencilRenderBuffer) {
          gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer);
          gpuRenderTarget.depthStencilRenderBuffer = null;
        }
        gpuRenderTarget.msaaRenderBuffer.forEach((renderBuffer) => {
          gl.deleteRenderbuffer(renderBuffer);
        });
        gpuRenderTarget.msaaRenderBuffer = null;
      }
      clear(_renderTarget, clear, clearColor) {
        if (!clear)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        if (typeof clear === "boolean") {
          clear = clear ? CLEAR.ALL : CLEAR.NONE;
        }
        const gl = this._renderer.gl;
        if (clear & CLEAR.COLOR) {
          clearColor ?? (clearColor = renderTargetSystem.defaultClearColor);
          const clearColorCache = this._clearColorCache;
          const clearColorArray = clearColor;
          if (clearColorCache[0] !== clearColorArray[0] || clearColorCache[1] !== clearColorArray[1] || clearColorCache[2] !== clearColorArray[2] || clearColorCache[3] !== clearColorArray[3]) {
            clearColorCache[0] = clearColorArray[0];
            clearColorCache[1] = clearColorArray[1];
            clearColorCache[2] = clearColorArray[2];
            clearColorCache[3] = clearColorArray[3];
            gl.clearColor(clearColorArray[0], clearColorArray[1], clearColorArray[2], clearColorArray[3]);
          }
        }
        gl.clear(clear);
      }
      resizeGpuRenderTarget(renderTarget) {
        if (renderTarget.isRoot)
          return;
        const renderTargetSystem = this._renderTargetSystem;
        const glRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        if (renderTarget.stencil || renderTarget.depth) {
          this._resizeStencil(glRenderTarget);
        }
      }
      _initColor(renderTarget, glRenderTarget) {
        const renderer = this._renderer;
        const gl = renderer.gl;
        const resolveTargetFramebuffer = gl.createFramebuffer();
        glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
        gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
        glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
        glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          const source2 = colorTexture.source;
          if (source2.antialias) {
            if (renderer.context.supports.msaa) {
              glRenderTarget.msaa = true;
            } else {
              warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1");
            }
          }
          renderer.texture.bindSource(source2, 0);
          const glSource = renderer.texture.getGlSource(source2);
          const glTexture = glSource.texture;
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0 + i2,
            3553,
            // texture.target,
            glTexture,
            0
          );
        });
        if (glRenderTarget.msaa) {
          const viewFramebuffer = gl.createFramebuffer();
          glRenderTarget.framebuffer = viewFramebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((_3, i2) => {
            const msaaRenderBuffer = gl.createRenderbuffer();
            glRenderTarget.msaaRenderBuffer[i2] = msaaRenderBuffer;
          });
        } else {
          glRenderTarget.framebuffer = resolveTargetFramebuffer;
        }
        this._resizeColor(renderTarget, glRenderTarget);
      }
      _resizeColor(renderTarget, glRenderTarget) {
        const source2 = renderTarget.colorTexture.source;
        glRenderTarget.width = source2.pixelWidth;
        glRenderTarget.height = source2.pixelHeight;
        renderTarget.colorTextures.forEach((colorTexture, i2) => {
          if (i2 === 0)
            return;
          colorTexture.source.resize(source2.width, source2.height, source2._resolution);
        });
        if (glRenderTarget.msaa) {
          const renderer = this._renderer;
          const gl = renderer.gl;
          const viewFramebuffer = glRenderTarget.framebuffer;
          gl.bindFramebuffer(gl.FRAMEBUFFER, viewFramebuffer);
          renderTarget.colorTextures.forEach((colorTexture, i2) => {
            const source22 = colorTexture.source;
            renderer.texture.bindSource(source22, 0);
            const glSource = renderer.texture.getGlSource(source22);
            const glInternalFormat = glSource.internalFormat;
            const msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i2];
            gl.bindRenderbuffer(
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
            gl.renderbufferStorageMultisample(
              gl.RENDERBUFFER,
              4,
              glInternalFormat,
              source22.pixelWidth,
              source22.pixelHeight
            );
            gl.framebufferRenderbuffer(
              gl.FRAMEBUFFER,
              gl.COLOR_ATTACHMENT0 + i2,
              gl.RENDERBUFFER,
              msaaRenderBuffer
            );
          });
        }
      }
      _initStencil(glRenderTarget) {
        if (glRenderTarget.framebuffer === null)
          return;
        const gl = this._renderer.gl;
        const depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          gl.DEPTH_STENCIL_ATTACHMENT,
          gl.RENDERBUFFER,
          depthStencilRenderBuffer
        );
        this._resizeStencil(glRenderTarget);
      }
      _resizeStencil(glRenderTarget) {
        const gl = this._renderer.gl;
        gl.bindRenderbuffer(
          gl.RENDERBUFFER,
          glRenderTarget.depthStencilRenderBuffer
        );
        if (glRenderTarget.msaa) {
          gl.renderbufferStorageMultisample(
            gl.RENDERBUFFER,
            4,
            gl.DEPTH24_STENCIL8,
            glRenderTarget.width,
            glRenderTarget.height
          );
        } else {
          gl.renderbufferStorage(
            gl.RENDERBUFFER,
            this._renderer.context.webGLVersion === 2 ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL,
            glRenderTarget.width,
            glRenderTarget.height
          );
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs
var GlRenderTargetSystem;
var init_GlRenderTargetSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/renderTarget/GlRenderTargetSystem.mjs"() {
    init_Extensions();
    init_RenderTargetSystem();
    init_GlRenderTargetAdaptor();
    GlRenderTargetSystem = class extends RenderTargetSystem {
      constructor(renderer) {
        super(renderer);
        this.adaptor = new GlRenderTargetAdaptor();
        this.adaptor.init(renderer, this);
      }
    };
    GlRenderTargetSystem.extension = {
      type: [ExtensionType.WebGLSystem],
      name: "renderTarget"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs
function generateShaderSyncCode(shader, shaderSystem) {
  const funcFragments = [];
  const headerFragments = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
  let addedTextreSystem = false;
  let blockIndex = 0;
  let textureCount = 0;
  const programData = shaderSystem._getProgramData(shader.glProgram);
  for (const i2 in shader.groups) {
    const group = shader.groups[i2];
    funcFragments.push(`
            resources = g[${i2}].resources;
        `);
    for (const j3 in group.resources) {
      const resource = group.resources[j3];
      if (resource instanceof UniformGroup) {
        if (resource.ubo) {
          funcFragments.push(`
                        sS.bindUniformBlock(
                            resources[${j3}],
                            sS._uniformBindMap[${i2}[${j3}],
                            ${blockIndex++}
                        );
                    `);
        } else {
          funcFragments.push(`
                        ugS.updateUniformGroup(resources[${j3}], p, sD);
                    `);
        }
      } else if (resource instanceof BufferResource) {
        funcFragments.push(`
                    sS.bindUniformBlock(
                        resources[${j3}],
                        sS._uniformBindMap[${i2}[${j3}],
                        ${blockIndex++}
                    );
                `);
      } else if (resource instanceof TextureSource) {
        const uniformName = shader._uniformBindMap[i2][j3];
        const uniformData = programData.uniformData[uniformName];
        if (uniformData) {
          if (!addedTextreSystem) {
            addedTextreSystem = true;
            headerFragments.push(`
                        var tS = r.texture;
                        `);
          }
          shaderSystem._gl.uniform1i(uniformData.location, textureCount);
          funcFragments.push(`
                        tS.bind(resources[${j3}], ${textureCount});
                    `);
          textureCount++;
        }
      }
    }
  }
  const functionSource = [...headerFragments, ...funcFragments].join("\n");
  return new Function("r", "s", "sD", functionSource);
}
var init_GenerateShaderSyncCode = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GenerateShaderSyncCode.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_TextureSource();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs
var GlProgramData;
var init_GlProgramData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgramData.mjs"() {
    "use strict";
    GlProgramData = class {
      /**
       * Makes a new Pixi program.
       * @param program - webgl program
       * @param uniformData - uniforms
       */
      constructor(program, uniformData) {
        this.program = program;
        this.uniformData = uniformData;
        this.uniformGroups = {};
        this.uniformDirtyGroups = {};
        this.uniformBlockBindings = {};
      }
      /** Destroys this program. */
      destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.uniformDirtyGroups = null;
        this.uniformBlockBindings = null;
        this.program = null;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs
function compileShader(gl, type2, src) {
  const shader = gl.createShader(type2);
  gl.shaderSource(shader, src);
  gl.compileShader(shader);
  return shader;
}
var init_compileShader = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/compileShader.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs
function booleanArray(size) {
  const array2 = new Array(size);
  for (let i2 = 0; i2 < array2.length; i2++) {
    array2[i2] = false;
  }
  return array2;
}
function defaultValue(type2, size) {
  switch (type2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * size);
    case "vec3":
      return new Float32Array(3 * size);
    case "vec4":
      return new Float32Array(4 * size);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * size);
    case "ivec3":
      return new Int32Array(3 * size);
    case "ivec4":
      return new Int32Array(4 * size);
    case "uvec2":
      return new Uint32Array(2 * size);
    case "uvec3":
      return new Uint32Array(3 * size);
    case "uvec4":
      return new Uint32Array(4 * size);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * size);
    case "bvec3":
      return booleanArray(3 * size);
    case "bvec4":
      return booleanArray(4 * size);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var init_defaultValue = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/defaultValue.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs
function mapType(gl, type2) {
  if (!GL_TABLE) {
    const typeNames = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (let i2 = 0; i2 < typeNames.length; ++i2) {
      const tn = typeNames[i2];
      GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn];
    }
  }
  return GL_TABLE[type2];
}
function mapGlToVertexFormat(gl, type2) {
  const typeValue = mapType(gl, type2);
  return GLSL_TO_VERTEX_TYPES[typeValue] || "float32";
}
var GL_TABLE, GL_TO_GLSL_TYPES, GLSL_TO_VERTEX_TYPES;
var init_mapType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/mapType.mjs"() {
    "use strict";
    GL_TABLE = null;
    GL_TO_GLSL_TYPES = {
      FLOAT: "float",
      FLOAT_VEC2: "vec2",
      FLOAT_VEC3: "vec3",
      FLOAT_VEC4: "vec4",
      INT: "int",
      INT_VEC2: "ivec2",
      INT_VEC3: "ivec3",
      INT_VEC4: "ivec4",
      UNSIGNED_INT: "uint",
      UNSIGNED_INT_VEC2: "uvec2",
      UNSIGNED_INT_VEC3: "uvec3",
      UNSIGNED_INT_VEC4: "uvec4",
      BOOL: "bool",
      BOOL_VEC2: "bvec2",
      BOOL_VEC3: "bvec3",
      BOOL_VEC4: "bvec4",
      FLOAT_MAT2: "mat2",
      FLOAT_MAT3: "mat3",
      FLOAT_MAT4: "mat4",
      SAMPLER_2D: "sampler2D",
      INT_SAMPLER_2D: "sampler2D",
      UNSIGNED_INT_SAMPLER_2D: "sampler2D",
      SAMPLER_CUBE: "samplerCube",
      INT_SAMPLER_CUBE: "samplerCube",
      UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
      SAMPLER_2D_ARRAY: "sampler2DArray",
      INT_SAMPLER_2D_ARRAY: "sampler2DArray",
      UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    };
    GLSL_TO_VERTEX_TYPES = {
      float: "float32",
      vec2: "float32x2",
      vec3: "float32x3",
      vec4: "float32x4",
      int: "sint32",
      ivec2: "sint32x2",
      ivec3: "sint32x3",
      ivec4: "sint32x4",
      uint: "uint32",
      uvec2: "uint32x2",
      uvec3: "uint32x3",
      uvec4: "uint32x4",
      bool: "uint32",
      bvec2: "uint32x2",
      bvec3: "uint32x3",
      bvec4: "uint32x4"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs
function extractAttributesFromGlProgram(program, gl, sortAttributes = false) {
  const attributes = {};
  const totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < totalAttributes; i2++) {
    const attribData = gl.getActiveAttrib(program, i2);
    if (attribData.name.startsWith("gl_")) {
      continue;
    }
    const format2 = mapGlToVertexFormat(gl, attribData.type);
    attributes[attribData.name] = {
      location: 0,
      // set further down..
      format: format2,
      stride: getAttributeInfoFromFormat(format2).stride,
      offset: 0,
      instance: false,
      start: 0
    };
  }
  const keys2 = Object.keys(attributes);
  if (sortAttributes) {
    keys2.sort((a3, b2) => a3 > b2 ? 1 : -1);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      attributes[keys2[i2]].location = i2;
      gl.bindAttribLocation(program, i2, keys2[i2]);
    }
    gl.linkProgram(program);
  } else {
    for (let i2 = 0; i2 < keys2.length; i2++) {
      attributes[keys2[i2]].location = gl.getAttribLocation(program, keys2[i2]);
    }
  }
  return attributes;
}
var init_extractAttributesFromGlProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/extractAttributesFromGlProgram.mjs"() {
    init_getAttributeInfoFromFormat();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs
function getUboData(program, gl) {
  if (!gl.ACTIVE_UNIFORM_BLOCKS)
    return {};
  const uniformBlocks = {};
  const totalUniformsBlocks = gl.getProgramParameter(program, gl.ACTIVE_UNIFORM_BLOCKS);
  for (let i2 = 0; i2 < totalUniformsBlocks; i2++) {
    const name = gl.getActiveUniformBlockName(program, i2);
    const uniformBlockIndex = gl.getUniformBlockIndex(program, name);
    const size = gl.getActiveUniformBlockParameter(program, i2, gl.UNIFORM_BLOCK_DATA_SIZE);
    uniformBlocks[name] = {
      name,
      index: uniformBlockIndex,
      size
    };
  }
  return uniformBlocks;
}
var init_getUboData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUboData.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs
function getUniformData(program, gl) {
  const uniforms = {};
  const totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i2 = 0; i2 < totalUniforms; i2++) {
    const uniformData = gl.getActiveUniform(program, i2);
    const name = uniformData.name.replace(/\[.*?\]$/, "");
    const isArray2 = !!uniformData.name.match(/\[.*?\]$/);
    const type2 = mapType(gl, uniformData.type);
    uniforms[name] = {
      name,
      index: i2,
      type: type2,
      size: uniformData.size,
      isArray: isArray2,
      value: defaultValue(type2, uniformData.size)
    };
  }
  return uniforms;
}
var init_getUniformData = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getUniformData.mjs"() {
    init_defaultValue();
    init_mapType();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs
function logPrettyShaderError(gl, shader) {
  const shaderSrc = gl.getShaderSource(shader).split("\n").map((line, index2) => `${index2}: ${line}`);
  const shaderLog = gl.getShaderInfoLog(shader);
  const splitShader = shaderLog.split("\n");
  const dedupe = {};
  const lineNumbers = splitShader.map((line) => parseFloat(line.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter((n2) => {
    if (n2 && !dedupe[n2]) {
      dedupe[n2] = true;
      return true;
    }
    return false;
  });
  const logArgs = [""];
  lineNumbers.forEach((number3) => {
    shaderSrc[number3 - 1] = `%c${shaderSrc[number3 - 1]}%c`;
    logArgs.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  const fragmentSourceToLog = shaderSrc.join("\n");
  logArgs[0] = fragmentSourceToLog;
  console.error(shaderLog);
  console.groupCollapsed("click to view full shader code");
  console.warn(...logArgs);
  console.groupEnd();
}
function logProgramError(gl, program, vertexShader, fragmentShader) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, vertexShader);
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      logPrettyShaderError(gl, fragmentShader);
    }
    console.error("PixiJS Error: Could not initialize shader.");
    if (gl.getProgramInfoLog(program) !== "") {
      console.warn("PixiJS Warning: gl.getProgramInfoLog()", gl.getProgramInfoLog(program));
    }
  }
}
var init_logProgramError = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/logProgramError.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs
function generateProgram(gl, program) {
  const glVertShader = compileShader(gl, gl.VERTEX_SHADER, program.vertex);
  const glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
  const webGLProgram = gl.createProgram();
  gl.attachShader(webGLProgram, glVertShader);
  gl.attachShader(webGLProgram, glFragShader);
  const transformFeedbackVaryings = program.transformFeedbackVaryings;
  if (transformFeedbackVaryings) {
    if (typeof gl.transformFeedbackVaryings !== "function") {
      warn(`TransformFeedback is not supported but TransformFeedbackVaryings are given.`);
    } else {
      gl.transformFeedbackVaryings(
        webGLProgram,
        transformFeedbackVaryings.names,
        transformFeedbackVaryings.bufferMode === "separate" ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS
      );
    }
  }
  gl.linkProgram(webGLProgram);
  if (!gl.getProgramParameter(webGLProgram, gl.LINK_STATUS)) {
    logProgramError(gl, webGLProgram, glVertShader, glFragShader);
  }
  program._attributeData = extractAttributesFromGlProgram(
    webGLProgram,
    gl,
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex)
  );
  program._uniformData = getUniformData(webGLProgram, gl);
  program._uniformBlockData = getUboData(webGLProgram, gl);
  gl.deleteShader(glVertShader);
  gl.deleteShader(glFragShader);
  const uniformData = {};
  for (const i2 in program._uniformData) {
    const data = program._uniformData[i2];
    uniformData[i2] = {
      location: gl.getUniformLocation(webGLProgram, i2),
      value: defaultValue(data.type, data.size)
    };
  }
  const glProgram3 = new GlProgramData(webGLProgram, uniformData);
  return glProgram3;
}
var init_generateProgram = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/generateProgram.mjs"() {
    init_warn();
    init_GlProgramData();
    init_compileShader();
    init_defaultValue();
    init_extractAttributesFromGlProgram();
    init_getUboData();
    init_getUniformData();
    init_logProgramError();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs
var defaultSyncData, GlShaderSystem;
var init_GlShaderSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlShaderSystem.mjs"() {
    init_Extensions();
    init_maxRecommendedTextures();
    init_GenerateShaderSyncCode();
    init_generateProgram();
    defaultSyncData = {
      textureCount: 0,
      blockIndex: 0
    };
    GlShaderSystem = class {
      constructor(renderer) {
        this._activeProgram = null;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._nextIndex = 0;
        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
        this._programDataHash = /* @__PURE__ */ Object.create(null);
        this._boundUniformsIdsToIndexHash = /* @__PURE__ */ Object.create(null);
        this._boundIndexToUniformsHash = /* @__PURE__ */ Object.create(null);
        this._shaderSyncFunctions = /* @__PURE__ */ Object.create(null);
        this._activeProgram = null;
        this.maxTextures = getMaxTexturesPerBatch();
      }
      /**
       * Changes the current shader to the one given in parameter.
       * @param shader - the new shader
       * @param skipSync - false if the shader should automatically sync its uniforms.
       * @returns the glProgram that belongs to the shader.
       */
      bind(shader, skipSync) {
        this._setProgram(shader.glProgram);
        if (skipSync)
          return;
        defaultSyncData.textureCount = 0;
        defaultSyncData.blockIndex = 0;
        let syncFunction = this._shaderSyncFunctions[shader.glProgram._key];
        if (!syncFunction) {
          syncFunction = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this);
        }
        syncFunction(this._renderer, shader, defaultSyncData);
      }
      /**
       * Updates the uniform group.
       * @param uniformGroup - the uniform group to update
       */
      updateUniformGroup(uniformGroup) {
        this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
      }
      /**
       * Binds a uniform block to the shader.
       * @param uniformGroup - the uniform group to bind
       * @param name - the name of the uniform block
       * @param index - the index of the uniform block
       */
      bindUniformBlock(uniformGroup, name, index2 = 0) {
        const bufferSystem = this._renderer.buffer;
        const programData = this._getProgramData(this._activeProgram);
        const isBufferResource = uniformGroup._bufferResource;
        if (isBufferResource) {
          this._renderer.ubo.updateUniformGroup(uniformGroup);
        }
        bufferSystem.updateBuffer(uniformGroup.buffer);
        let boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid];
        if (boundIndex === void 0) {
          const nextIndex = this._nextIndex++ % this._maxBindings;
          const currentBoundUniformGroup = this._boundIndexToUniformsHash[nextIndex];
          if (currentBoundUniformGroup) {
            this._boundUniformsIdsToIndexHash[currentBoundUniformGroup.uid] = void 0;
          }
          boundIndex = this._boundUniformsIdsToIndexHash[uniformGroup.uid] = nextIndex;
          this._boundIndexToUniformsHash[nextIndex] = uniformGroup;
          if (isBufferResource) {
            bufferSystem.bindBufferRange(uniformGroup.buffer, nextIndex, uniformGroup.offset);
          } else {
            bufferSystem.bindBufferBase(uniformGroup.buffer, nextIndex);
          }
        }
        const gl = this._gl;
        const uniformBlockIndex = this._activeProgram._uniformBlockData[name].index;
        if (programData.uniformBlockBindings[index2] === boundIndex)
          return;
        programData.uniformBlockBindings[index2] = boundIndex;
        gl.uniformBlockBinding(programData.program, uniformBlockIndex, boundIndex);
      }
      _setProgram(program) {
        if (this._activeProgram === program)
          return;
        this._activeProgram = program;
        const programData = this._getProgramData(program);
        this._gl.useProgram(programData.program);
      }
      /**
       * @param program - the program to get the data for
       * @internal
       * @private
       */
      _getProgramData(program) {
        return this._programDataHash[program._key] || this._createProgramData(program);
      }
      _createProgramData(program) {
        const key = program._key;
        this._programDataHash[key] = generateProgram(this._gl, program);
        return this._programDataHash[key];
      }
      destroy() {
        for (const key of Object.keys(this._programDataHash)) {
          const programData = this._programDataHash[key];
          programData.destroy();
          this._programDataHash[key] = null;
        }
        this._programDataHash = null;
        this._boundUniformsIdsToIndexHash = null;
      }
      /**
       * Creates a function that can be executed that will sync the shader as efficiently as possible.
       * Overridden by the unsafe eval package if you don't want eval used in your project.
       * @param shader - the shader to generate the sync function for
       * @param shaderSystem - the shader system to use
       * @returns - the generated sync function
       * @ignore
       */
      _generateShaderSync(shader, shaderSystem) {
        return generateShaderSyncCode(shader, shaderSystem);
      }
    };
    GlShaderSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "shader"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs
var UNIFORM_TO_SINGLE_SETTERS, UNIFORM_TO_ARRAY_SETTERS;
var init_generateUniformsSyncTypes = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSyncTypes.mjs"() {
    "use strict";
    UNIFORM_TO_SINGLE_SETTERS = {
      f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
      "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
      "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
      "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
      i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
      "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
      "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
      "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
      bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
      "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
      "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
      "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`
    };
    UNIFORM_TO_ARRAY_SETTERS = {
      f32: `gl.uniform1fv(location, v);`,
      "vec2<f32>": `gl.uniform2fv(location, v);`,
      "vec3<f32>": `gl.uniform3fv(location, v);`,
      "vec4<f32>": `gl.uniform4fv(location, v);`,
      "mat2x2<f32>": `gl.uniformMatrix2fv(location, false, v);`,
      "mat3x3<f32>": `gl.uniformMatrix3fv(location, false, v);`,
      "mat4x4<f32>": `gl.uniformMatrix4fv(location, false, v);`,
      i32: `gl.uniform1iv(location, v);`,
      "vec2<i32>": `gl.uniform2iv(location, v);`,
      "vec3<i32>": `gl.uniform3iv(location, v);`,
      "vec4<i32>": `gl.uniform4iv(location, v);`,
      u32: `gl.uniform1iv(location, v);`,
      "vec2<u32>": `gl.uniform2iv(location, v);`,
      "vec3<u32>": `gl.uniform3iv(location, v);`,
      "vec4<u32>": `gl.uniform4iv(location, v);`,
      bool: `gl.uniform1iv(location, v);`,
      "vec2<bool>": `gl.uniform2iv(location, v);`,
      "vec3<bool>": `gl.uniform3iv(location, v);`,
      "vec4<bool>": `gl.uniform4iv(location, v);`
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs
function generateUniformsSync(group, uniformData) {
  const funcFragments = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
  for (const i2 in group.uniforms) {
    if (!uniformData[i2]) {
      if (group.uniforms[i2] instanceof UniformGroup) {
        if (group.uniforms[i2].ubo) {
          funcFragments.push(`
                        renderer.shader.bindUniformBlock(uv.${i2}, "${i2}");
                    `);
        } else {
          funcFragments.push(`
                        renderer.shader.updateUniformGroup(uv.${i2});
                    `);
        }
      } else if (group.uniforms[i2] instanceof BufferResource) {
        funcFragments.push(`
                        renderer.shader.bindBufferResource(uv.${i2}, "${i2}");
                    `);
      }
      continue;
    }
    const uniform = group.uniformStructures[i2];
    let parsed = false;
    for (let j3 = 0; j3 < uniformParsers.length; j3++) {
      const parser = uniformParsers[j3];
      if (uniform.type === parser.type && parser.test(uniform)) {
        funcFragments.push(`name = "${i2}";`, uniformParsers[j3].uniform);
        parsed = true;
        break;
      }
    }
    if (!parsed) {
      const templateType = uniform.size === 1 ? UNIFORM_TO_SINGLE_SETTERS : UNIFORM_TO_ARRAY_SETTERS;
      const template = templateType[uniform.type].replace("location", `ud["${i2}"].location`);
      funcFragments.push(`
            cu = ud["${i2}"];
            cv = cu.value;
            v = uv["${i2}"];
            ${template};`);
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
}
var init_generateUniformsSync = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/utils/generateUniformsSync.mjs"() {
    init_BufferResource();
    init_UniformGroup();
    init_uniformParsers();
    init_generateUniformsSyncTypes();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs
var GlUniformGroupSystem;
var init_GlUniformGroupSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlUniformGroupSystem.mjs"() {
    init_Extensions();
    init_generateUniformsSync();
    GlUniformGroupSystem = class {
      /** @param renderer - The renderer this System works for. */
      constructor(renderer) {
        this._cache = {};
        this._uniformGroupSyncHash = {};
        this._renderer = renderer;
        this.gl = null;
        this._cache = {};
      }
      contextChange(gl) {
        this.gl = gl;
      }
      /**
       * Uploads the uniforms values to the currently bound shader.
       * @param group - the uniforms values that be applied to the current shader
       * @param program
       * @param syncData
       * @param syncData.textureCount
       */
      updateUniformGroup(group, program, syncData) {
        const programData = this._renderer.shader._getProgramData(program);
        if (!group.isStatic || group._dirtyId !== programData.uniformDirtyGroups[group.uid]) {
          programData.uniformDirtyGroups[group.uid] = group._dirtyId;
          const syncFunc = this._getUniformSyncFunction(group, program);
          syncFunc(programData.uniformData, group.uniforms, this._renderer, syncData);
        }
      }
      /**
       * Overridable by the pixi.js/unsafe-eval package to use static syncUniforms instead.
       * @param group
       * @param program
       */
      _getUniformSyncFunction(group, program) {
        return this._uniformGroupSyncHash[group._signature]?.[program._key] || this._createUniformSyncFunction(group, program);
      }
      _createUniformSyncFunction(group, program) {
        const uniformGroupSyncHash = this._uniformGroupSyncHash[group._signature] || (this._uniformGroupSyncHash[group._signature] = {});
        const id2 = this._getSignature(group, program._uniformData, "u");
        if (!this._cache[id2]) {
          this._cache[id2] = this._generateUniformsSync(group, program._uniformData);
        }
        uniformGroupSyncHash[program._key] = this._cache[id2];
        return uniformGroupSyncHash[program._key];
      }
      _generateUniformsSync(group, uniformData) {
        return generateUniformsSync(group, uniformData);
      }
      /**
       * Takes a uniform group and data and generates a unique signature for them.
       * @param group - The uniform group to get signature of
       * @param group.uniforms
       * @param uniformData - Uniform information generated by the shader
       * @param preFix
       * @returns Unique signature of the uniform group
       */
      _getSignature(group, uniformData, preFix) {
        const uniforms = group.uniforms;
        const strings = [`${preFix}-`];
        for (const i2 in uniforms) {
          strings.push(i2);
          if (uniformData[i2]) {
            strings.push(uniformData[i2].type);
          }
        }
        return strings.join("-");
      }
      /** Destroys this System and removes all its textures. */
      destroy() {
        this._renderer = null;
        this._cache = null;
      }
    };
    GlUniformGroupSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "uniformGroup"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs
function mapWebGLBlendModesToPixi(gl) {
  const blendMap = {};
  blendMap.normal = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.add = [gl.ONE, gl.ONE];
  blendMap.multiply = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.screen = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.none = [0, 0];
  blendMap["normal-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap["add-npm"] = [gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE];
  blendMap["screen-npm"] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
  blendMap.erase = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
  const isWebGl2 = !(gl instanceof DOMAdapter.get().getWebGLRenderingContext());
  if (isWebGl2) {
    blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MIN, gl.MIN];
    blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.MAX, gl.MAX];
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext) {
      blendMap.min = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MIN_EXT, ext.MIN_EXT];
      blendMap.max = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, ext.MAX_EXT, ext.MAX_EXT];
    }
  }
  return blendMap;
}
var init_mapWebGLBlendModesToPixi = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/mapWebGLBlendModesToPixi.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs
var BLEND2, OFFSET2, CULLING2, DEPTH_TEST2, WINDING2, DEPTH_MASK2, _GlStateSystem, GlStateSystem;
var init_GlStateSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/state/GlStateSystem.mjs"() {
    init_Extensions();
    init_State();
    init_mapWebGLBlendModesToPixi();
    BLEND2 = 0;
    OFFSET2 = 1;
    CULLING2 = 2;
    DEPTH_TEST2 = 3;
    WINDING2 = 4;
    DEPTH_MASK2 = 5;
    _GlStateSystem = class _GlStateSystem2 {
      constructor() {
        this.gl = null;
        this.stateId = 0;
        this.polygonOffset = 0;
        this.blendMode = "none";
        this._blendEq = false;
        this.map = [];
        this.map[BLEND2] = this.setBlend;
        this.map[OFFSET2] = this.setOffset;
        this.map[CULLING2] = this.setCullFace;
        this.map[DEPTH_TEST2] = this.setDepthTest;
        this.map[WINDING2] = this.setFrontFace;
        this.map[DEPTH_MASK2] = this.setDepthMask;
        this.checks = [];
        this.defaultState = State.for2d();
      }
      contextChange(gl) {
        this.gl = gl;
        this.blendModesMap = mapWebGLBlendModesToPixi(gl);
        this.reset();
      }
      /**
       * Sets the current state
       * @param {*} state - The state to set.
       */
      set(state) {
        state = state || this.defaultState;
        if (this.stateId !== state.data) {
          let diff = this.stateId ^ state.data;
          let i2 = 0;
          while (diff) {
            if (diff & 1) {
              this.map[i2].call(this, !!(state.data & 1 << i2));
            }
            diff = diff >> 1;
            i2++;
          }
          this.stateId = state.data;
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
      }
      /**
       * Sets the state, when previous state is unknown.
       * @param {*} state - The state to set
       */
      forceState(state) {
        state = state || this.defaultState;
        for (let i2 = 0; i2 < this.map.length; i2++) {
          this.map[i2].call(this, !!(state.data & 1 << i2));
        }
        for (let i2 = 0; i2 < this.checks.length; i2++) {
          this.checks[i2](this, state);
        }
        this.stateId = state.data;
      }
      /**
       * Sets whether to enable or disable blending.
       * @param value - Turn on or off WebGl blending.
       */
      setBlend(value) {
        this._updateCheck(_GlStateSystem2._checkBlendMode, value);
        this.gl[value ? "enable" : "disable"](this.gl.BLEND);
      }
      /**
       * Sets whether to enable or disable polygon offset fill.
       * @param value - Turn on or off webgl polygon offset testing.
       */
      setOffset(value) {
        this._updateCheck(_GlStateSystem2._checkPolygonOffset, value);
        this.gl[value ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      /**
       * Sets whether to enable or disable depth test.
       * @param value - Turn on or off webgl depth testing.
       */
      setDepthTest(value) {
        this.gl[value ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      /**
       * Sets whether to enable or disable depth mask.
       * @param value - Turn on or off webgl depth mask.
       */
      setDepthMask(value) {
        this.gl.depthMask(value);
      }
      /**
       * Sets whether to enable or disable cull face.
       * @param {boolean} value - Turn on or off webgl cull face.
       */
      setCullFace(value) {
        this.gl[value ? "enable" : "disable"](this.gl.CULL_FACE);
      }
      /**
       * Sets the gl front face.
       * @param {boolean} value - true is clockwise and false is counter-clockwise
       */
      setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? "CW" : "CCW"]);
      }
      /**
       * Sets the blend mode.
       * @param {number} value - The blend mode to set to.
       */
      setBlendMode(value) {
        if (!this.blendModesMap[value]) {
          value = "normal";
        }
        if (value === this.blendMode) {
          return;
        }
        this.blendMode = value;
        const mode = this.blendModesMap[value];
        const gl = this.gl;
        if (mode.length === 2) {
          gl.blendFunc(mode[0], mode[1]);
        } else {
          gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
          this._blendEq = true;
          gl.blendEquationSeparate(mode[4], mode[5]);
        } else if (this._blendEq) {
          this._blendEq = false;
          gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
      }
      /**
       * Sets the polygon offset.
       * @param {number} value - the polygon offset
       * @param {number} scale - the polygon offset scale
       */
      setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
      }
      // used
      /** Resets all the logic and disables the VAOs. */
      reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(this.defaultState);
        this._blendEq = true;
        this.blendMode = "";
        this.setBlendMode("normal");
      }
      /**
       * Checks to see which updates should be checked based on which settings have been activated.
       *
       * For example, if blend is enabled then we should check the blend modes each time the state is changed
       * or if polygon fill is activated then we need to check if the polygon offset changes.
       * The idea is that we only check what we have too.
       * @param func - the checking function to add or remove
       * @param value - should the check function be added or removed.
       */
      _updateCheck(func, value) {
        const index2 = this.checks.indexOf(func);
        if (value && index2 === -1) {
          this.checks.push(func);
        } else if (!value && index2 !== -1) {
          this.checks.splice(index2, 1);
        }
      }
      /**
       * A private little wrapper function that we call to check the blend mode.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
      }
      /**
       * A private little wrapper function that we call to check the polygon offset.
       * @param system - the System to perform the state check on
       * @param state - the state that the blendMode will pulled from
       */
      static _checkPolygonOffset(system, state) {
        system.setPolygonOffset(1, state.polygonOffset);
      }
      /**
       * @ignore
       */
      destroy() {
        this.gl = null;
        this.checks.length = 0;
      }
    };
    _GlStateSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "state"
    };
    GlStateSystem = _GlStateSystem;
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs
var GlTexture;
var init_GlTexture = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTexture.mjs"() {
    init_const9();
    GlTexture = class {
      constructor(texture) {
        this.target = GL_TARGETS.TEXTURE_2D;
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        this.type = GL_TYPES.UNSIGNED_BYTE;
        this.internalFormat = GL_FORMATS.RGBA;
        this.format = GL_FORMATS.RGBA;
        this.samplerType = 0;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs
var glUploadBufferImageResource;
var init_glUploadBufferImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadBufferImageResource.mjs"() {
    "use strict";
    glUploadBufferImageResource = {
      id: "buffer",
      upload(source2, glTexture, gl) {
        if (glTexture.width === source2.width || glTexture.height === source2.height) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            source2.width,
            source2.height,
            glTexture.format,
            glTexture.type,
            source2.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            source2.width,
            source2.height,
            0,
            glTexture.format,
            glTexture.type,
            source2.resource
          );
        }
        glTexture.width = source2.width;
        glTexture.height = source2.height;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs
var compressedFormatMap, glUploadCompressedTextureResource;
var init_glUploadCompressedTextureResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadCompressedTextureResource.mjs"() {
    "use strict";
    compressedFormatMap = {
      "bc1-rgba-unorm": true,
      "bc1-rgba-unorm-srgb": true,
      "bc2-rgba-unorm": true,
      "bc2-rgba-unorm-srgb": true,
      "bc3-rgba-unorm": true,
      "bc3-rgba-unorm-srgb": true,
      "bc4-r-unorm": true,
      "bc4-r-snorm": true,
      "bc5-rg-unorm": true,
      "bc5-rg-snorm": true,
      "bc6h-rgb-ufloat": true,
      "bc6h-rgb-float": true,
      "bc7-rgba-unorm": true,
      "bc7-rgba-unorm-srgb": true,
      // ETC2 compressed formats usable if "texture-compression-etc2" is both
      // supported by the device/user agent and enabled in requestDevice.
      "etc2-rgb8unorm": true,
      "etc2-rgb8unorm-srgb": true,
      "etc2-rgb8a1unorm": true,
      "etc2-rgb8a1unorm-srgb": true,
      "etc2-rgba8unorm": true,
      "etc2-rgba8unorm-srgb": true,
      "eac-r11unorm": true,
      "eac-r11snorm": true,
      "eac-rg11unorm": true,
      "eac-rg11snorm": true,
      // ASTC compressed formats usable if "texture-compression-astc" is both
      // supported by the device/user agent and enabled in requestDevice.
      "astc-4x4-unorm": true,
      "astc-4x4-unorm-srgb": true,
      "astc-5x4-unorm": true,
      "astc-5x4-unorm-srgb": true,
      "astc-5x5-unorm": true,
      "astc-5x5-unorm-srgb": true,
      "astc-6x5-unorm": true,
      "astc-6x5-unorm-srgb": true,
      "astc-6x6-unorm": true,
      "astc-6x6-unorm-srgb": true,
      "astc-8x5-unorm": true,
      "astc-8x5-unorm-srgb": true,
      "astc-8x6-unorm": true,
      "astc-8x6-unorm-srgb": true,
      "astc-8x8-unorm": true,
      "astc-8x8-unorm-srgb": true,
      "astc-10x5-unorm": true,
      "astc-10x5-unorm-srgb": true,
      "astc-10x6-unorm": true,
      "astc-10x6-unorm-srgb": true,
      "astc-10x8-unorm": true,
      "astc-10x8-unorm-srgb": true,
      "astc-10x10-unorm": true,
      "astc-10x10-unorm-srgb": true,
      "astc-12x10-unorm": true,
      "astc-12x10-unorm-srgb": true,
      "astc-12x12-unorm": true,
      "astc-12x12-unorm-srgb": true
    };
    glUploadCompressedTextureResource = {
      id: "compressed",
      upload(source2, glTexture, gl) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
        let mipWidth = source2.pixelWidth;
        let mipHeight = source2.pixelHeight;
        const compressed = !!compressedFormatMap[source2.format];
        for (let i2 = 0; i2 < source2.resource.length; i2++) {
          const levelBuffer = source2.resource[i2];
          if (compressed) {
            gl.compressedTexImage2D(
              gl.TEXTURE_2D,
              i2,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              levelBuffer
            );
          } else {
            gl.texImage2D(
              gl.TEXTURE_2D,
              i2,
              glTexture.internalFormat,
              mipWidth,
              mipHeight,
              0,
              glTexture.format,
              glTexture.type,
              levelBuffer
            );
          }
          mipWidth = Math.max(mipWidth >> 1, 1);
          mipHeight = Math.max(mipHeight >> 1, 1);
        }
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs
var glUploadImageResource;
var init_glUploadImageResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadImageResource.mjs"() {
    "use strict";
    glUploadImageResource = {
      id: "image",
      upload(source2, glTexture, gl, webGLVersion) {
        const premultipliedAlpha = source2.alphaMode === "premultiply-alpha-on-upload";
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha);
        const glWidth = glTexture.width;
        const glHeight = glTexture.height;
        const textureWidth = source2.pixelWidth;
        const textureHeight = source2.pixelHeight;
        const resourceWidth = source2.resourceWidth;
        const resourceHeight = source2.resourceHeight;
        if (resourceWidth < textureWidth || resourceHeight < textureHeight) {
          if (glWidth !== textureWidth || glHeight !== textureHeight) {
            gl.texImage2D(
              glTexture.target,
              0,
              glTexture.internalFormat,
              textureWidth,
              textureHeight,
              0,
              glTexture.format,
              glTexture.type,
              null
            );
          }
          if (webGLVersion === 2) {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              resourceWidth,
              resourceHeight,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          } else {
            gl.texSubImage2D(
              gl.TEXTURE_2D,
              0,
              0,
              0,
              glTexture.format,
              glTexture.type,
              source2.resource
            );
          }
        } else if (glWidth === textureWidth || glHeight === textureHeight) {
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            glTexture.format,
            glTexture.type,
            source2.resource
          );
        } else if (webGLVersion === 2) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            textureWidth,
            textureHeight,
            0,
            glTexture.format,
            glTexture.type,
            source2.resource
          );
        } else {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            glTexture.format,
            glTexture.type,
            source2.resource
          );
        }
        glTexture.width = textureWidth;
        glTexture.height = textureHeight;
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs
var glUploadVideoResource;
var init_glUploadVideoResource = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/uploaders/glUploadVideoResource.mjs"() {
    init_glUploadImageResource();
    glUploadVideoResource = {
      id: "video",
      upload(source2, glTexture, gl, webGLVersion) {
        if (!source2.isValid) {
          gl.texImage2D(
            glTexture.target,
            0,
            glTexture.internalFormat,
            1,
            1,
            0,
            glTexture.format,
            glTexture.type,
            null
          );
          return;
        }
        glUploadImageResource.upload(source2, glTexture, gl, webGLVersion);
      }
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs
var scaleModeToGlFilter, mipmapScaleModeToGlFilter, wrapModeToGlAddress, compareModeToGlCompare;
var init_pixiToGlMaps = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/pixiToGlMaps.mjs"() {
    "use strict";
    scaleModeToGlFilter = {
      linear: 9729,
      nearest: 9728
    };
    mipmapScaleModeToGlFilter = {
      linear: {
        linear: 9987,
        nearest: 9985
      },
      nearest: {
        linear: 9986,
        nearest: 9984
      }
    };
    wrapModeToGlAddress = {
      "clamp-to-edge": 33071,
      repeat: 10497,
      "mirror-repeat": 33648
    };
    compareModeToGlCompare = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs
function applyStyleParams(style, gl, mipmaps, anisotropicExt, glFunctionName, firstParam, forceClamp, firstCreation) {
  const castParam = firstParam;
  if (!firstCreation || style.addressModeU !== "repeat" || style.addressModeV !== "repeat" || style.addressModeW !== "repeat") {
    const wrapModeS = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeU];
    const wrapModeT = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeV];
    const wrapModeR = wrapModeToGlAddress[forceClamp ? "clamp-to-edge" : style.addressModeW];
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_S, wrapModeS);
    gl[glFunctionName](castParam, gl.TEXTURE_WRAP_T, wrapModeT);
    if (gl.TEXTURE_WRAP_R)
      gl[glFunctionName](castParam, gl.TEXTURE_WRAP_R, wrapModeR);
  }
  if (!firstCreation || style.magFilter !== "linear") {
    gl[glFunctionName](castParam, gl.TEXTURE_MAG_FILTER, scaleModeToGlFilter[style.magFilter]);
  }
  if (mipmaps) {
    if (!firstCreation || style.mipmapFilter !== "linear") {
      const glFilterMode = mipmapScaleModeToGlFilter[style.minFilter][style.mipmapFilter];
      gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, glFilterMode);
    }
  } else {
    gl[glFunctionName](castParam, gl.TEXTURE_MIN_FILTER, scaleModeToGlFilter[style.minFilter]);
  }
  if (anisotropicExt && style.maxAnisotropy > 1) {
    const level = Math.min(style.maxAnisotropy, gl.getParameter(anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
    gl[glFunctionName](castParam, anisotropicExt.TEXTURE_MAX_ANISOTROPY_EXT, level);
  }
  if (style.compare) {
    gl[glFunctionName](castParam, gl.TEXTURE_COMPARE_FUNC, compareModeToGlCompare[style.compare]);
  }
}
var init_applyStyleParams = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/applyStyleParams.mjs"() {
    init_pixiToGlMaps();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs
function mapFormatToGlFormat(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.RED,
    r8snorm: gl.RED,
    r8uint: gl.RED,
    r8sint: gl.RED,
    // 16-bit formats
    r16uint: gl.RED,
    r16sint: gl.RED,
    r16float: gl.RED,
    rg8unorm: gl.RG,
    rg8snorm: gl.RG,
    rg8uint: gl.RG,
    rg8sint: gl.RG,
    // 32-bit formats
    r32uint: gl.RED,
    r32sint: gl.RED,
    r32float: gl.RED,
    rg16uint: gl.RG,
    rg16sint: gl.RG,
    rg16float: gl.RG,
    rgba8unorm: gl.RGBA,
    "rgba8unorm-srgb": gl.RGBA,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA,
    rgba8uint: gl.RGBA,
    rgba8sint: gl.RGBA,
    bgra8unorm: gl.RGBA,
    "bgra8unorm-srgb": gl.RGBA,
    rgb9e5ufloat: gl.RGB,
    rgb10a2unorm: gl.RGBA,
    rg11b10ufloat: gl.RGB,
    // 64-bit formats
    rg32uint: gl.RG,
    rg32sint: gl.RG,
    rg32float: gl.RG,
    rgba16uint: gl.RGBA,
    rgba16sint: gl.RGBA,
    rgba16float: gl.RGBA,
    // 128-bit formats
    rgba32uint: gl.RGBA,
    rgba32sint: gl.RGBA,
    rgba32float: gl.RGBA,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT,
    depth24plus: gl.DEPTH_COMPONENT,
    "depth24plus-stencil8": gl.DEPTH_STENCIL,
    depth32float: gl.DEPTH_COMPONENT,
    "depth32float-stencil8": gl.DEPTH_STENCIL
  };
}
var init_mapFormatToGlFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlFormat.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs
function mapFormatToGlInternalFormat(gl, extensions2) {
  let srgb = {};
  let bgra8unorm = gl.RGBA;
  if (!(gl instanceof DOMAdapter.get().getWebGLRenderingContext())) {
    srgb = {
      "rgba8unorm-srgb": gl.SRGB8_ALPHA8,
      "bgra8unorm-srgb": gl.SRGB8_ALPHA8
    };
    bgra8unorm = gl.RGBA8;
  } else if (extensions2.srgb) {
    srgb = {
      "rgba8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT,
      "bgra8unorm-srgb": extensions2.srgb.SRGB8_ALPHA8_EXT
    };
  }
  return {
    // 8-bit formats
    r8unorm: gl.R8,
    r8snorm: gl.R8_SNORM,
    r8uint: gl.R8UI,
    r8sint: gl.R8I,
    // 16-bit formats
    r16uint: gl.R16UI,
    r16sint: gl.R16I,
    r16float: gl.R16F,
    rg8unorm: gl.RG8,
    rg8snorm: gl.RG8_SNORM,
    rg8uint: gl.RG8UI,
    rg8sint: gl.RG8I,
    // 32-bit formats
    r32uint: gl.R32UI,
    r32sint: gl.R32I,
    r32float: gl.R32F,
    rg16uint: gl.RG16UI,
    rg16sint: gl.RG16I,
    rg16float: gl.RG16F,
    rgba8unorm: gl.RGBA,
    ...srgb,
    // Packed 32-bit formats
    rgba8snorm: gl.RGBA8_SNORM,
    rgba8uint: gl.RGBA8UI,
    rgba8sint: gl.RGBA8I,
    bgra8unorm,
    rgb9e5ufloat: gl.RGB9_E5,
    rgb10a2unorm: gl.RGB10_A2,
    rg11b10ufloat: gl.R11F_G11F_B10F,
    // 64-bit formats
    rg32uint: gl.RG32UI,
    rg32sint: gl.RG32I,
    rg32float: gl.RG32F,
    rgba16uint: gl.RGBA16UI,
    rgba16sint: gl.RGBA16I,
    rgba16float: gl.RGBA16F,
    // 128-bit formats
    rgba32uint: gl.RGBA32UI,
    rgba32sint: gl.RGBA32I,
    rgba32float: gl.RGBA32F,
    // Depth/stencil formats
    stencil8: gl.STENCIL_INDEX8,
    depth16unorm: gl.DEPTH_COMPONENT16,
    depth24plus: gl.DEPTH_COMPONENT24,
    "depth24plus-stencil8": gl.DEPTH24_STENCIL8,
    depth32float: gl.DEPTH_COMPONENT32F,
    "depth32float-stencil8": gl.DEPTH32F_STENCIL8,
    // Compressed formats
    ...extensions2.s3tc ? {
      "bc1-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm": extensions2.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.s3tc_sRGB ? {
      "bc1-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
      "bc2-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
      "bc3-rgba-unorm-srgb": extensions2.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    } : {},
    ...extensions2.rgtc ? {
      "bc4-r-unorm": extensions2.rgtc.COMPRESSED_RED_RGTC1_EXT,
      "bc4-r-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
      "bc5-rg-unorm": extensions2.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
      "bc5-rg-snorm": extensions2.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
    } : {},
    ...extensions2.bptc ? {
      "bc6h-rgb-float": extensions2.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
      "bc6h-rgb-ufloat": extensions2.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
      "bc7-rgba-unorm": extensions2.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
      "bc7-rgba-unorm-srgb": extensions2.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
    } : {},
    ...extensions2.etc ? {
      "etc2-rgb8unorm": extensions2.etc.COMPRESSED_RGB8_ETC2,
      "etc2-rgb8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ETC2,
      "etc2-rgb8a1unorm": extensions2.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgb8a1unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
      "etc2-rgba8unorm": extensions2.etc.COMPRESSED_RGBA8_ETC2_EAC,
      "etc2-rgba8unorm-srgb": extensions2.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
      "eac-r11unorm": extensions2.etc.COMPRESSED_R11_EAC,
      // 'eac-r11snorm'
      "eac-rg11unorm": extensions2.etc.COMPRESSED_SIGNED_RG11_EAC
      // 'eac-rg11snorm'
    } : {},
    ...extensions2.astc ? {
      "astc-4x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
      "astc-4x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
      "astc-5x4-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
      "astc-5x4-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
      "astc-5x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
      "astc-5x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
      "astc-6x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
      "astc-6x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
      "astc-6x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
      "astc-6x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
      "astc-8x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
      "astc-8x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
      "astc-8x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
      "astc-8x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
      "astc-8x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
      "astc-8x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
      "astc-10x5-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
      "astc-10x5-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
      "astc-10x6-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
      "astc-10x6-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
      "astc-10x8-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
      "astc-10x8-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
      "astc-10x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
      "astc-10x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
      "astc-12x10-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
      "astc-12x10-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
      "astc-12x12-unorm": extensions2.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
      "astc-12x12-unorm-srgb": extensions2.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    } : {}
  };
}
var init_mapFormatToGlInternalFormat = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlInternalFormat.mjs"() {
    init_adapter();
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs
function mapFormatToGlType(gl) {
  return {
    // 8-bit formats
    r8unorm: gl.UNSIGNED_BYTE,
    r8snorm: gl.BYTE,
    r8uint: gl.UNSIGNED_BYTE,
    r8sint: gl.BYTE,
    // 16-bit formats
    r16uint: gl.UNSIGNED_SHORT,
    r16sint: gl.SHORT,
    r16float: gl.HALF_FLOAT,
    rg8unorm: gl.UNSIGNED_BYTE,
    rg8snorm: gl.BYTE,
    rg8uint: gl.UNSIGNED_BYTE,
    rg8sint: gl.BYTE,
    // 32-bit formats
    r32uint: gl.UNSIGNED_INT,
    r32sint: gl.INT,
    r32float: gl.FLOAT,
    rg16uint: gl.UNSIGNED_SHORT,
    rg16sint: gl.SHORT,
    rg16float: gl.HALF_FLOAT,
    rgba8unorm: gl.UNSIGNED_BYTE,
    "rgba8unorm-srgb": gl.UNSIGNED_BYTE,
    // Packed 32-bit formats
    rgba8snorm: gl.BYTE,
    rgba8uint: gl.UNSIGNED_BYTE,
    rgba8sint: gl.BYTE,
    bgra8unorm: gl.UNSIGNED_BYTE,
    "bgra8unorm-srgb": gl.UNSIGNED_BYTE,
    rgb9e5ufloat: gl.UNSIGNED_INT_5_9_9_9_REV,
    rgb10a2unorm: gl.UNSIGNED_INT_2_10_10_10_REV,
    rg11b10ufloat: gl.UNSIGNED_INT_10F_11F_11F_REV,
    // 64-bit formats
    rg32uint: gl.UNSIGNED_INT,
    rg32sint: gl.INT,
    rg32float: gl.FLOAT,
    rgba16uint: gl.UNSIGNED_SHORT,
    rgba16sint: gl.SHORT,
    rgba16float: gl.HALF_FLOAT,
    // 128-bit formats
    rgba32uint: gl.UNSIGNED_INT,
    rgba32sint: gl.INT,
    rgba32float: gl.FLOAT,
    // Depth/stencil formats
    stencil8: gl.UNSIGNED_BYTE,
    depth16unorm: gl.UNSIGNED_SHORT,
    depth24plus: gl.UNSIGNED_INT,
    "depth24plus-stencil8": gl.UNSIGNED_INT_24_8,
    depth32float: gl.FLOAT,
    "depth32float-stencil8": gl.FLOAT_32_UNSIGNED_INT_24_8_REV
  };
}
var init_mapFormatToGlType = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/utils/mapFormatToGlType.mjs"() {
    "use strict";
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs
var BYTES_PER_PIXEL, GlTextureSystem;
var init_GlTextureSystem = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/texture/GlTextureSystem.mjs"() {
    init_adapter();
    init_Extensions();
    init_Texture();
    init_GlTexture();
    init_glUploadBufferImageResource();
    init_glUploadCompressedTextureResource();
    init_glUploadImageResource();
    init_glUploadVideoResource();
    init_applyStyleParams();
    init_mapFormatToGlFormat();
    init_mapFormatToGlInternalFormat();
    init_mapFormatToGlType();
    BYTES_PER_PIXEL = 4;
    GlTextureSystem = class {
      constructor(renderer) {
        this.managedTextures = [];
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundTextures = [];
        this._activeTextureLocation = -1;
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        this._uploads = {
          image: glUploadImageResource,
          buffer: glUploadBufferImageResource,
          video: glUploadVideoResource,
          compressed: glUploadCompressedTextureResource
        };
        this._useSeparateSamplers = false;
        this._renderer = renderer;
      }
      contextChange(gl) {
        this._gl = gl;
        if (!this._mapFormatToInternalFormat) {
          this._mapFormatToInternalFormat = mapFormatToGlInternalFormat(gl, this._renderer.context.extensions);
          this._mapFormatToType = mapFormatToGlType(gl);
          this._mapFormatToFormat = mapFormatToGlFormat(gl);
        }
        this._glTextures = /* @__PURE__ */ Object.create(null);
        this._glSamplers = /* @__PURE__ */ Object.create(null);
        this._boundSamplers = /* @__PURE__ */ Object.create(null);
        for (let i2 = 0; i2 < 16; i2++) {
          this.bind(Texture.EMPTY, i2);
        }
      }
      initSource(source2) {
        this.bind(source2);
      }
      bind(texture, location = 0) {
        const source2 = texture.source;
        if (texture) {
          this.bindSource(source2, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(source2.style, location);
          }
        } else {
          this.bindSource(null, location);
          if (this._useSeparateSamplers) {
            this._bindSampler(null, location);
          }
        }
      }
      bindSource(source2, location = 0) {
        const gl = this._gl;
        source2._touched = this._renderer.textureGC.count;
        if (this._boundTextures[location] !== source2) {
          this._boundTextures[location] = source2;
          this._activateLocation(location);
          source2 = source2 || Texture.EMPTY.source;
          const glTexture = this.getGlSource(source2);
          gl.bindTexture(glTexture.target, glTexture.texture);
        }
      }
      _bindSampler(style, location = 0) {
        const gl = this._gl;
        if (!style) {
          this._boundSamplers[location] = null;
          gl.bindSampler(location, null);
          return;
        }
        const sampler = this._getGlSampler(style);
        if (this._boundSamplers[location] !== sampler) {
          this._boundSamplers[location] = sampler;
          gl.bindSampler(location, sampler);
        }
      }
      unbind(texture) {
        const source2 = texture.source;
        const boundTextures = this._boundTextures;
        const gl = this._gl;
        for (let i2 = 0; i2 < boundTextures.length; i2++) {
          if (boundTextures[i2] === source2) {
            this._activateLocation(i2);
            const glTexture = this.getGlSource(source2);
            gl.bindTexture(glTexture.target, null);
            boundTextures[i2] = null;
          }
        }
      }
      _activateLocation(location) {
        if (this._activeTextureLocation !== location) {
          this._activeTextureLocation = location;
          this._gl.activeTexture(this._gl.TEXTURE0 + location);
        }
      }
      _initSource(source2) {
        const gl = this._gl;
        const glTexture = new GlTexture(gl.createTexture());
        glTexture.type = this._mapFormatToType[source2.format];
        glTexture.internalFormat = this._mapFormatToInternalFormat[source2.format];
        glTexture.format = this._mapFormatToFormat[source2.format];
        if (source2.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source2.isPowerOfTwo)) {
          const biggestDimension = Math.max(source2.width, source2.height);
          source2.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;
        }
        this._glTextures[source2.uid] = glTexture;
        if (!this.managedTextures.includes(source2)) {
          source2.on("update", this.onSourceUpdate, this);
          source2.on("resize", this.onSourceUpdate, this);
          source2.on("styleChange", this.onStyleChange, this);
          source2.on("destroy", this.onSourceDestroy, this);
          source2.on("unload", this.onSourceUnload, this);
          source2.on("updateMipmaps", this.onUpdateMipmaps, this);
          this.managedTextures.push(source2);
        }
        this.onSourceUpdate(source2);
        this.updateStyle(source2, false);
        return glTexture;
      }
      onStyleChange(source2) {
        this.updateStyle(source2, false);
      }
      updateStyle(source2, firstCreation) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source2);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source2;
        applyStyleParams(
          source2.style,
          gl,
          source2.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          gl.TEXTURE_2D,
          // will force a clamp to edge if the texture is not a power of two
          !this._renderer.context.supports.nonPowOf2wrapping && !source2.isPowerOfTwo,
          firstCreation
        );
      }
      onSourceUnload(source2) {
        const glTexture = this._glTextures[source2.uid];
        if (!glTexture)
          return;
        this.unbind(source2);
        this._glTextures[source2.uid] = null;
        this._gl.deleteTexture(glTexture.texture);
      }
      onSourceUpdate(source2) {
        const gl = this._gl;
        const glTexture = this.getGlSource(source2);
        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
        this._boundTextures[this._activeTextureLocation] = source2;
        if (this._uploads[source2.uploadMethodId]) {
          this._uploads[source2.uploadMethodId].upload(source2, glTexture, gl, this._renderer.context.webGLVersion);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source2.pixelWidth, source2.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        if (source2.autoGenerateMipmaps && source2.mipLevelCount > 1) {
          this.onUpdateMipmaps(source2, false);
        }
      }
      onUpdateMipmaps(source2, bind = true) {
        if (bind)
          this.bindSource(source2, 0);
        const glTexture = this.getGlSource(source2);
        this._gl.generateMipmap(glTexture.target);
      }
      onSourceDestroy(source2) {
        source2.off("destroy", this.onSourceDestroy, this);
        source2.off("update", this.onSourceUpdate, this);
        source2.off("resize", this.onSourceUpdate, this);
        source2.off("unload", this.onSourceUnload, this);
        source2.off("styleChange", this.onStyleChange, this);
        source2.off("updateMipmaps", this.onUpdateMipmaps, this);
        this.managedTextures.splice(this.managedTextures.indexOf(source2), 1);
        this.onSourceUnload(source2);
      }
      _initSampler(style) {
        const gl = this._gl;
        const glSampler = this._gl.createSampler();
        this._glSamplers[style._resourceId] = glSampler;
        applyStyleParams(
          style,
          gl,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          glSampler,
          false,
          true
        );
        return this._glSamplers[style._resourceId];
      }
      _getGlSampler(sampler) {
        return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
      }
      getGlSource(source2) {
        return this._glTextures[source2.uid] || this._initSource(source2);
      }
      generateCanvas(texture) {
        const { pixels, width, height } = this.getPixels(texture);
        const canvas = DOMAdapter.get().createCanvas();
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (ctx) {
          const imageData = ctx.createImageData(width, height);
          imageData.data.set(pixels);
          ctx.putImageData(imageData, 0, 0);
        }
        return canvas;
      }
      getPixels(texture) {
        const resolution = texture.source.resolution;
        const frame2 = texture.frame;
        const width = Math.max(Math.round(frame2.width * resolution), 1);
        const height = Math.max(Math.round(frame2.height * resolution), 1);
        const pixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
        const renderer = this._renderer;
        const renderTarget = renderer.renderTarget.getRenderTarget(texture);
        const glRenterTarget = renderer.renderTarget.getGpuRenderTarget(renderTarget);
        const gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenterTarget.resolveTargetFramebuffer);
        gl.readPixels(
          Math.round(frame2.x * resolution),
          Math.round(frame2.y * resolution),
          width,
          height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels
        );
        if (false) {
          unpremultiplyAlpha(pixels);
        }
        return { pixels: new Uint8ClampedArray(pixels.buffer), width, height };
      }
      destroy() {
        this.managedTextures.slice().forEach((source2) => this.onSourceDestroy(source2));
        this.managedTextures = null;
        this._renderer = null;
      }
    };
    GlTextureSystem.extension = {
      type: [
        ExtensionType.WebGLSystem
      ],
      name: "texture"
    };
  }
});

// node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs
var WebGLRenderer_exports = {};
__export(WebGLRenderer_exports, {
  WebGLRenderer: () => WebGLRenderer
});
var DefaultWebGLSystems, DefaultWebGLPipes, DefaultWebGLAdapters, systems2, renderPipes2, renderPipeAdaptors2, WebGLRenderer;
var init_WebGLRenderer = __esm({
  "node_modules/pixi.js/lib/rendering/renderers/gl/WebGLRenderer.mjs"() {
    init_Extensions();
    init_GlGraphicsAdaptor();
    init_GlMeshAdaptor();
    init_GlBatchAdaptor();
    init_AbstractRenderer();
    init_SharedSystems();
    init_types2();
    init_GlBufferSystem();
    init_GlContextSystem();
    init_GlGeometrySystem();
    init_GlBackBufferSystem();
    init_GlColorMaskSystem();
    init_GlEncoderSystem();
    init_GlStencilSystem();
    init_GlUboSystem();
    init_GlRenderTargetSystem();
    init_GlShaderSystem();
    init_GlUniformGroupSystem();
    init_GlStateSystem();
    init_GlTextureSystem();
    DefaultWebGLSystems = [
      ...SharedSystems,
      GlUboSystem,
      GlBackBufferSystem,
      GlContextSystem,
      GlBufferSystem,
      GlTextureSystem,
      GlRenderTargetSystem,
      GlGeometrySystem,
      GlUniformGroupSystem,
      GlShaderSystem,
      GlEncoderSystem,
      GlStateSystem,
      GlStencilSystem,
      GlColorMaskSystem
    ];
    DefaultWebGLPipes = [...SharedRenderPipes];
    DefaultWebGLAdapters = [GlBatchAdaptor, GlMeshAdaptor, GlGraphicsAdaptor];
    systems2 = [];
    renderPipes2 = [];
    renderPipeAdaptors2 = [];
    extensions.handleByNamedList(ExtensionType.WebGLSystem, systems2);
    extensions.handleByNamedList(ExtensionType.WebGLPipes, renderPipes2);
    extensions.handleByNamedList(ExtensionType.WebGLPipesAdaptor, renderPipeAdaptors2);
    extensions.add(...DefaultWebGLSystems, ...DefaultWebGLPipes, ...DefaultWebGLAdapters);
    WebGLRenderer = class extends AbstractRenderer {
      constructor() {
        const systemConfig = {
          name: "webgl",
          type: RendererType.WEBGL,
          systems: systems2,
          renderPipes: renderPipes2,
          renderPipeAdaptors: renderPipeAdaptors2
        };
        super(systemConfig);
      }
    };
  }
});

// node_modules/pixi.js/lib/environment-browser/browserExt.mjs
init_Extensions();
var browserExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await Promise.resolve().then(() => (init_browserAll(), browserAll_exports));
  }
};

// node_modules/pixi.js/lib/environment-webworker/webworkerExt.mjs
init_Extensions();
var webworkerExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await Promise.resolve().then(() => (init_webworkerAll(), webworkerAll_exports));
  }
};

// node_modules/pixi.js/lib/index.mjs
init_Extensions();
init_init5();
init_init4();

// node_modules/pixi.js/lib/app/Application.mjs
init_Extensions();

// node_modules/pixi.js/lib/utils/browser/isWebGLSupported.mjs
init_adapter();
init_AbstractRenderer();
var _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!gl?.getContextAttributes()?.stencil;
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (e3) {
      return false;
    }
  })();
  return _isWebGLSupported;
}

// node_modules/pixi.js/lib/utils/browser/isWebGPUSupported.mjs
init_adapter();
var _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (e3) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}

// node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs
init_AbstractRenderer();
var renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i2 = 0; i2 < preferredOrder.length; i2++) {
    const rendererType = preferredOrder[i2];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer: WebGPURenderer2 } = await Promise.resolve().then(() => (init_WebGPURenderer(), WebGPURenderer_exports));
      RendererClass = WebGPURenderer2;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: WebGLRenderer2 } = await Promise.resolve().then(() => (init_WebGLRenderer(), WebGLRenderer_exports));
      RendererClass = WebGLRenderer2;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}

// node_modules/pixi.js/lib/app/Application.mjs
init_Container();
init_globalHooks();
init_deprecation();
var _Application = class _Application2 {
  /** @ignore */
  constructor(...args) {
    this.stage = new Container();
    if (args[0] !== void 0) {
      deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  /**
   * @param options - The optional application and renderer parameters.
   */
  async init(options) {
    options = { ...options };
    this.renderer = await autoDetectRenderer(options);
    _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /** Render the current stage. */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element.
   * @readonly
   * @member {HTMLCanvasElement}
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @member {HTMLCanvasElement}
   * @deprecated since 8.0.0
   */
  get view() {
    deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
   * @readonly
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.
   * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.
   * @param {object|boolean} [options=false] - The options for destroying the stage.
   * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method
   * called as well. `options` will be passed on to those calls.
   * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.
   * If options.children is set to true,
   * it should destroy the texture of the child sprite.
   * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.
   *  If options.children is set to true,
   * it should destroy the texture source of the child sprite.
   * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.
   * If options.children is set to true,
   * it should destroy the context of the child graphics.
   */
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
_Application._plugins = [];
var Application = _Application;
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ApplicationInitHook);

// node_modules/pixi.js/lib/scene/text/AbstractText.mjs
init_ObservablePoint();
init_deprecation();
init_View();
var AbstractText = class extends ViewContainer {
  constructor(options, styleClass) {
    const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;
    super({
      ...rest
    });
    this.batched = true;
    this._resolution = null;
    this._autoResolution = true;
    this._didTextUpdate = true;
    this._styleClass = styleClass;
    this.text = text ?? "";
    this.style = style;
    this.resolution = resolution ?? null;
    this.allowChildren = false;
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor)
      this.anchor = anchor;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * The anchor sets the origin point of the text.
   * The default is `(0,0)`, this means the text's origin is the top left.
   *
   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
   *
   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * import { Text } from 'pixi.js';
   *
   * const text = new Text('hello world');
   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    typeof value === "number" ? this._anchor.set(value) : this._anchor.copyFrom(value);
  }
  /** Set the copy for the text object. To split a line you can use '\n'. */
  set text(value) {
    value = value.toString();
    if (this._text === value)
      return;
    this._text = value;
    this.onViewUpdate();
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution / device pixel ratio of the canvas.
   * @default 1
   */
  set resolution(value) {
    this._autoResolution = value === null;
    this._resolution = value;
    this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * Set the style of the text.
   *
   * Set up an event listener to listen for changes on the style object and mark the text as dirty.
   *
   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.
   * @type {
   * text.TextStyle |
   * Partial<text.TextStyle> |
   * text.TextStyleOptions |
   * text.HTMLTextStyle |
   * Partial<text.HTMLTextStyle> |
   * text.HTMLTextStyleOptions
   * }
   */
  set style(style) {
    style = style || {};
    this._style?.off("update", this.onViewUpdate, this);
    if (style instanceof this._styleClass) {
      this._style = style;
    } else {
      this._style = new this._styleClass(style);
    }
    this._style.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  /**
   * The local bounds of the Text.
   * @type {rendering.Bounds}
   */
  get bounds() {
    if (this._boundsDirty) {
      this._updateBounds();
      this._boundsDirty = false;
    }
    return this._bounds;
  }
  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(value) {
    this._setWidth(value, this.bounds.width);
  }
  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(value) {
    this._setHeight(value, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object.
   * This is faster than get the width and height separately.
   * @param out - Optional object to store the size in.
   * @returns - The size of the Text.
   */
  getSize(out2) {
    out2 || (out2 = {});
    out2.width = Math.abs(this.scale.x) * this.bounds.width;
    out2.height = Math.abs(this.scale.y) * this.bounds.height;
    return out2;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting the width and height separately.
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value, height) {
    if (typeof value === "object") {
      height = value.height ?? value.width;
      value = value.width;
    } else {
      height ?? (height = value);
    }
    value !== void 0 && this._setWidth(value, this.bounds.width);
    height !== void 0 && this._setHeight(height, this.bounds.height);
  }
  /**
   * Adds the bounds of this text to the bounds object.
   * @param bounds - The output bounds object.
   */
  addBounds(bounds) {
    const _bounds = this.bounds;
    bounds.addFrame(
      _bounds.minX,
      _bounds.minY,
      _bounds.maxX,
      _bounds.maxY
    );
  }
  /**
   * Checks if the text contains the given point.
   * @param point - The point to check
   */
  containsPoint(point) {
    const width = this.bounds.width;
    const height = this.bounds.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  onViewUpdate() {
    this._didViewChangeTick++;
    this._boundsDirty = true;
    if (this.didViewUpdate)
      return;
    this.didViewUpdate = true;
    this._didTextUpdate = true;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.onChildViewUpdate(this);
    }
  }
  _getKey() {
    return `${this.text}:${this._style.styleKey}:${this._resolution}`;
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style
   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style
   * @param {boolean} [options.style=false] - Should it destroy the style of the text
   */
  destroy(options = false) {
    super.destroy(options);
    this.owner = null;
    this._bounds = null;
    this._anchor = null;
    if (typeof options === "boolean" ? options : options?.style) {
      this._style.destroy(options);
    }
    this._style = null;
    this._text = null;
  }
};
function ensureOptions(args, name) {
  let options = args[0] ?? {};
  if (typeof options === "string" || args[1]) {
    deprecation(v8_0_0, `use new ${name}({ text: "hi!", style }) instead`);
    options = {
      text: options,
      style: args[1]
    };
  }
  return options;
}

// node_modules/pixi.js/lib/scene/text/Text.mjs
init_CanvasTextMetrics();
init_TextStyle();
var Text = class extends AbstractText {
  constructor(...args) {
    const options = ensureOptions(args, "Text");
    super(options, TextStyle);
    this.renderPipeId = "text";
  }
  _updateBounds() {
    const bounds = this._bounds;
    const anchor = this._anchor;
    const canvasMeasurement = CanvasTextMetrics.measureText(
      this._text,
      this._style
    );
    const { width, height } = canvasMeasurement;
    bounds.minX = -anchor._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor._y * height;
    bounds.maxY = bounds.minY + height;
  }
};

// node_modules/pixi.js/lib/index.mjs
init_Point();
init_Polygon();
init_Rectangle();
init_textureFrom();
init_Container();
init_Graphics();
init_Ticker();
init_eventemitter3();
var import_earcut2 = __toESM(require_earcut(), 1);
extensions.add(browserExt, webworkerExt);

// node_modules/pixi-viewport/dist/pixi_viewport.js
var u2 = class {
  /** @param {Viewport} parent */
  constructor(t2) {
    this.parent = t2, this.paused = false;
  }
  /** Called when plugin is removed */
  destroy() {
  }
  /** Handler for pointerdown PIXI event */
  down(t2) {
    return false;
  }
  /** Handler for pointermove PIXI event */
  move(t2) {
    return false;
  }
  /** Handler for pointerup PIXI event */
  up(t2) {
    return false;
  }
  /** Handler for wheel event on div */
  wheel(t2) {
    return false;
  }
  /**
   * Called on each tick
   * @param {number} elapsed time in millisecond since last update
   */
  update(t2) {
  }
  /** Called when the viewport is resized */
  resize() {
  }
  /** Called when the viewport is manually moved */
  reset() {
  }
  /** Pause the plugin */
  pause() {
    this.paused = true;
  }
  /** Un-pause the plugin */
  resume() {
    this.paused = false;
  }
};
var S2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function M2(l2) {
  return l2 && l2.__esModule && Object.prototype.hasOwnProperty.call(l2, "default") ? l2.default : l2;
}
var W = { exports: {} };
(function(l2, t2) {
  (function() {
    var e3, n2;
    n2 = function(i2) {
      return l2.exports = i2;
    }, e3 = {
      linear: function(i2, s2, h2, o2) {
        return h2 * i2 / o2 + s2;
      },
      easeInQuad: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 + s2;
      },
      easeOutQuad: function(i2, s2, h2, o2) {
        return -h2 * (i2 /= o2) * (i2 - 2) + s2;
      },
      easeInOutQuad: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 + s2 : -h2 / 2 * (--i2 * (i2 - 2) - 1) + s2;
      },
      easeInCubic: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 + s2;
      },
      easeOutCubic: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 + 1) + s2;
      },
      easeInOutCubic: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 + 2) + s2;
      },
      easeInQuart: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 + s2;
      },
      easeOutQuart: function(i2, s2, h2, o2) {
        return -h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 - 1) + s2;
      },
      easeInOutQuart: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 + s2 : -h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 - 2) + s2;
      },
      easeInQuint: function(i2, s2, h2, o2) {
        return h2 * (i2 /= o2) * i2 * i2 * i2 * i2 + s2;
      },
      easeOutQuint: function(i2, s2, h2, o2) {
        return h2 * ((i2 = i2 / o2 - 1) * i2 * i2 * i2 * i2 + 1) + s2;
      },
      easeInOutQuint: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * i2 * i2 * i2 * i2 * i2 + s2 : h2 / 2 * ((i2 -= 2) * i2 * i2 * i2 * i2 + 2) + s2;
      },
      easeInSine: function(i2, s2, h2, o2) {
        return -h2 * Math.cos(i2 / o2 * (Math.PI / 2)) + h2 + s2;
      },
      easeOutSine: function(i2, s2, h2, o2) {
        return h2 * Math.sin(i2 / o2 * (Math.PI / 2)) + s2;
      },
      easeInOutSine: function(i2, s2, h2, o2) {
        return -h2 / 2 * (Math.cos(Math.PI * i2 / o2) - 1) + s2;
      },
      easeInExpo: function(i2, s2, h2, o2) {
        return i2 === 0 ? s2 : h2 * Math.pow(2, 10 * (i2 / o2 - 1)) + s2;
      },
      easeOutExpo: function(i2, s2, h2, o2) {
        return i2 === o2 ? s2 + h2 : h2 * (-Math.pow(2, -10 * i2 / o2) + 1) + s2;
      },
      easeInOutExpo: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? h2 / 2 * Math.pow(2, 10 * (i2 - 1)) + s2 : h2 / 2 * (-Math.pow(2, -10 * --i2) + 2) + s2;
      },
      easeInCirc: function(i2, s2, h2, o2) {
        return -h2 * (Math.sqrt(1 - (i2 /= o2) * i2) - 1) + s2;
      },
      easeOutCirc: function(i2, s2, h2, o2) {
        return h2 * Math.sqrt(1 - (i2 = i2 / o2 - 1) * i2) + s2;
      },
      easeInOutCirc: function(i2, s2, h2, o2) {
        return (i2 /= o2 / 2) < 1 ? -h2 / 2 * (Math.sqrt(1 - i2 * i2) - 1) + s2 : h2 / 2 * (Math.sqrt(1 - (i2 -= 2) * i2) + 1) + s2;
      },
      easeInElastic: function(i2, s2, h2, o2) {
        var r2, a3, p2;
        return p2 = 1.70158, a3 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a3 || (a3 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a3 / 4) : p2 = a3 / (2 * Math.PI) * Math.asin(h2 / r2), -(r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a3)) + s2;
      },
      easeOutElastic: function(i2, s2, h2, o2) {
        var r2, a3, p2;
        return p2 = 1.70158, a3 = 0, r2 = h2, i2 === 0 || (i2 /= o2), a3 || (a3 = o2 * 0.3), r2 < Math.abs(h2) ? (r2 = h2, p2 = a3 / 4) : p2 = a3 / (2 * Math.PI) * Math.asin(h2 / r2), r2 * Math.pow(2, -10 * i2) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a3) + h2 + s2;
      },
      easeInOutElastic: function(i2, s2, h2, o2) {
        var r2, a3, p2;
        return p2 = 1.70158, a3 = 0, r2 = h2, i2 === 0 || (i2 /= o2 / 2), a3 || (a3 = o2 * (0.3 * 1.5)), r2 < Math.abs(h2) ? (r2 = h2, p2 = a3 / 4) : p2 = a3 / (2 * Math.PI) * Math.asin(h2 / r2), i2 < 1 ? -0.5 * (r2 * Math.pow(2, 10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a3)) + s2 : r2 * Math.pow(2, -10 * (i2 -= 1)) * Math.sin((i2 * o2 - p2) * (2 * Math.PI) / a3) * 0.5 + h2 + s2;
      },
      easeInBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * (i2 /= o2) * i2 * ((r2 + 1) * i2 - r2) + s2;
      },
      easeOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), h2 * ((i2 = i2 / o2 - 1) * i2 * ((r2 + 1) * i2 + r2) + 1) + s2;
      },
      easeInOutBack: function(i2, s2, h2, o2, r2) {
        return r2 === void 0 && (r2 = 1.70158), (i2 /= o2 / 2) < 1 ? h2 / 2 * (i2 * i2 * (((r2 *= 1.525) + 1) * i2 - r2)) + s2 : h2 / 2 * ((i2 -= 2) * i2 * (((r2 *= 1.525) + 1) * i2 + r2) + 2) + s2;
      },
      easeInBounce: function(i2, s2, h2, o2) {
        var r2;
        return r2 = e3.easeOutBounce(o2 - i2, 0, h2, o2), h2 - r2 + s2;
      },
      easeOutBounce: function(i2, s2, h2, o2) {
        return (i2 /= o2) < 1 / 2.75 ? h2 * (7.5625 * i2 * i2) + s2 : i2 < 2 / 2.75 ? h2 * (7.5625 * (i2 -= 1.5 / 2.75) * i2 + 0.75) + s2 : i2 < 2.5 / 2.75 ? h2 * (7.5625 * (i2 -= 2.25 / 2.75) * i2 + 0.9375) + s2 : h2 * (7.5625 * (i2 -= 2.625 / 2.75) * i2 + 0.984375) + s2;
      },
      easeInOutBounce: function(i2, s2, h2, o2) {
        var r2;
        return i2 < o2 / 2 ? (r2 = e3.easeInBounce(i2 * 2, 0, h2, o2), r2 * 0.5 + s2) : (r2 = e3.easeOutBounce(i2 * 2 - o2, 0, h2, o2), r2 * 0.5 + h2 * 0.5 + s2);
      }
    }, n2(e3);
  }).call(S2);
})(W);
var O = W.exports;
var v2 = /* @__PURE__ */ M2(O);
function x2(l2, t2) {
  if (l2) {
    if (typeof l2 == "function")
      return l2;
    if (typeof l2 == "string")
      return v2[l2];
  } else
    return v2[t2];
}
var P = {
  removeOnInterrupt: false,
  ease: "linear",
  time: 1e3
};
var C = class extends u2 {
  /**
   * This is called by {@link Viewport.animate}.
   *
   * @param parent
   * @param options
   */
  constructor(t2, e3 = {}) {
    super(t2), this.startWidth = null, this.startHeight = null, this.deltaWidth = null, this.deltaHeight = null, this.width = null, this.height = null, this.time = 0, this.options = Object.assign({}, P, e3), this.options.ease = x2(this.options.ease), this.setupPosition(), this.setupZoom(), this.time = 0;
  }
  /**
   * Setup `startX`, `startY`, `deltaX`, `deltaY`, `keepCenter`.
   *
   * This is called during construction.
   */
  setupPosition() {
    typeof this.options.position < "u" ? (this.startX = this.parent.center.x, this.startY = this.parent.center.y, this.deltaX = this.options.position.x - this.parent.center.x, this.deltaY = this.options.position.y - this.parent.center.y, this.keepCenter = false) : this.keepCenter = true;
  }
  /**
   * Setup `startWidth, `startHeight`, `deltaWidth, `deltaHeight, `width`, `height`.
   *
   * This is called during construction.
   */
  setupZoom() {
    this.width = null, this.height = null, typeof this.options.scale < "u" ? this.width = this.parent.screenWidth / this.options.scale : typeof this.options.scaleX < "u" || typeof this.options.scaleY < "u" ? (typeof this.options.scaleX < "u" && (this.width = this.parent.screenWidth / this.options.scaleX), typeof this.options.scaleY < "u" && (this.height = this.parent.screenHeight / this.options.scaleY)) : (typeof this.options.width < "u" && (this.width = this.options.width), typeof this.options.height < "u" && (this.height = this.options.height)), this.width !== null && (this.startWidth = this.parent.screenWidthInWorldPixels, this.deltaWidth = this.width - this.startWidth), this.height !== null && (this.startHeight = this.parent.screenHeightInWorldPixels, this.deltaHeight = this.height - this.startHeight);
  }
  down() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("animate"), false;
  }
  complete() {
    this.parent.plugins.remove("animate"), this.width !== null && this.parent.fitWidth(this.width, this.keepCenter, this.height === null), this.height !== null && this.parent.fitHeight(this.height, this.keepCenter, this.width === null), !this.keepCenter && this.options.position && this.parent.moveCenter(this.options.position), this.parent.emit("animate-end", this.parent), this.options.callbackOnComplete && this.options.callbackOnComplete(this.parent);
  }
  update(t2) {
    if (this.paused)
      return;
    this.time += t2;
    const e3 = new Point(this.parent.scale.x, this.parent.scale.y);
    if (this.time >= this.options.time) {
      const n2 = this.parent.width, i2 = this.parent.height;
      this.complete(), (n2 !== this.parent.width || i2 !== this.parent.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e3, type: "animate" });
    } else {
      const n2 = this.options.ease(this.time, 0, 1, this.options.time);
      if (this.width !== null) {
        const i2 = this.startWidth, s2 = this.deltaWidth;
        this.parent.fitWidth(
          i2 + s2 * n2,
          this.keepCenter,
          this.height === null
        );
      }
      if (this.height !== null) {
        const i2 = this.startHeight, s2 = this.deltaHeight;
        this.parent.fitHeight(
          i2 + s2 * n2,
          this.keepCenter,
          this.width === null
        );
      }
      if (this.width === null ? this.parent.scale.x = this.parent.scale.y : this.height === null && (this.parent.scale.y = this.parent.scale.x), !this.keepCenter) {
        const i2 = this.startX, s2 = this.startY, h2 = this.deltaX, o2 = this.deltaY, r2 = new Point(this.parent.x, this.parent.y);
        this.parent.moveCenter(i2 + h2 * n2, s2 + o2 * n2), this.parent.emit("moved", { viewport: this.parent, original: r2, type: "animate" });
      }
      (this.width || this.height) && this.parent.emit("zoomed", { viewport: this.parent, original: e3, type: "animate" });
    }
  }
};
var I = {
  sides: "all",
  friction: 0.5,
  time: 150,
  ease: "easeInOutSine",
  underflow: "center",
  bounceBox: null
};
var k2 = class extends u2 {
  /**
   * This is called by {@link Viewport.bounce}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, I, e3), this.ease = x2(this.options.ease, "easeInOutSine"), this.options.sides ? this.options.sides === "all" ? this.top = this.bottom = this.left = this.right = true : this.options.sides === "horizontal" ? (this.right = this.left = true, this.top = this.bottom = false) : this.options.sides === "vertical" ? (this.left = this.right = false, this.top = this.bottom = true) : (this.top = this.options.sides.indexOf("top") !== -1, this.bottom = this.options.sides.indexOf("bottom") !== -1, this.left = this.options.sides.indexOf("left") !== -1, this.right = this.options.sides.indexOf("right") !== -1) : this.left = this.top = this.right = this.bottom = false;
    const n2 = this.options.underflow.toLowerCase();
    n2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (this.underflowX = n2.indexOf("left") !== -1 ? -1 : n2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = n2.indexOf("top") !== -1 ? -1 : n2.indexOf("bottom") !== -1 ? 1 : 0), this.reset();
  }
  isActive() {
    return this.toX !== null || this.toY !== null;
  }
  down() {
    return this.toX = this.toY = null, false;
  }
  up() {
    return this.bounce(), false;
  }
  update(t2) {
    if (!this.paused) {
      if (this.bounce(), this.toX) {
        const e3 = this.toX;
        e3.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-x" }), e3.time >= this.options.time ? (this.parent.x = e3.end, this.toX = null, this.parent.emit("bounce-x-end", this.parent)) : this.parent.x = this.ease(e3.time, e3.start, e3.delta, this.options.time);
      }
      if (this.toY) {
        const e3 = this.toY;
        e3.time += t2, this.parent.emit("moved", { viewport: this.parent, type: "bounce-y" }), e3.time >= this.options.time ? (this.parent.y = e3.end, this.toY = null, this.parent.emit("bounce-y-end", this.parent)) : this.parent.y = this.ease(e3.time, e3.start, e3.delta, this.options.time);
      }
    }
  }
  /** @internal */
  calcUnderflowX() {
    let t2;
    switch (this.underflowX) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenWidth - this.parent.screenWorldWidth;
        break;
      default:
        t2 = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
    }
    return t2;
  }
  /** @internal */
  calcUnderflowY() {
    let t2;
    switch (this.underflowY) {
      case -1:
        t2 = 0;
        break;
      case 1:
        t2 = this.parent.screenHeight - this.parent.screenWorldHeight;
        break;
      default:
        t2 = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
    }
    return t2;
  }
  oob() {
    const t2 = this.options.bounceBox;
    if (t2) {
      const e3 = typeof t2.x > "u" ? 0 : t2.x, n2 = typeof t2.y > "u" ? 0 : t2.y, i2 = typeof t2.width > "u" ? this.parent.worldWidth : t2.width, s2 = typeof t2.height > "u" ? this.parent.worldHeight : t2.height;
      return {
        left: this.parent.left < e3,
        right: this.parent.right > i2,
        top: this.parent.top < n2,
        bottom: this.parent.bottom > s2,
        topLeft: new Point(
          e3 * this.parent.scale.x,
          n2 * this.parent.scale.y
        ),
        bottomRight: new Point(
          i2 * this.parent.scale.x - this.parent.screenWidth,
          s2 * this.parent.scale.y - this.parent.screenHeight
        )
      };
    }
    return {
      left: this.parent.left < 0,
      right: this.parent.right > this.parent.worldWidth,
      top: this.parent.top < 0,
      bottom: this.parent.bottom > this.parent.worldHeight,
      topLeft: new Point(0, 0),
      bottomRight: new Point(
        this.parent.worldWidth * this.parent.scale.x - this.parent.screenWidth,
        this.parent.worldHeight * this.parent.scale.y - this.parent.screenHeight
      )
    };
  }
  bounce() {
    var s2, h2;
    if (this.paused)
      return;
    let t2, e3 = this.parent.plugins.get("decelerate", true);
    e3 && (e3.x || e3.y) && (e3.x && e3.percentChangeX === ((s2 = e3.options) == null ? void 0 : s2.friction) || e3.y && e3.percentChangeY === ((h2 = e3.options) == null ? void 0 : h2.friction)) && (t2 = this.oob(), (t2.left && this.left || t2.right && this.right) && (e3.percentChangeX = this.options.friction), (t2.top && this.top || t2.bottom && this.bottom) && (e3.percentChangeY = this.options.friction));
    const n2 = this.parent.plugins.get("drag", true) || {}, i2 = this.parent.plugins.get("pinch", true) || {};
    if (e3 = e3 || {}, !(n2 != null && n2.active) && !(i2 != null && i2.active) && (!this.toX || !this.toY) && (!e3.x || !e3.y)) {
      t2 = t2 || this.oob();
      const o2 = t2.topLeft, r2 = t2.bottomRight;
      if (!this.toX && !e3.x) {
        let a3 = null;
        t2.left && this.left ? a3 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -o2.x : t2.right && this.right && (a3 = this.parent.screenWorldWidth < this.parent.screenWidth ? this.calcUnderflowX() : -r2.x), a3 !== null && this.parent.x !== a3 && (this.toX = { time: 0, start: this.parent.x, delta: a3 - this.parent.x, end: a3 }, this.parent.emit("bounce-x-start", this.parent));
      }
      if (!this.toY && !e3.y) {
        let a3 = null;
        t2.top && this.top ? a3 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -o2.y : t2.bottom && this.bottom && (a3 = this.parent.screenWorldHeight < this.parent.screenHeight ? this.calcUnderflowY() : -r2.y), a3 !== null && this.parent.y !== a3 && (this.toY = { time: 0, start: this.parent.y, delta: a3 - this.parent.y, end: a3 }, this.parent.emit("bounce-y-start", this.parent));
      }
    }
  }
  reset() {
    this.toX = this.toY = null, this.bounce();
  }
};
var Y = {
  left: false,
  right: false,
  top: false,
  bottom: false,
  direction: null,
  underflow: "center"
};
var X = class extends u2 {
  /**
   * This is called by {@link Viewport.clamp}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, Y, e3), this.options.direction && (this.options.left = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.right = this.options.direction === "x" || this.options.direction === "all" ? true : null, this.options.top = this.options.direction === "y" || this.options.direction === "all" ? true : null, this.options.bottom = this.options.direction === "y" || this.options.direction === "all" ? true : null), this.parseUnderflow(), this.last = { x: null, y: null, scaleX: null, scaleY: null }, this.update();
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "none" ? this.noUnderflow = true : t2 === "center" ? (this.underflowX = this.underflowY = 0, this.noUnderflow = false) : (this.underflowX = t2.indexOf("left") !== -1 ? -1 : t2.indexOf("right") !== -1 ? 1 : 0, this.underflowY = t2.indexOf("top") !== -1 ? -1 : t2.indexOf("bottom") !== -1 ? 1 : 0, this.noUnderflow = false);
  }
  move() {
    return this.update(), false;
  }
  update() {
    if (this.paused || this.parent.x === this.last.x && this.parent.y === this.last.y && this.parent.scale.x === this.last.scaleX && this.parent.scale.y === this.last.scaleY)
      return;
    const t2 = new Point(this.parent.x, this.parent.y), e3 = this.parent.plugins.decelerate || {};
    if (this.options.left !== null || this.options.right !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x !== 0 && (this.parent.x = 0, n2 = true);
            break;
          case 1:
            this.parent.x !== this.parent.screenWidth - this.parent.screenWorldWidth && (this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth, n2 = true);
            break;
          default:
            this.parent.x !== (this.parent.screenWidth - this.parent.screenWorldWidth) / 2 && (this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2, n2 = true);
        }
      else
        this.options.left !== null && this.parent.left < (this.options.left === true ? 0 : this.options.left) && (this.parent.x = -(this.options.left === true ? 0 : this.options.left) * this.parent.scale.x, e3.x = 0, n2 = true), this.options.right !== null && this.parent.right > (this.options.right === true ? this.parent.worldWidth : this.options.right) && (this.parent.x = -(this.options.right === true ? this.parent.worldWidth : this.options.right) * this.parent.scale.x + this.parent.screenWidth, e3.x = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-x" });
    }
    if (this.options.top !== null || this.options.bottom !== null) {
      let n2 = false;
      if (!this.noUnderflow && this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y !== 0 && (this.parent.y = 0, n2 = true);
            break;
          case 1:
            this.parent.y !== this.parent.screenHeight - this.parent.screenWorldHeight && (this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight, n2 = true);
            break;
          default:
            this.parent.y !== (this.parent.screenHeight - this.parent.screenWorldHeight) / 2 && (this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2, n2 = true);
        }
      else
        this.options.top !== null && this.parent.top < (this.options.top === true ? 0 : this.options.top) && (this.parent.y = -(this.options.top === true ? 0 : this.options.top) * this.parent.scale.y, e3.y = 0, n2 = true), this.options.bottom !== null && this.parent.bottom > (this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) && (this.parent.y = -(this.options.bottom === true ? this.parent.worldHeight : this.options.bottom) * this.parent.scale.y + this.parent.screenHeight, e3.y = 0, n2 = true);
      n2 && this.parent.emit("moved", { viewport: this.parent, original: t2, type: "clamp-y" });
    }
    this.last.x = this.parent.x, this.last.y = this.parent.y, this.last.scaleX = this.parent.scale.x, this.last.scaleY = this.parent.scale.y;
  }
  reset() {
    this.update();
  }
};
var z = {
  minWidth: null,
  minHeight: null,
  maxWidth: null,
  maxHeight: null,
  minScale: null,
  maxScale: null
};
var A = class extends u2 {
  /**
   * This is called by {@link Viewport.clampZoom}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, z, e3), this.clamp();
  }
  resize() {
    this.clamp();
  }
  /** Clamp the viewport scale zoom) */
  clamp() {
    if (!this.paused) {
      if (this.options.minWidth || this.options.minHeight || this.options.maxWidth || this.options.maxHeight) {
        let t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight;
        if (this.options.minWidth !== null && t2 < this.options.minWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.minWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxWidth !== null && t2 > this.options.maxWidth) {
          const n2 = this.parent.scale.x;
          this.parent.fitWidth(this.options.maxWidth, false, false, true), this.parent.scale.y *= this.parent.scale.x / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.minHeight !== null && e3 < this.options.minHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.minHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
        if (this.options.maxHeight !== null && e3 > this.options.maxHeight) {
          const n2 = this.parent.scale.y;
          this.parent.fitHeight(this.options.maxHeight, false, false, true), this.parent.scale.x *= this.parent.scale.y / n2, this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" });
        }
      } else if (this.options.minScale || this.options.maxScale) {
        const t2 = { x: null, y: null }, e3 = { x: null, y: null };
        if (typeof this.options.minScale == "number")
          t2.x = this.options.minScale, t2.y = this.options.minScale;
        else if (this.options.minScale !== null) {
          const s2 = this.options.minScale;
          t2.x = typeof s2.x > "u" ? null : s2.x, t2.y = typeof s2.y > "u" ? null : s2.y;
        }
        if (typeof this.options.maxScale == "number")
          e3.x = this.options.maxScale, e3.y = this.options.maxScale;
        else if (this.options.maxScale !== null) {
          const s2 = this.options.maxScale;
          e3.x = typeof s2.x > "u" ? null : s2.x, e3.y = typeof s2.y > "u" ? null : s2.y;
        }
        let n2 = this.parent.scale.x, i2 = this.parent.scale.y;
        t2.x !== null && n2 < t2.x && (n2 = t2.x), e3.x !== null && n2 > e3.x && (n2 = e3.x), t2.y !== null && i2 < t2.y && (i2 = t2.y), e3.y !== null && i2 > e3.y && (i2 = e3.y), (n2 !== this.parent.scale.x || i2 !== this.parent.scale.y) && (this.parent.scale.set(n2, i2), this.parent.emit("zoomed", { viewport: this.parent, type: "clamp-zoom" }));
      }
    }
  }
  reset() {
    this.clamp();
  }
};
var _2 = {
  friction: 0.98,
  bounce: 0.8,
  minSpeed: 0.01
};
var d2 = 16;
var T = class extends u2 {
  /**
   * This is called by {@link Viewport.decelerate}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, _2, e3), this.saved = [], this.timeSinceRelease = 0, this.reset(), this.parent.on("moved", (n2) => this.handleMoved(n2));
  }
  down() {
    return this.saved = [], this.x = this.y = null, false;
  }
  isActive() {
    return !!(this.x || this.y);
  }
  move() {
    if (this.paused)
      return false;
    const t2 = this.parent.input.count();
    return (t2 === 1 || t2 > 1 && !this.parent.plugins.get("pinch", true)) && (this.saved.push({ x: this.parent.x, y: this.parent.y, time: performance.now() }), this.saved.length > 60 && this.saved.splice(0, 30)), false;
  }
  /** Listener to viewport's "moved" event. */
  handleMoved(t2) {
    if (this.saved.length) {
      const e3 = this.saved[this.saved.length - 1];
      t2.type === "clamp-x" && t2.original ? e3.x === t2.original.x && (e3.x = this.parent.x) : t2.type === "clamp-y" && t2.original && e3.y === t2.original.y && (e3.y = this.parent.y);
    }
  }
  up() {
    if (this.parent.input.count() === 0 && this.saved.length) {
      const t2 = performance.now();
      for (const e3 of this.saved)
        if (e3.time >= t2 - 100) {
          const n2 = t2 - e3.time;
          this.x = (this.parent.x - e3.x) / n2, this.y = (this.parent.y - e3.y) / n2, this.percentChangeX = this.percentChangeY = this.options.friction, this.timeSinceRelease = 0;
          break;
        }
    }
    return false;
  }
  /**
   * Manually activate deceleration, starting from the (x, y) velocity components passed in the options.
   *
   * @param {object} options
   * @param {number} [options.x] - Specify x-component of initial velocity.
   * @param {number} [options.y] - Specify y-component of initial velocity.
   */
  activate(t2) {
    t2 = t2 || {}, typeof t2.x < "u" && (this.x = t2.x, this.percentChangeX = this.options.friction), typeof t2.y < "u" && (this.y = t2.y, this.percentChangeY = this.options.friction);
  }
  update(t2) {
    if (this.paused)
      return;
    const e3 = this.x || this.y, n2 = this.timeSinceRelease, i2 = this.timeSinceRelease + t2;
    if (this.x) {
      const s2 = this.percentChangeX, h2 = Math.log(s2);
      this.parent.x += this.x * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.x *= Math.pow(this.percentChangeX, t2 / d2);
    }
    if (this.y) {
      const s2 = this.percentChangeY, h2 = Math.log(s2);
      this.parent.y += this.y * d2 / h2 * (Math.pow(s2, i2 / d2) - Math.pow(s2, n2 / d2)), this.y *= Math.pow(this.percentChangeY, t2 / d2);
    }
    this.timeSinceRelease += t2, this.x && this.y ? Math.abs(this.x) < this.options.minSpeed && Math.abs(this.y) < this.options.minSpeed && (this.x = 0, this.y = 0) : (Math.abs(this.x || 0) < this.options.minSpeed && (this.x = 0), Math.abs(this.y || 0) < this.options.minSpeed && (this.y = 0)), e3 && this.parent.emit("moved", { viewport: this.parent, type: "decelerate" });
  }
  reset() {
    this.x = this.y = null;
  }
};
var E = {
  direction: "all",
  pressDrag: true,
  wheel: true,
  wheelScroll: 1,
  reverse: false,
  clampWheel: false,
  underflow: "center",
  factor: 1,
  mouseButtons: "all",
  keyToPress: null,
  ignoreKeyToPressOnTouch: false,
  lineHeight: 20,
  wheelSwapAxes: false
};
var D = class extends u2 {
  /**
   * This is called by {@link Viewport.drag}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.windowEventHandlers = [], this.options = Object.assign({}, E, e3), this.moved = false, this.reverse = this.options.reverse ? 1 : -1, this.xDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "x", this.yDirection = !this.options.direction || this.options.direction === "all" || this.options.direction === "y", this.keyIsPressed = false, this.parseUnderflow(), this.mouseButtons(this.options.mouseButtons), this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger drag event
   */
  handleKeyPresses(t2) {
    const e3 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = true);
    }, n2 = (i2) => {
      t2.includes(i2.code) && (this.keyIsPressed = false);
    };
    this.addWindowEventHandler("keyup", n2), this.addWindowEventHandler("keydown", e3);
  }
  addWindowEventHandler(t2, e3) {
    typeof window > "u" || (window.addEventListener(t2, e3), this.windowEventHandlers.push({ event: t2, handler: e3 }));
  }
  destroy() {
    typeof window > "u" || this.windowEventHandlers.forEach(({ event: t2, handler: e3 }) => {
      window.removeEventListener(t2, e3);
    });
  }
  /**
   * initialize mousebuttons array
   * @param {string} buttons
   */
  mouseButtons(t2) {
    !t2 || t2 === "all" ? this.mouse = [true, true, true] : this.mouse = [
      t2.indexOf("left") !== -1,
      t2.indexOf("middle") !== -1,
      t2.indexOf("right") !== -1
    ];
  }
  parseUnderflow() {
    const t2 = this.options.underflow.toLowerCase();
    t2 === "center" ? (this.underflowX = 0, this.underflowY = 0) : (t2.includes("left") ? this.underflowX = -1 : t2.includes("right") ? this.underflowX = 1 : this.underflowX = 0, t2.includes("top") ? this.underflowY = -1 : t2.includes("bottom") ? this.underflowY = 1 : this.underflowY = 0);
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkButtons(t2) {
    const e3 = t2.pointerType === "mouse", n2 = this.parent.input.count();
    return !!((n2 === 1 || n2 > 1 && !this.parent.plugins.get("pinch", true)) && (!e3 || this.mouse[t2.button]));
  }
  /**
   * @param {PIXI.FederatedPointerEvent} event
   * @returns {boolean}
   */
  checkKeyPress(t2) {
    return !this.options.keyToPress || this.keyIsPressed || this.options.ignoreKeyToPressOnTouch && t2.data.pointerType === "touch";
  }
  down(t2) {
    return this.paused || !this.options.pressDrag ? false : this.checkButtons(t2) && this.checkKeyPress(t2) ? (this.last = { x: t2.global.x, y: t2.global.y }, this.current = t2.pointerId, true) : (this.last = null, false);
  }
  get active() {
    return this.moved;
  }
  move(t2) {
    if (this.paused || !this.options.pressDrag)
      return false;
    if (this.last && this.current === t2.data.pointerId) {
      const e3 = t2.global.x, n2 = t2.global.y, i2 = this.parent.input.count();
      if (i2 === 1 || i2 > 1 && !this.parent.plugins.get("pinch", true)) {
        const s2 = e3 - this.last.x, h2 = n2 - this.last.y;
        if (this.moved || this.xDirection && this.parent.input.checkThreshold(s2) || this.yDirection && this.parent.input.checkThreshold(h2)) {
          const o2 = { x: e3, y: n2 };
          return this.xDirection && (this.parent.x += (o2.x - this.last.x) * this.options.factor), this.yDirection && (this.parent.y += (o2.y - this.last.y) * this.options.factor), this.last = o2, this.moved || this.parent.emit("drag-start", {
            event: t2,
            screen: new Point(this.last.x, this.last.y),
            world: this.parent.toWorld(new Point(this.last.x, this.last.y)),
            viewport: this.parent
          }), this.moved = true, this.parent.emit("moved", { viewport: this.parent, type: "drag" }), true;
        }
      } else
        this.moved = false;
    }
    return false;
  }
  up(t2) {
    if (this.paused)
      return false;
    const e3 = this.parent.input.touches;
    if (e3.length === 1) {
      const n2 = e3[0];
      return n2.last && (this.last = { x: n2.last.x, y: n2.last.y }, this.current = n2.id), this.moved = false, true;
    } else if (this.last && this.moved) {
      const n2 = new Point(this.last.x, this.last.y);
      return this.parent.emit("drag-end", {
        event: t2,
        screen: n2,
        world: this.parent.toWorld(n2),
        viewport: this.parent
      }), this.last = null, this.moved = false, true;
    }
    return false;
  }
  wheel(t2) {
    if (this.paused)
      return false;
    if (this.options.wheel) {
      const e3 = this.parent.plugins.get("wheel", true);
      if (!e3 || !e3.options.wheelZoom && !t2.ctrlKey) {
        const n2 = t2.deltaMode ? this.options.lineHeight : 1, i2 = [t2.deltaX, t2.deltaY], [s2, h2] = this.options.wheelSwapAxes ? i2.reverse() : i2;
        return this.xDirection && (this.parent.x += s2 * n2 * this.options.wheelScroll * this.reverse), this.yDirection && (this.parent.y += h2 * n2 * this.options.wheelScroll * this.reverse), this.options.clampWheel && this.clamp(), this.parent.emit("wheel-scroll", this.parent), this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.options.passiveWheel || t2.preventDefault(), this.parent.options.stopPropagation && t2.stopPropagation(), true;
      }
    }
    return false;
  }
  resume() {
    this.last = null, this.paused = false;
  }
  clamp() {
    const t2 = this.parent.plugins.get("decelerate", true) || {};
    if (this.options.clampWheel !== "y")
      if (this.parent.screenWorldWidth < this.parent.screenWidth)
        switch (this.underflowX) {
          case -1:
            this.parent.x = 0;
            break;
          case 1:
            this.parent.x = this.parent.screenWidth - this.parent.screenWorldWidth;
            break;
          default:
            this.parent.x = (this.parent.screenWidth - this.parent.screenWorldWidth) / 2;
        }
      else
        this.parent.left < 0 ? (this.parent.x = 0, t2.x = 0) : this.parent.right > this.parent.worldWidth && (this.parent.x = -this.parent.worldWidth * this.parent.scale.x + this.parent.screenWidth, t2.x = 0);
    if (this.options.clampWheel !== "x")
      if (this.parent.screenWorldHeight < this.parent.screenHeight)
        switch (this.underflowY) {
          case -1:
            this.parent.y = 0;
            break;
          case 1:
            this.parent.y = this.parent.screenHeight - this.parent.screenWorldHeight;
            break;
          default:
            this.parent.y = (this.parent.screenHeight - this.parent.screenWorldHeight) / 2;
        }
      else
        this.parent.top < 0 && (this.parent.y = 0, t2.y = 0), this.parent.bottom > this.parent.worldHeight && (this.parent.y = -this.parent.worldHeight * this.parent.scale.y + this.parent.screenHeight, t2.y = 0);
  }
};
var L = {
  speed: 0,
  acceleration: null,
  radius: null
};
var U = class extends u2 {
  /**
   * This is called by {@link Viewport.follow}.
   *
   * @param parent
   * @param target - target to follow
   * @param options
   */
  constructor(t2, e3, n2 = {}) {
    super(t2), this.target = e3, this.options = Object.assign({}, L, n2), this.velocity = { x: 0, y: 0 };
  }
  update(t2) {
    if (this.paused)
      return;
    const e3 = this.parent.center;
    let n2 = this.target.x, i2 = this.target.y;
    if (this.options.radius)
      if (Math.sqrt(Math.pow(this.target.y - e3.y, 2) + Math.pow(this.target.x - e3.x, 2)) > this.options.radius) {
        const r2 = Math.atan2(this.target.y - e3.y, this.target.x - e3.x);
        n2 = this.target.x - Math.cos(r2) * this.options.radius, i2 = this.target.y - Math.sin(r2) * this.options.radius;
      } else
        return;
    const s2 = n2 - e3.x, h2 = i2 - e3.y;
    if (s2 || h2)
      if (this.options.speed)
        if (this.options.acceleration) {
          const o2 = Math.atan2(i2 - e3.y, n2 - e3.x), r2 = Math.sqrt(Math.pow(s2, 2) + Math.pow(h2, 2));
          if (r2) {
            const a3 = (Math.pow(this.velocity.x, 2) + Math.pow(this.velocity.y, 2)) / (2 * this.options.acceleration);
            r2 > a3 ? this.velocity = {
              x: Math.min(this.velocity.x + (this.options.acceleration * t2, this.options.speed)),
              y: Math.min(this.velocity.y + (this.options.acceleration * t2, this.options.speed))
            } : this.velocity = {
              x: Math.max(this.velocity.x - this.options.acceleration * this.options.speed, 0),
              y: Math.max(this.velocity.y - this.options.acceleration * this.options.speed, 0)
            };
            const p2 = Math.cos(o2) * this.velocity.x, f2 = Math.sin(o2) * this.velocity.y, g2 = Math.abs(p2) > Math.abs(s2) ? n2 : e3.x + p2, w2 = Math.abs(f2) > Math.abs(h2) ? i2 : e3.y + f2;
            this.parent.moveCenter(g2, w2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
          }
        } else {
          const o2 = Math.atan2(i2 - e3.y, n2 - e3.x), r2 = Math.cos(o2) * this.options.speed, a3 = Math.sin(o2) * this.options.speed, p2 = Math.abs(r2) > Math.abs(s2) ? n2 : e3.x + r2, f2 = Math.abs(a3) > Math.abs(h2) ? i2 : e3.y + a3;
          this.parent.moveCenter(p2, f2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
        }
      else
        this.parent.moveCenter(n2, i2), this.parent.emit("moved", { viewport: this.parent, type: "follow" });
  }
};
var F = {
  radius: null,
  distance: null,
  top: null,
  bottom: null,
  left: null,
  right: null,
  speed: 8,
  reverse: false,
  noDecelerate: false,
  linear: false,
  allowButtons: false
};
var B = class extends u2 {
  /**
   * This is called by {@link Viewport.mouseEdges}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, F, e3), this.reverse = this.options.reverse ? 1 : -1, this.radiusSquared = typeof this.options.radius == "number" ? Math.pow(this.options.radius, 2) : null, this.resize();
  }
  resize() {
    const t2 = this.options.distance;
    t2 !== null ? (this.left = t2, this.top = t2, this.right = this.parent.screenWidth - t2, this.bottom = this.parent.screenHeight - t2) : this.options.radius || (this.left = this.options.left, this.top = this.options.top, this.right = this.options.right === null ? null : this.parent.screenWidth - this.options.right, this.bottom = this.options.bottom === null ? null : this.parent.screenHeight - this.options.bottom);
  }
  down() {
    return this.paused || this.options.allowButtons || (this.horizontal = this.vertical = null), false;
  }
  move(t2) {
    if (this.paused || t2.pointerType !== "mouse" && t2.pointerId !== 1 || !this.options.allowButtons && t2.buttons !== 0)
      return false;
    const e3 = t2.global.x, n2 = t2.global.y;
    if (this.radiusSquared) {
      const i2 = this.parent.toScreen(this.parent.center);
      if (Math.pow(i2.x - e3, 2) + Math.pow(i2.y - n2, 2) >= this.radiusSquared) {
        const h2 = Math.atan2(i2.y - n2, i2.x - e3);
        this.options.linear ? (this.horizontal = Math.round(Math.cos(h2)) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.round(Math.sin(h2)) * this.options.speed * this.reverse * (60 / 1e3)) : (this.horizontal = Math.cos(h2) * this.options.speed * this.reverse * (60 / 1e3), this.vertical = Math.sin(h2) * this.options.speed * this.reverse * (60 / 1e3));
      } else
        this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = 0;
    } else
      this.left !== null && e3 < this.left ? this.horizontal = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.right !== null && e3 > this.right ? this.horizontal = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateHorizontal(), this.horizontal = 0), this.top !== null && n2 < this.top ? this.vertical = Number(this.reverse) * this.options.speed * (60 / 1e3) : this.bottom !== null && n2 > this.bottom ? this.vertical = -1 * this.reverse * this.options.speed * (60 / 1e3) : (this.decelerateVertical(), this.vertical = 0);
    return false;
  }
  decelerateHorizontal() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.horizontal && t2 && !this.options.noDecelerate && t2.activate({ x: this.horizontal * this.options.speed * this.reverse / (1e3 / 60) });
  }
  decelerateVertical() {
    const t2 = this.parent.plugins.get("decelerate", true);
    this.vertical && t2 && !this.options.noDecelerate && t2.activate({ y: this.vertical * this.options.speed * this.reverse / (1e3 / 60) });
  }
  up() {
    return this.paused || (this.horizontal && this.decelerateHorizontal(), this.vertical && this.decelerateVertical(), this.horizontal = this.vertical = null), false;
  }
  update() {
    if (!this.paused && (this.horizontal || this.vertical)) {
      const t2 = this.parent.center;
      this.horizontal && (t2.x += this.horizontal * this.options.speed), this.vertical && (t2.y += this.vertical * this.options.speed), this.parent.moveCenter(t2), this.parent.emit("moved", { viewport: this.parent, type: "mouse-edges" });
    }
  }
};
var V = {
  noDrag: false,
  percent: 1,
  center: null,
  factor: 1,
  axis: "all"
};
var N2 = class extends u2 {
  /**
   * This is called by {@link Viewport.pinch}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.active = false, this.pinching = false, this.moved = false, this.options = Object.assign({}, V, e3);
  }
  down() {
    return this.parent.input.count() >= 2 ? (this.active = true, true) : false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  move(t2) {
    if (this.paused || !this.active)
      return false;
    const e3 = t2.global.x, n2 = t2.global.y, i2 = this.parent.input.touches;
    if (i2.length >= 2) {
      const s2 = i2[0], h2 = i2[1], o2 = s2.last && h2.last ? Math.sqrt(Math.pow(h2.last.x - s2.last.x, 2) + Math.pow(h2.last.y - s2.last.y, 2)) : null;
      if (s2.id === t2.pointerId ? s2.last = { x: e3, y: n2, data: t2 } : h2.id === t2.pointerId && (h2.last = { x: e3, y: n2, data: t2 }), o2) {
        let r2;
        const a3 = new Point(
          s2.last.x + (h2.last.x - s2.last.x) / 2,
          s2.last.y + (h2.last.y - s2.last.y) / 2
        );
        this.options.center || (r2 = this.parent.toLocal(a3));
        let p2 = Math.sqrt(Math.pow(
          h2.last.x - s2.last.x,
          2
        ) + Math.pow(h2.last.y - s2.last.y, 2));
        p2 = p2 === 0 ? p2 = 1e-10 : p2;
        const f2 = (1 - o2 / p2) * this.options.percent * (this.isAxisX() ? this.parent.scale.x : this.parent.scale.y);
        this.isAxisX() && (this.parent.scale.x += f2), this.isAxisY() && (this.parent.scale.y += f2), this.parent.emit("zoomed", { viewport: this.parent, type: "pinch", center: a3 });
        const g2 = this.parent.plugins.get("clamp-zoom", true);
        if (g2 && g2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const w2 = this.parent.toGlobal(r2);
          this.parent.x += (a3.x - w2.x) * this.options.factor, this.parent.y += (a3.y - w2.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" });
        }
        !this.options.noDrag && this.lastCenter && (this.parent.x += (a3.x - this.lastCenter.x) * this.options.factor, this.parent.y += (a3.y - this.lastCenter.y) * this.options.factor, this.parent.emit("moved", { viewport: this.parent, type: "pinch" })), this.lastCenter = a3, this.moved = true;
      } else
        this.pinching || (this.parent.emit("pinch-start", this.parent), this.pinching = true);
      return true;
    }
    return false;
  }
  up() {
    return this.pinching && this.parent.input.touches.length <= 1 ? (this.active = false, this.lastCenter = null, this.pinching = false, this.moved = false, this.parent.emit("pinch-end", this.parent), true) : false;
  }
};
var Z = {
  topLeft: false,
  friction: 0.8,
  time: 1e3,
  ease: "easeInOutSine",
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false
};
var j2 = class extends u2 {
  /**
   * This is called by {@link Viewport.snap}.
   */
  constructor(t2, e3, n2, i2 = {}) {
    super(t2), this.options = Object.assign({}, Z, i2), this.ease = x2(i2.ease, "easeInOutSine"), this.x = e3, this.y = n2, this.options.forceStart && this.snapStart();
  }
  snapStart() {
    this.percent = 0, this.snapping = { time: 0 };
    const t2 = this.options.topLeft ? this.parent.corner : this.parent.center;
    this.deltaX = this.x - t2.x, this.deltaY = this.y - t2.y, this.startX = t2.x, this.startY = t2.y, this.parent.emit("snap-start", this.parent);
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap") : this.options.interrupt && (this.snapping = null), false;
  }
  up() {
    if (this.parent.input.count() === 0) {
      const t2 = this.parent.plugins.get("decelerate", true);
      t2 && (t2.x || t2.y) && (t2.percentChangeX = t2.percentChangeY = this.options.friction);
    }
    return false;
  }
  update(t2) {
    if (!this.paused && !(this.options.interrupt && this.parent.input.count() !== 0))
      if (this.snapping) {
        const e3 = this.snapping;
        e3.time += t2;
        let n2, i2, s2;
        const h2 = this.startX, o2 = this.startY, r2 = this.deltaX, a3 = this.deltaY;
        if (e3.time > this.options.time)
          n2 = true, i2 = h2 + r2, s2 = o2 + a3;
        else {
          const p2 = this.ease(e3.time, 0, 1, this.options.time);
          i2 = h2 + r2 * p2, s2 = o2 + a3 * p2;
        }
        this.options.topLeft ? this.parent.moveCorner(i2, s2) : this.parent.moveCenter(i2, s2), this.parent.emit("moved", { viewport: this.parent, type: "snap" }), n2 && (this.options.removeOnComplete && this.parent.plugins.remove("snap"), this.parent.emit("snap-end", this.parent), this.snapping = null);
      } else {
        const e3 = this.options.topLeft ? this.parent.corner : this.parent.center;
        (e3.x !== this.x || e3.y !== this.y) && this.snapStart();
      }
  }
};
var R = {
  width: 0,
  height: 0,
  time: 1e3,
  ease: "easeInOutSine",
  center: null,
  interrupt: true,
  removeOnComplete: false,
  removeOnInterrupt: false,
  forceStart: false,
  noMove: false
};
var K = class extends u2 {
  /**
   * This is called by {@link Viewport.snapZoom}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, R, e3), this.ease = x2(this.options.ease), this.xIndependent = false, this.yIndependent = false, this.xScale = 0, this.yScale = 0, this.options.width > 0 && (this.xScale = t2.screenWidth / this.options.width, this.xIndependent = true), this.options.height > 0 && (this.yScale = t2.screenHeight / this.options.height, this.yIndependent = true), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale, this.options.time === 0 ? (t2.container.scale.x = this.xScale, t2.container.scale.y = this.yScale, this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom")) : e3.forceStart && this.createSnapping();
  }
  createSnapping() {
    const t2 = this.parent.worldScreenWidth, e3 = this.parent.worldScreenHeight, n2 = this.parent.screenWidth / this.xScale, i2 = this.parent.screenHeight / this.yScale;
    this.snapping = {
      time: 0,
      startX: t2,
      startY: e3,
      deltaX: n2 - t2,
      deltaY: i2 - e3
    }, this.parent.emit("snap-zoom-start", this.parent);
  }
  resize() {
    this.snapping = null, this.options.width > 0 && (this.xScale = this.parent.screenWidth / this.options.width), this.options.height > 0 && (this.yScale = this.parent.screenHeight / this.options.height), this.xScale = this.xIndependent ? this.xScale : this.yScale, this.yScale = this.yIndependent ? this.yScale : this.xScale;
  }
  wheel() {
    return this.options.removeOnInterrupt && this.parent.plugins.remove("snap-zoom"), false;
  }
  down() {
    return this.options.removeOnInterrupt ? this.parent.plugins.remove("snap-zoom") : this.options.interrupt && (this.snapping = null), false;
  }
  update(t2) {
    if (this.paused || this.options.interrupt && this.parent.input.count() !== 0)
      return;
    let e3;
    if (!this.options.center && !this.options.noMove && (e3 = this.parent.center), !this.snapping)
      (this.parent.scale.x !== this.xScale || this.parent.scale.y !== this.yScale) && this.createSnapping();
    else if (this.snapping) {
      const n2 = this.snapping;
      if (n2.time += t2, n2.time >= this.options.time)
        this.parent.scale.set(this.xScale, this.yScale), this.options.removeOnComplete && this.parent.plugins.remove("snap-zoom"), this.parent.emit("snap-zoom-end", this.parent), this.snapping = null;
      else {
        const s2 = this.snapping, h2 = this.ease(s2.time, s2.startX, s2.deltaX, this.options.time), o2 = this.ease(s2.time, s2.startY, s2.deltaY, this.options.time);
        this.parent.scale.x = this.parent.screenWidth / h2, this.parent.scale.y = this.parent.screenHeight / o2;
      }
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      i2 && i2.clamp(), this.options.noMove || (this.options.center ? this.parent.moveCenter(this.options.center) : this.parent.moveCenter(e3));
    }
  }
  resume() {
    this.snapping = null, super.resume();
  }
};
var q = {
  percent: 0.1,
  smooth: false,
  interrupt: true,
  reverse: false,
  center: null,
  lineHeight: 20,
  axis: "all",
  keyToPress: null,
  trackpadPinch: false,
  wheelZoom: true
};
var G = class extends u2 {
  /**
   * This is called by {@link Viewport.wheel}.
   */
  constructor(t2, e3 = {}) {
    super(t2), this.options = Object.assign({}, q, e3), this.keyIsPressed = false, this.options.keyToPress && this.handleKeyPresses(this.options.keyToPress);
  }
  /**
   * Handles keypress events and set the keyIsPressed boolean accordingly
   *
   * @param {array} codes - key codes that can be used to trigger zoom event
   */
  handleKeyPresses(t2) {
    typeof window > "u" || (window.addEventListener("keydown", (e3) => {
      t2.includes(e3.code) && (this.keyIsPressed = true);
    }), window.addEventListener("keyup", (e3) => {
      t2.includes(e3.code) && (this.keyIsPressed = false);
    }));
  }
  checkKeyPress() {
    return !this.options.keyToPress || this.keyIsPressed;
  }
  down() {
    return this.options.interrupt && (this.smoothing = null), false;
  }
  isAxisX() {
    return ["all", "x"].includes(this.options.axis);
  }
  isAxisY() {
    return ["all", "y"].includes(this.options.axis);
  }
  update() {
    if (this.smoothing) {
      const t2 = this.smoothingCenter, e3 = this.smoothing;
      let n2;
      this.options.center || (n2 = this.parent.toLocal(t2)), this.isAxisX() && (this.parent.scale.x += e3.x), this.isAxisY() && (this.parent.scale.y += e3.y), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
      const i2 = this.parent.plugins.get("clamp-zoom", true);
      if (i2 && i2.clamp(), this.options.center)
        this.parent.moveCenter(this.options.center);
      else {
        const s2 = this.parent.toGlobal(n2);
        this.parent.x += t2.x - s2.x, this.parent.y += t2.y - s2.y;
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.smoothingCount++, this.smoothingCount >= this.options.smooth && (this.smoothing = null);
    }
  }
  pinch(t2) {
    if (this.paused)
      return;
    const e3 = this.parent.input.getPointerPosition(t2), n2 = -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 200, i2 = Math.pow(2, (1 + this.options.percent) * n2);
    let s2;
    this.options.center || (s2 = this.parent.toLocal(e3)), this.isAxisX() && (this.parent.scale.x *= i2), this.isAxisY() && (this.parent.scale.y *= i2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
    const h2 = this.parent.plugins.get("clamp-zoom", true);
    if (h2 && h2.clamp(), this.options.center)
      this.parent.moveCenter(this.options.center);
    else {
      const o2 = this.parent.toGlobal(s2);
      this.parent.x += e3.x - o2.x, this.parent.y += e3.y - o2.y;
    }
    this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
      "wheel-start",
      { event: t2, viewport: this.parent }
    );
  }
  wheel(t2) {
    if (this.paused || !this.checkKeyPress())
      return false;
    if (t2.ctrlKey && this.options.trackpadPinch)
      this.pinch(t2);
    else if (this.options.wheelZoom) {
      const e3 = this.parent.input.getPointerPosition(t2), i2 = (this.options.reverse ? -1 : 1) * -t2.deltaY * (t2.deltaMode ? this.options.lineHeight : 1) / 500, s2 = Math.pow(2, (1 + this.options.percent) * i2);
      if (this.options.smooth) {
        const h2 = {
          x: this.smoothing ? this.smoothing.x * (this.options.smooth - this.smoothingCount) : 0,
          y: this.smoothing ? this.smoothing.y * (this.options.smooth - this.smoothingCount) : 0
        };
        this.smoothing = {
          x: ((this.parent.scale.x + h2.x) * s2 - this.parent.scale.x) / this.options.smooth,
          y: ((this.parent.scale.y + h2.y) * s2 - this.parent.scale.y) / this.options.smooth
        }, this.smoothingCount = 0, this.smoothingCenter = e3;
      } else {
        let h2;
        this.options.center || (h2 = this.parent.toLocal(e3)), this.isAxisX() && (this.parent.scale.x *= s2), this.isAxisY() && (this.parent.scale.y *= s2), this.parent.emit("zoomed", { viewport: this.parent, type: "wheel" });
        const o2 = this.parent.plugins.get("clamp-zoom", true);
        if (o2 && o2.clamp(), this.options.center)
          this.parent.moveCenter(this.options.center);
        else {
          const r2 = this.parent.toGlobal(h2);
          this.parent.x += e3.x - r2.x, this.parent.y += e3.y - r2.y;
        }
      }
      this.parent.emit("moved", { viewport: this.parent, type: "wheel" }), this.parent.emit(
        "wheel-start",
        { event: t2, viewport: this.parent }
      );
    }
    return !this.parent.options.passiveWheel;
  }
};
var Q = class {
  constructor(t2) {
    this.viewport = t2, this.touches = [], this.addListeners();
  }
  /** Add input listeners */
  addListeners() {
    this.viewport.eventMode = "static", this.viewport.forceHitArea || (this.viewport.hitArea = new Rectangle(0, 0, this.viewport.worldWidth, this.viewport.worldHeight)), this.viewport.on("pointerdown", this.down, this), this.viewport.options.allowPreserveDragOutside ? this.viewport.on("globalpointermove", this.move, this) : this.viewport.on("pointermove", this.move, this), this.viewport.on("pointerup", this.up, this), this.viewport.on("pointerupoutside", this.up, this), this.viewport.on("pointercancel", this.up, this), this.viewport.options.allowPreserveDragOutside || this.viewport.on("pointerleave", this.up, this), this.wheelFunction = (t2) => this.handleWheel(t2), this.viewport.options.events.domElement.addEventListener(
      "wheel",
      this.wheelFunction,
      { passive: this.viewport.options.passiveWheel }
    ), this.isMouseDown = false;
  }
  /**
   * Removes all event listeners from viewport
   * (useful for cleanup of wheel when removing viewport)
   */
  destroy() {
    var t2;
    (t2 = this.viewport.options.events.domElement) == null || t2.removeEventListener("wheel", this.wheelFunction);
  }
  /**
   * handle down events for viewport
   *
   * @param {PIXI.FederatedPointerEvent} event
   */
  down(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    if (t2.pointerType === "mouse" ? this.isMouseDown = true : this.get(t2.pointerId) || this.touches.push({ id: t2.pointerId, last: null }), this.count() === 1) {
      this.last = t2.global.clone();
      const n2 = this.viewport.plugins.get("decelerate", true), i2 = this.viewport.plugins.get("bounce", true);
      (!n2 || !n2.isActive()) && (!i2 || !i2.isActive()) ? this.clickedAvailable = true : this.clickedAvailable = false;
    } else
      this.clickedAvailable = false;
    this.viewport.plugins.down(t2) && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Clears all pointer events */
  clear() {
    this.isMouseDown = false, this.touches = [], this.last = null;
  }
  /**
   * @param {number} change
   * @returns whether change exceeds threshold
   */
  checkThreshold(t2) {
    return Math.abs(t2) >= this.viewport.threshold;
  }
  /** Handle move events for viewport */
  move(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e3 = this.viewport.plugins.move(t2);
    if (this.clickedAvailable && this.last) {
      const n2 = t2.global.x - this.last.x, i2 = t2.global.y - this.last.y;
      (this.checkThreshold(n2) || this.checkThreshold(i2)) && (this.clickedAvailable = false);
    }
    e3 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Handle up events for viewport */
  up(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    t2.pointerType === "mouse" && (this.isMouseDown = false), t2.pointerType !== "mouse" && this.remove(t2.pointerId);
    const e3 = this.viewport.plugins.up(t2);
    this.clickedAvailable && this.count() === 0 && this.last && (this.viewport.emit("clicked", {
      event: t2,
      screen: this.last,
      world: this.viewport.toWorld(this.last),
      viewport: this.viewport
    }), this.clickedAvailable = false), e3 && this.viewport.options.stopPropagation && t2.stopPropagation();
  }
  /** Gets pointer position if this.interaction is set */
  getPointerPosition(t2) {
    const e3 = new Point();
    return this.viewport.options.events.mapPositionToPoint(e3, t2.clientX, t2.clientY), e3;
  }
  /** Handle wheel events */
  handleWheel(t2) {
    if (this.viewport.pause || !this.viewport.visible)
      return;
    const e3 = this.viewport.toLocal(this.getPointerPosition(t2));
    this.viewport.left <= e3.x && e3.x <= this.viewport.right && this.viewport.top <= e3.y && e3.y <= this.viewport.bottom && this.viewport.plugins.wheel(t2) && !this.viewport.options.passiveWheel && t2.preventDefault();
  }
  pause() {
    this.touches = [], this.isMouseDown = false;
  }
  /** Get touch by id */
  get(t2) {
    for (const e3 of this.touches)
      if (e3.id === t2)
        return e3;
    return null;
  }
  /** Remove touch by number */
  remove(t2) {
    for (let e3 = 0; e3 < this.touches.length; e3++)
      if (this.touches[e3].id === t2) {
        this.touches.splice(e3, 1);
        return;
      }
  }
  /**
   * @returns {number} count of mouse/touch pointers that are down on the viewport
   */
  count() {
    return (this.isMouseDown ? 1 : 0) + this.touches.length;
  }
};
var m2 = [
  "drag",
  "pinch",
  "wheel",
  "follow",
  "mouse-edges",
  "decelerate",
  "animate",
  "bounce",
  "snap-zoom",
  "clamp-zoom",
  "snap",
  "clamp"
];
var J = class {
  /** This is called by {@link Viewport} to initialize the {@link Viewport.plugins plugins}. */
  constructor(t2) {
    this.viewport = t2, this.list = [], this.plugins = {};
  }
  /**
   * Inserts a named plugin or a user plugin into the viewport
   * default plugin order: 'drag', 'pinch', 'wheel', 'follow', 'mouse-edges', 'decelerate', 'bounce',
   * 'snap-zoom', 'clamp-zoom', 'snap', 'clamp'
   *
   * @param {string} name of plugin
   * @param {Plugin} plugin - instantiated Plugin class
   * @param {number} index to insert userPlugin (otherwise inserts it at the end)
   */
  add(t2, e3, n2 = m2.length) {
    const i2 = this.plugins[t2];
    i2 && i2.destroy(), this.plugins[t2] = e3;
    const s2 = m2.indexOf(t2);
    s2 !== -1 && m2.splice(s2, 1), m2.splice(n2, 0, t2), this.sort();
  }
  /**
   * Get plugin
   *
   * @param {string} name of plugin
   * @param {boolean} [ignorePaused] return null if plugin is paused
   */
  get(t2, e3) {
    var n2;
    return e3 && (n2 = this.plugins[t2]) != null && n2.paused ? null : this.plugins[t2];
  }
  /**
   * Update all active plugins
   *
   * @internal
   * @ignore
   * @param {number} elapsed type in milliseconds since last update
   */
  update(t2) {
    for (const e3 of this.list)
      e3.update(t2);
  }
  /**
   * Resize all active plugins
   *
   * @internal
   * @ignore
   */
  resize() {
    for (const t2 of this.list)
      t2.resize();
  }
  /** Clamps and resets bounce and decelerate (as needed) after manually moving viewport */
  reset() {
    for (const t2 of this.list)
      t2.reset();
  }
  /** removes all installed plugins */
  removeAll() {
    this.list.forEach((t2) => {
      t2.destroy();
    }), this.plugins = {}, this.sort();
  }
  /**
   * Removes installed plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  remove(t2) {
    var e3;
    this.plugins[t2] && ((e3 = this.plugins[t2]) == null || e3.destroy(), delete this.plugins[t2], this.viewport.emit("plugin-remove", t2), this.sort());
  }
  /**
   * Pause plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  pause(t2) {
    var e3;
    (e3 = this.plugins[t2]) == null || e3.pause();
  }
  /**
   * Resume plugin
   *
   * @param {string} name of plugin (e.g., 'drag', 'pinch')
   */
  resume(t2) {
    var e3;
    (e3 = this.plugins[t2]) == null || e3.resume();
  }
  /**
   * Sort plugins according to PLUGIN_ORDER
   *
   * @internal
   * @ignore
   */
  sort() {
    this.list = [];
    for (const t2 of m2)
      this.plugins[t2] && this.list.push(this.plugins[t2]);
  }
  /**
   * Handle down for all plugins
   *
   * @internal
   * @ignore
   */
  down(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.down(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle move for all plugins
   *
   * @internal
   * @ignore
   */
  move(t2) {
    let e3 = false;
    for (const n2 of this.viewport.plugins.list)
      n2.move(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle up for all plugins
   *
   * @internal
   * @ignore
   */
  up(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.up(t2) && (e3 = true);
    return e3;
  }
  /**
   * Handle wheel event for all plugins
   *
   * @internal
   * @ignore
   */
  wheel(t2) {
    let e3 = false;
    for (const n2 of this.list)
      n2.wheel(t2) && (e3 = true);
    return e3;
  }
};
var $2 = {
  screenWidth: typeof window > "u" ? 0 : window.innerWidth,
  screenHeight: typeof window > "u" ? 0 : window.innerHeight,
  worldWidth: null,
  worldHeight: null,
  threshold: 5,
  passiveWheel: true,
  stopPropagation: false,
  forceHitArea: null,
  noTicker: false,
  disableOnContextMenu: false,
  ticker: Ticker.shared,
  allowPreserveDragOutside: false
};
var et = class extends Container {
  /**
   * @param {IViewportOptions} ViewportOptions
   * @param {number} [options.screenWidth=window.innerWidth]
   * @param {number} [options.screenHeight=window.innerHeight]
   * @param {number} [options.worldWidth=this.width]
   * @param {number} [options.worldHeight=this.height]
   * @param {number} [options.threshold=5] number of pixels to move to trigger an input event (e.g., drag, pinch)
   * or disable a clicked event
   * @param {boolean} [options.passiveWheel=true] whether the 'wheel' event is set to passive (note: if false,
   * e.preventDefault() will be called when wheel is used over the viewport)
   * @param {boolean} [options.stopPropagation=false] whether to stopPropagation of events that impact the viewport
   * (except wheel events, see options.passiveWheel)
   * @param {HitArea} [options.forceHitArea] change the default hitArea from world size to a new value
   * @param {boolean} [options.noTicker] set this if you want to manually call update() function on each frame
   * @param {PIXI.Ticker} [options.ticker=PIXI.Ticker.shared] use this PIXI.ticker for updates
   * @param {PIXI.EventSystem} [options.events] EventSystem available from app.events or added manually and passed here
   * location on screen
   * @param {boolean} [options.disableOnContextMenu] remove oncontextmenu=() => {} from the pixi's events.domElement
   */
  constructor(t2) {
    super(), this._disableOnContextMenu = (e3) => e3.preventDefault(), this.options = {
      ...$2,
      ...t2
    }, this.screenWidth = this.options.screenWidth, this.screenHeight = this.options.screenHeight, this._worldWidth = this.options.worldWidth, this._worldHeight = this.options.worldHeight, this.forceHitArea = this.options.forceHitArea, this.threshold = this.options.threshold, this.options.disableOnContextMenu && this.options.events.domElement.addEventListener("contextmenu", this._disableOnContextMenu), this.options.noTicker || (this.tickerFunction = () => this.update(this.options.ticker.elapsedMS), this.options.ticker.add(this.tickerFunction)), this.input = new Q(this), this.plugins = new J(this);
  }
  /** Overrides PIXI.Container's destroy to also remove the 'wheel' and PIXI.Ticker listeners */
  destroy(t2) {
    var e3;
    !this.options.noTicker && this.tickerFunction && this.options.ticker.remove(this.tickerFunction), this.options.disableOnContextMenu && ((e3 = this.options.events.domElement) == null || e3.removeEventListener("contextmenu", this._disableOnContextMenu)), this.input.destroy(), super.destroy(t2);
  }
  /**
   * Update viewport on each frame.
   *
   * By default, you do not need to call this unless you set `options.noTicker=true`.
   *
   * @param {number} elapsed time in milliseconds since last update
   */
  update(t2) {
    this.pause || (this.plugins.update(t2), this.lastViewport && (this.lastViewport.x !== this.x || this.lastViewport.y !== this.y ? this.moving = true : this.moving && (this.emit("moved-end", this), this.moving = false), this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y ? this.zooming = true : this.zooming && (this.emit("zoomed-end", this), this.zooming = false)), this.forceHitArea || (this._hitAreaDefault = new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight), this.hitArea = this._hitAreaDefault), this._dirty = this._dirty || !this.lastViewport || this.lastViewport.x !== this.x || this.lastViewport.y !== this.y || this.lastViewport.scaleX !== this.scale.x || this.lastViewport.scaleY !== this.scale.y, this.lastViewport = {
      x: this.x,
      y: this.y,
      scaleX: this.scale.x,
      scaleY: this.scale.y
    }, this.emit("frame-end", this));
  }
  /**
   * Use this to set screen and world sizes, needed for pinch/wheel/clamp/bounce.
   * @param {number} screenWidth=window.innerWidth
   * @param {number} screenHeight=window.innerHeight
   * @param {number} [worldWidth]
   * @param {number} [worldHeight]
   */
  resize(t2 = typeof window > "u" ? 0 : window.innerWidth, e3 = typeof window > "u" ? 0 : window.innerHeight, n2, i2) {
    this.screenWidth = t2, this.screenHeight = e3, typeof n2 < "u" && (this._worldWidth = n2), typeof i2 < "u" && (this._worldHeight = i2), this.plugins.resize(), this.dirty = true;
  }
  /** World width, in pixels */
  get worldWidth() {
    return this._worldWidth ? this._worldWidth : this.width / this.scale.x;
  }
  set worldWidth(t2) {
    this._worldWidth = t2, this.plugins.resize();
  }
  /** World height, in pixels */
  get worldHeight() {
    return this._worldHeight ? this._worldHeight : this.height / this.scale.y;
  }
  set worldHeight(t2) {
    this._worldHeight = t2, this.plugins.resize();
  }
  /** Get visible world bounds of viewport */
  getVisibleBounds() {
    return new Rectangle(this.left, this.top, this.worldScreenWidth, this.worldScreenHeight);
  }
  /**
   * Changes coordinate from screen to world
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toWorld(t2, e3) {
    return arguments.length === 2 ? this.toLocal(new Point(t2, e3)) : this.toLocal(t2);
  }
  /**
   * Changes coordinate from world to screen
   * @param {number|PIXI.Point} x
   * @param {number} y
   * @returns {PIXI.Point}
   */
  toScreen(t2, e3) {
    return arguments.length === 2 ? this.toGlobal(new Point(t2, e3)) : this.toGlobal(t2);
  }
  /** Screen width in world coordinates */
  get worldScreenWidth() {
    return this.screenWidth / this.scale.x;
  }
  /** Screen height in world coordinates */
  get worldScreenHeight() {
    return this.screenHeight / this.scale.y;
  }
  /** World width in screen coordinates */
  get screenWorldWidth() {
    return this.worldWidth * this.scale.x;
  }
  /** World height in screen coordinates */
  get screenWorldHeight() {
    return this.worldHeight * this.scale.y;
  }
  /** Center of screen in world coordinates */
  get center() {
    return new Point(
      this.worldScreenWidth / 2 - this.x / this.scale.x,
      this.worldScreenHeight / 2 - this.y / this.scale.y
    );
  }
  set center(t2) {
    this.moveCenter(t2);
  }
  /**
   * Move center of viewport to (x, y)
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @return {Viewport}
   */
  moveCenter(...t2) {
    let e3, n2;
    typeof t2[0] == "number" ? (e3 = t2[0], n2 = t2[1]) : (e3 = t2[0].x, n2 = t2[0].y);
    const i2 = (this.worldScreenWidth / 2 - e3) * this.scale.x, s2 = (this.worldScreenHeight / 2 - n2) * this.scale.y;
    return (this.x !== i2 || this.y !== s2) && (this.position.set(i2, s2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Top-left corner of Viewport */
  get corner() {
    return new Point(-this.x / this.scale.x, -this.y / this.scale.y);
  }
  set corner(t2) {
    this.moveCorner(t2);
  }
  /**
   * MoveCorner
   * @param {number|PIXI.Point} x
   * @param {number} [y]
   * @returns {Viewport}
   */
  moveCorner(...t2) {
    let e3, n2;
    return t2.length === 1 ? (e3 = -t2[0].x * this.scale.x, n2 = -t2[0].y * this.scale.y) : (e3 = -t2[0] * this.scale.x, n2 = -t2[1] * this.scale.y), (e3 !== this.x || n2 !== this.y) && (this.position.set(e3, n2), this.plugins.reset(), this.dirty = true), this;
  }
  /** Get how many world pixels fit in screen's width */
  get screenWidthInWorldPixels() {
    return this.screenWidth / this.scale.x;
  }
  /** Get how many world pixels fit on screen's height */
  get screenHeightInWorldPixels() {
    return this.screenHeight / this.scale.y;
  }
  /**
   * Find the scale value that fits a world width on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param width - Width in world pixels
   * @return - scale
   */
  findFitWidth(t2) {
    return this.screenWidth / t2;
  }
  /**
   * Finds the scale value that fits a world height on the screens
   * does not change the viewport (use fit... to change)
   *
   * @param height - Height in world pixels
   * @return - scale
   */
  findFitHeight(t2) {
    return this.screenHeight / t2;
  }
  /**
   * Finds the scale value that fits the smaller of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findFit(t2, e3) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e3;
    return Math.min(n2, i2);
  }
  /**
   * Finds the scale value that fits the larger of a world width and world height on the screen
   * does not change the viewport (use fit... to change)
   *
   * @param {number} width in world pixels
   * @param {number} height in world pixels
   * @returns {number} scale
   */
  findCover(t2, e3) {
    const n2 = this.screenWidth / t2, i2 = this.screenHeight / e3;
    return Math.max(n2, i2);
  }
  /**
   * Change zoom so the width fits in the viewport
   *
   * @param width - width in world coordinates
   * @param center - maintain the same center
   * @param scaleY - whether to set scaleY=scaleX
   * @param noClamp - whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitWidth(t2 = this.worldWidth, e3, n2 = true, i2) {
    let s2;
    e3 && (s2 = this.center), this.scale.x = this.screenWidth / t2, n2 && (this.scale.y = this.scale.x);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e3 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so the height fits in the viewport
   *
   * @param {number} [height=this.worldHeight] in world coordinates
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {boolean} [scaleX=true] whether to set scaleX = scaleY
   * @param {boolean} [noClamp] whether to disable clamp-zoom
   * @returns {Viewport} this
   */
  fitHeight(t2 = this.worldHeight, e3, n2 = true, i2) {
    let s2;
    e3 && (s2 = this.center), this.scale.y = this.screenHeight / t2, n2 && (this.scale.x = this.scale.y);
    const h2 = this.plugins.get("clamp-zoom", true);
    return !i2 && h2 && h2.clamp(), e3 && s2 && this.moveCenter(s2), this;
  }
  /**
   * Change zoom so it fits the entire world in the viewport
   *
   * @param {boolean} center maintain the same center of the screen after zoom
   * @returns {Viewport} this
   */
  fitWorld(t2) {
    let e3;
    t2 && (e3 = this.center), this.scale.x = this.screenWidth / this.worldWidth, this.scale.y = this.screenHeight / this.worldHeight, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const n2 = this.plugins.get("clamp-zoom", true);
    return n2 && n2.clamp(), t2 && e3 && this.moveCenter(e3), this;
  }
  /**
   * Change zoom so it fits the size or the entire world in the viewport
   *
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @param {number} [width=this.worldWidth] desired width
   * @param {number} [height=this.worldHeight] desired height
   * @returns {Viewport} this
   */
  fit(t2, e3 = this.worldWidth, n2 = this.worldHeight) {
    let i2;
    t2 && (i2 = this.center), this.scale.x = this.screenWidth / e3, this.scale.y = this.screenHeight / n2, this.scale.x < this.scale.y ? this.scale.y = this.scale.x : this.scale.x = this.scale.y;
    const s2 = this.plugins.get("clamp-zoom", true);
    return s2 && s2.clamp(), t2 && i2 && this.moveCenter(i2), this;
  }
  /**
   * Zoom viewport to specific value.
   *
   * @param {number} scale value (e.g., 1 would be 100%, 0.25 would be 25%)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  setZoom(t2, e3) {
    let n2;
    e3 && (n2 = this.center), this.scale.set(t2);
    const i2 = this.plugins.get("clamp-zoom", true);
    return i2 && i2.clamp(), e3 && n2 && this.moveCenter(n2), this;
  }
  /**
   * Zoom viewport by a certain percent (in both x and y direction).
   *
   * @param {number} percent change (e.g., 0.25 would increase a starting scale of 1.0 to 1.25)
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoomPercent(t2, e3) {
    return this.setZoom(this.scale.x + this.scale.x * t2, e3);
  }
  /**
   * Zoom viewport by increasing/decreasing width by a certain number of pixels.
   *
   * @param {number} change in pixels
   * @param {boolean} [center] maintain the same center of the screen after zoom
   * @return {Viewport} this
   */
  zoom(t2, e3) {
    return this.fitWidth(t2 + this.worldScreenWidth, e3), this;
  }
  /** Changes scale of viewport and maintains center of viewport */
  get scaled() {
    return this.scale.x;
  }
  set scaled(t2) {
    this.setZoom(t2, true);
  }
  /**
   * Returns zoom to the desired scale
   *
   * @param {ISnapZoomOptions} options
   * @param {number} [options.width=0] - the desired width to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.height=0] - the desired height to snap (to maintain aspect ratio, choose width or height)
   * @param {number} [options.time=1000] - time for snapping in ms
   * @param {(string|function)} [options.ease=easeInOutSine] ease function or name (see http://easings.net/
   *   for supported names)
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of the viewport
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at the
   *   desired zoom
   * @param {boolean} [options.noMove] - zoom but do not move
   */
  snapZoom(t2) {
    return this.plugins.add("snap-zoom", new K(this, t2)), this;
  }
  /** Is container out of world bounds */
  OOB() {
    return {
      left: this.left < 0,
      right: this.right > this.worldWidth,
      top: this.top < 0,
      bottom: this.bottom > this.worldHeight,
      cornerPoint: new Point(
        this.worldWidth * this.scale.x - this.screenWidth,
        this.worldHeight * this.scale.y - this.screenHeight
      )
    };
  }
  /** World coordinates of the right edge of the screen */
  get right() {
    return -this.x / this.scale.x + this.worldScreenWidth;
  }
  set right(t2) {
    this.x = -t2 * this.scale.x + this.screenWidth, this.plugins.reset();
  }
  /** World coordinates of the left edge of the screen */
  get left() {
    return -this.x / this.scale.x;
  }
  set left(t2) {
    this.x = -t2 * this.scale.x, this.plugins.reset();
  }
  /** World coordinates of the top edge of the screen */
  get top() {
    return -this.y / this.scale.y;
  }
  set top(t2) {
    this.y = -t2 * this.scale.y, this.plugins.reset();
  }
  /** World coordinates of the bottom edge of the screen */
  get bottom() {
    return -this.y / this.scale.y + this.worldScreenHeight;
  }
  set bottom(t2) {
    this.y = -t2 * this.scale.y + this.screenHeight, this.plugins.reset();
  }
  /**
   * Determines whether the viewport is dirty (i.e., needs to be rendered to the screen because of a change)
   */
  get dirty() {
    return !!this._dirty;
  }
  set dirty(t2) {
    this._dirty = t2;
  }
  /**
   * Permanently changes the Viewport's hitArea
   *
   * NOTE: if not set then hitArea = PIXI.Rectangle(Viewport.left, Viewport.top, Viewport.worldScreenWidth,
   * Viewport.worldScreenHeight)
   */
  get forceHitArea() {
    return this._forceHitArea;
  }
  set forceHitArea(t2) {
    t2 ? (this._forceHitArea = t2, this.hitArea = t2) : (this._forceHitArea = null, this.hitArea = new Rectangle(0, 0, this.worldWidth, this.worldHeight));
  }
  /**
   * Enable one-finger touch to drag
   *
   * NOTE: if you expect users to use right-click dragging, you should enable `viewport.options.disableOnContextMenu`
   * to avoid the context menu popping up on each right-click drag.
   *
   * @param {IDragOptions} [options]
   * @param {string} [options.direction=all] direction to drag
   * @param {boolean} [options.pressDrag=true] whether click to drag is active
   * @param {boolean} [options.wheel=true] use wheel to scroll in direction (unless wheel plugin is active)
   * @param {number} [options.wheelScroll=1] number of pixels to scroll with each wheel spin
   * @param {boolean} [options.reverse] reverse the direction of the wheel scroll
   * @param {(boolean|string)} [options.clampWheel=false] clamp wheel(to avoid weird bounce with mouse wheel)
   * @param {string} [options.underflow=center] where to place world if too small for screen
   * @param {number} [options.factor=1] factor to multiply drag to increase the speed of movement
   * @param {string} [options.mouseButtons=all] changes which mouse buttons trigger drag, use: 'all', 'left',
   *  'right' 'middle', or some combination, like, 'middle-right'; you may want to set
   *   viewport.options.disableOnContextMenu if you want to use right-click dragging
   * @param {string[]} [options.keyToPress=null] - array containing
   *  {@link key|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code} codes of keys that can be
   *  pressed for the drag to be triggered, e.g.: ['ShiftLeft', 'ShiftRight'}.
   * @param {boolean} [options.ignoreKeyToPressOnTouch=false] - ignore keyToPress for touch events
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @returns {Viewport} this
   */
  drag(t2) {
    return this.plugins.add("drag", new D(this, t2)), this;
  }
  /**
   * Clamp to world boundaries or other provided boundaries
   * There are three ways to clamp:
   * 1. direction: 'all' = the world is clamped to its world boundaries, ie, you cannot drag any part of offscreen
   *    direction: 'x' | 'y' = only the x or y direction is clamped to its world boundary
   * 2. left, right, top, bottom = true | number = the world is clamped to the world's pixel location for each side;
   *    if any of these are set to true, then the location is set to the boundary
   *    [0, viewport.worldWidth/viewport.worldHeight], eg: to allow the world to be completely dragged offscreen,
   *    set [-viewport.worldWidth, -viewport.worldHeight, viewport.worldWidth * 2, viewport.worldHeight * 2]
   *
   * Underflow determines what happens when the world is smaller than the viewport
   * 1. none = the world is clamped but there is no special behavior
   * 2. center = the world is centered on the viewport
   * 3. combination of top/bottom/center and left/right/center (case insensitive) = the world is stuck to the
   *     appropriate boundaries
   *
   * NOTES:
   *   clamp is disabled if called with no options; use { direction: 'all' } for all edge clamping
   *   screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *
   * @param {object} [options]
   * @param {(number|boolean)} [options.left=false] - clamp left; true = 0
   * @param {(number|boolean)} [options.right=false] - clamp right; true = viewport.worldWidth
   * @param {(number|boolean)} [options.top=false] - clamp top; true = 0
   * @param {(number|boolean)} [options.bottom=false] - clamp bottom; true = viewport.worldHeight
   * @param {string} [direction] - (all, x, or y) using clamps of [0, viewport.worldWidth/viewport.worldHeight];
   *  replaces left/right/top/bottom if set
   * @param {string} [underflow=center] - where to place world if too small for screen (e.g., top-right, center,
   *  none, bottomLeft)     * @returns {Viewport} this
   */
  clamp(t2) {
    return this.plugins.add("clamp", new X(this, t2)), this;
  }
  /**
   * Decelerate after a move
   *
   * NOTE: this fires 'moved' event during deceleration
   *
   * @param {IDecelerateOptions} [options]
   * @param {number} [options.friction=0.95] - percent to decelerate after movement
   * @param {number} [options.bounce=0.8] - percent to decelerate when past boundaries (only applicable when
   *   viewport.bounce() is active)
   * @param {number} [options.minSpeed=0.01] - minimum velocity before stopping/reversing acceleration
   * @return {Viewport} this
   */
  decelerate(t2) {
    return this.plugins.add("decelerate", new T(this, t2)), this;
  }
  /**
   * Bounce on borders
   * NOTES:
   *    screenWidth, screenHeight, worldWidth, and worldHeight needs to be set for this to work properly
   *    fires 'moved', 'bounce-x-start', 'bounce-y-start', 'bounce-x-end', and 'bounce-y-end' events
   * @param {object} [options]
   * @param {string} [options.sides=all] - all, horizontal, vertical, or combination of top, bottom, right, left
   *  (e.g., 'top-bottom-right')
   * @param {number} [options.friction=0.5] - friction to apply to decelerate if active
   * @param {number} [options.time=150] - time in ms to finish bounce
   * @param {object} [options.bounceBox] - use this bounceBox instead of (0, 0, viewport.worldWidth, viewport.worldHeight)
   * @param {number} [options.bounceBox.x=0]
   * @param {number} [options.bounceBox.y=0]
   * @param {number} [options.bounceBox.width=viewport.worldWidth]
   * @param {number} [options.bounceBox.height=viewport.worldHeight]
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name
   *  (see http://easings.net/ for supported names)
   * @param {string} [options.underflow=center] - (top/bottom/center and left/right/center, or center)
   *  where to place world if too small for screen
   * @return {Viewport} this
   */
  bounce(t2) {
    return this.plugins.add("bounce", new k2(this, t2)), this;
  }
  /**
   * Enable pinch to zoom and two-finger touch to drag
   *
   * @param {PinchOptions} [options]
   * @param {boolean} [options.noDrag] - disable two-finger dragging
   * @param {number} [options.percent=1] - percent to modify pinch speed
   * @param {number} [options.factor=1] - factor to multiply two-finger drag to increase the speed of movement
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of center of two fingers
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  pinch(t2) {
    return this.plugins.add("pinch", new N2(this, t2)), this;
  }
  /**
   * Snap to a point
   *
   * @param {number} x
   * @param {number} y
   * @param {ISnapOptions} [options]
   * @param {boolean} [options.topLeft] - snap to the top-left of viewport instead of center
   * @param {number} [options.friction=0.8] - friction/frame to apply if decelerate is active
   * @param {number} [options.time=1000] - time in ms to snap
   * @param {string|function} [options.ease=easeInOutSine] - ease function or name (see http://easings.net/
   *   for supported names)
   * @param {boolean} [options.interrupt=true] - pause snapping with any user input on the viewport
   * @param {boolean} [options.removeOnComplete] - removes this plugin after snapping is complete
   * @param {boolean} [options.removeOnInterrupt] - removes this plugin if interrupted by any user input
   * @param {boolean} [options.forceStart] - starts the snap immediately regardless of whether the viewport is at
   *   the desired location
   * @return {Viewport} this
   */
  snap(t2, e3, n2) {
    return this.plugins.add("snap", new j2(this, t2, e3, n2)), this;
  }
  /**
   * Follow a target
   *
   * NOTES:
   *    uses the (x, y) as the center to follow; for PIXI.Sprite to work properly, use sprite.anchor.set(0.5)
   *    options.acceleration is not perfect as it doesn't know the velocity of the target. It adds acceleration
   *    to the start of movement and deceleration to the end of movement when the target is stopped.
   *    To cancel the follow, use: `viewport.plugins.remove('follow')`
   *
   * @fires 'moved' event
   *
   * @param {PIXI.DisplayObject} target to follow
   * @param {IFollowOptions} [options]
   * @param {number} [options.speed=0] - to follow in pixels/frame (0=teleport to location)
   * @param {number} [options.acceleration] - set acceleration to accelerate and decelerate at this rate; speed
   *   cannot be 0 to use acceleration
   * @param {number} [options.radius] - radius (in world coordinates) of center circle where movement is allowed
   *   without moving the viewport     * @returns {Viewport} this
   * @returns {Viewport} this
   */
  follow(t2, e3) {
    return this.plugins.add("follow", new U(this, t2, e3)), this;
  }
  /**
   * Zoom using mouse wheel
   *
   * NOTE: the default event listener for 'wheel' event is the options.events.domElement.
   *
   * @param {IWheelOptions} [options]
   * @param {number} [options.percent=0.1] - percent to scroll with each spin
   * @param {number} [options.smooth] - smooth the zooming by providing the number of frames to zoom between wheel spins
   * @param {boolean} [options.interrupt=true] - stop smoothing with any user input on the viewport
   * @param {boolean} [options.reverse] - reverse the direction of the scroll
   * @param {PIXI.Point} [options.center] - place this point at center during zoom instead of current mouse position
   * @param {number} [options.lineHeight=20] - scaling factor for non-DOM_DELTA_PIXEL scrolling events
   * @param {('all'|'x'|'y')} [options.axis=all] - axis to zoom
   * @return {Viewport} this
   */
  wheel(t2) {
    return this.plugins.add("wheel", new G(this, t2)), this;
  }
  /**
   * Animate the position and/or scale of the viewport
   * To set the zoom level, use: (1) scale, (2) scaleX and scaleY, or (3) width and/or height
   * @param {object} options
   * @param {number} [options.time=1000] - time to animate
   * @param {PIXI.Point} [options.position=viewport.center] - position to move viewport
   * @param {number} [options.width] - desired viewport width in world pixels (use instead of scale;
   *  aspect ratio is maintained if height is not provided)
   * @param {number} [options.height] - desired viewport height in world pixels (use instead of scale;
   *  aspect ratio is maintained if width is not provided)
   * @param {number} [options.scale] - scale to change zoom (scale.x = scale.y)
   * @param {number} [options.scaleX] - independently change zoom in x-direction
   * @param {number} [options.scaleY] - independently change zoom in y-direction
   * @param {(function|string)} [options.ease=linear] - easing function to use
   * @param {function} [options.callbackOnComplete]
   * @param {boolean} [options.removeOnInterrupt] removes this plugin if interrupted by any user input
   * @returns {Viewport} this
   */
  animate(t2) {
    return this.plugins.add("animate", new C(this, t2)), this;
  }
  /**
   * Enable clamping of zoom to constraints
   *
   * The minWidth/Height settings are how small the world can get (as it would appear on the screen)
   * before clamping. The maxWidth/maxHeight is how larger the world can scale (as it would appear on
   * the screen) before clamping.
   *
   * For example, if you have a world size of 1000 x 1000 and a screen size of 100 x 100, if you set
   * minWidth/Height = 100 then the world will not be able to zoom smaller than the screen size (ie,
   * zooming out so it appears smaller than the screen). Similarly, if you set maxWidth/Height = 100
   * the world will not be able to zoom larger than the screen size (ie, zooming in so it appears
   * larger than the screen).
   *
   * @param {object} [options]
   * @param {number} [options.minWidth] - minimum width
   * @param {number} [options.minHeight] - minimum height
   * @param {number} [options.maxWidth] - maximum width
   * @param {number} [options.maxHeight] - maximum height
   * @param {number} [options.minScale] - minimum scale
   * @param {number} [options.maxScale] - minimum scale
   * @return {Viewport} this
   */
  clampZoom(t2) {
    return this.plugins.add("clamp-zoom", new A(this, t2)), this;
  }
  /**
   * Scroll viewport when mouse hovers near one of the edges or radius-distance from center of screen.
   *
   * NOTES: fires 'moved' event; there's a known bug where the mouseEdges does not work properly with "windowed" viewports
   *
   * @param {IMouseEdgesOptions} [options]
   * @param {number} [options.radius] - distance from center of screen in screen pixels
   * @param {number} [options.distance] - distance from all sides in screen pixels
   * @param {number} [options.top] - alternatively, set top distance (leave unset for no top scroll)
   * @param {number} [options.bottom] - alternatively, set bottom distance (leave unset for no top scroll)
   * @param {number} [options.left] - alternatively, set left distance (leave unset for no top scroll)
   * @param {number} [options.right] - alternatively, set right distance (leave unset for no top scroll)
   * @param {number} [options.speed=8] - speed in pixels/frame to scroll viewport
   * @param {boolean} [options.reverse] - reverse direction of scroll
   * @param {boolean} [options.noDecelerate] - don't use decelerate plugin even if it's installed
   * @param {boolean} [options.linear] - if using radius, use linear movement (+/- 1, +/- 1) instead of angled
   *   movement (Math.cos(angle from center), Math.sin(angle from center))
   * @param {boolean} [options.allowButtons] allows plugin to continue working even when there's a mousedown event
   */
  mouseEdges(t2) {
    return this.plugins.add("mouse-edges", new B(this, t2)), this;
  }
  /** Pause viewport (including animation updates such as decelerate) */
  get pause() {
    return !!this._pause;
  }
  set pause(t2) {
    this._pause = t2, this.lastViewport = null, this.moving = false, this.zooming = false, t2 && this.input.pause();
  }
  /**
   * Move the viewport so the bounding box is visible
   *
   * @param x - left
   * @param y - top
   * @param width
   * @param height
   * @param resizeToFit - Resize the viewport so the box fits within the viewport
   */
  ensureVisible(t2, e3, n2, i2, s2) {
    s2 && (n2 > this.worldScreenWidth || i2 > this.worldScreenHeight) && (this.fit(true, n2, i2), this.emit("zoomed", { viewport: this, type: "ensureVisible" }));
    let h2 = false;
    t2 < this.left ? (this.left = t2, h2 = true) : t2 + n2 > this.right && (this.right = t2 + n2, h2 = true), e3 < this.top ? (this.top = e3, h2 = true) : e3 + i2 > this.bottom && (this.bottom = e3 + i2, h2 = true), h2 && this.emit("moved", { viewport: this, type: "ensureVisible" });
  }
};

// node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

// node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns") name = name.slice(i2 + 1);
  return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
}

// node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator_default(name) {
  var fullname = namespace_default(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

// node_modules/d3-selection/src/selector.js
function none() {
}
function selector_default(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

// node_modules/d3-selection/src/selection/select.js
function select_default(select) {
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m4 = groups.length, subgroups = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, subgroup = subgroups[j3] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node2 = group[i2]) && (subnode = select.call(node2, node2.__data__, i2, group))) {
        if ("__data__" in node2) subnode.__data__ = node2.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/array.js
function array(x5) {
  return x5 == null ? [] : Array.isArray(x5) ? x5 : Array.from(x5);
}

// node_modules/d3-selection/src/selectorAll.js
function empty() {
  return [];
}
function selectorAll_default(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

// node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}
function selectAll_default(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll_default(select);
  for (var groups = this._groups, m4 = groups.length, subgroups = [], parents = [], j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group[i2]) {
        subgroups.push(select.call(node2, node2.__data__, i2, group));
        parents.push(node2);
      }
    }
  }
  return new Selection(subgroups, parents);
}

// node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
  return function() {
    return this.matches(selector);
  };
}
function childMatcher(selector) {
  return function(node2) {
    return node2.matches(selector);
  };
}

// node_modules/d3-selection/src/selection/selectChild.js
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selectChild_default(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selectChildren_default(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

// node_modules/d3-selection/src/selection/filter.js
function filter_default(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m4 = groups.length, subgroups = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, subgroup = subgroups[j3] = [], node2, i2 = 0; i2 < n2; ++i2) {
      if ((node2 = group[i2]) && match.call(node2, node2.__data__, i2, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}

// node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update) {
  return new Array(update.length);
}

// node_modules/d3-selection/src/selection/enter.js
function enter_default() {
  return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent2, datum2) {
  this.ownerDocument = parent2.ownerDocument;
  this.namespaceURI = parent2.namespaceURI;
  this._next = null;
  this._parent = parent2;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function(selector) {
    return this._parent.querySelectorAll(selector);
  }
};

// node_modules/d3-selection/src/constant.js
function constant_default(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-selection/src/selection/data.js
function bindIndex(parent2, group, enter, update, exit, data) {
  var i2 = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i2 < dataLength; ++i2) {
    if (node2 = group[i2]) {
      node2.__data__ = data[i2];
      update[i2] = node2;
    } else {
      enter[i2] = new EnterNode(parent2, data[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node2 = group[i2]) {
      exit[i2] = node2;
    }
  }
}
function bindKey(parent2, group, enter, update, exit, data, key) {
  var i2, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node2 = group[i2]) {
      keyValues[i2] = keyValue = key.call(node2, node2.__data__, i2, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key.call(parent2, data[i2], i2, data) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update[i2] = node2;
      node2.__data__ = data[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent2, data[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node2 = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node2) {
      exit[i2] = node2;
    }
  }
}
function datum(node2) {
  return node2.__data__;
}
function data_default(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant_default(value);
  for (var m4 = groups.length, update = new Array(m4), enter = new Array(m4), exit = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    var parent2 = parents[j3], group = groups[j3], groupLength = group.length, data = arraylike(value.call(parent2, parent2 && parent2.__data__, j3, parents)), dataLength = data.length, enterGroup = enter[j3] = new Array(dataLength), updateGroup = update[j3] = new Array(dataLength), exitGroup = exit[j3] = new Array(groupLength);
    bind(parent2, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}

// node_modules/d3-selection/src/selection/exit.js
function exit_default() {
  return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
}

// node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

// node_modules/d3-selection/src/selection/merge.js
function merge_default(context2) {
  var selection2 = context2.selection ? context2.selection() : context2;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m4 = Math.min(m0, m1), merges = new Array(m0), j3 = 0; j3 < m4; ++j3) {
    for (var group0 = groups0[j3], group1 = groups1[j3], n2 = group0.length, merge2 = merges[j3] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group0[i2] || group1[i2]) {
        merge2[i2] = node2;
      }
    }
  }
  for (; j3 < m0; ++j3) {
    merges[j3] = groups0[j3];
  }
  return new Selection(merges, this._parents);
}

// node_modules/d3-selection/src/selection/order.js
function order_default() {
  for (var groups = this._groups, j3 = -1, m4 = groups.length; ++j3 < m4; ) {
    for (var group = groups[j3], i2 = group.length - 1, next = group[i2], node2; --i2 >= 0; ) {
      if (node2 = group[i2]) {
        if (next && node2.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node2, next);
        next = node2;
      }
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
  if (!compare) compare = ascending;
  function compareNode(a3, b2) {
    return a3 && b2 ? compare(a3.__data__, b2.__data__) : !a3 - !b2;
  }
  for (var groups = this._groups, m4 = groups.length, sortgroups = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, sortgroup = sortgroups[j3] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group[i2]) {
        sortgroup[i2] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a3, b2) {
  return a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// node_modules/d3-selection/src/selection/call.js
function call_default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

// node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
  return Array.from(this);
}

// node_modules/d3-selection/src/selection/node.js
function node_default() {
  for (var groups = this._groups, j3 = 0, m4 = groups.length; j3 < m4; ++j3) {
    for (var group = groups[j3], i2 = 0, n2 = group.length; i2 < n2; ++i2) {
      var node2 = group[i2];
      if (node2) return node2;
    }
  }
  return null;
}

// node_modules/d3-selection/src/selection/size.js
function size_default() {
  let size = 0;
  for (const node2 of this) ++size;
  return size;
}

// node_modules/d3-selection/src/selection/empty.js
function empty_default() {
  return !this.node();
}

// node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
  for (var groups = this._groups, j3 = 0, m4 = groups.length; j3 < m4; ++j3) {
    for (var group = groups[j3], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2) {
      if (node2 = group[i2]) callback.call(node2, node2.__data__, i2, group);
    }
  }
  return this;
}

// node_modules/d3-selection/src/selection/attr.js
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null) this.removeAttribute(name);
    else this.setAttribute(name, v3);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v3);
  };
}
function attr_default(name, value) {
  var fullname = namespace_default(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}

// node_modules/d3-selection/src/window.js
function window_default(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}

// node_modules/d3-selection/src/selection/style.js
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v3, priority);
  };
}
function style_default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || window_default(node2).getComputedStyle(node2, null).getPropertyValue(name);
}

// node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (v3 == null) delete this[name];
    else this[name] = v3;
  };
}
function property_default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

// node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i2 = this._names.indexOf(name);
    if (i2 >= 0) {
      this._names.splice(i2, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  var list = classList(node2), i2 = -1, n2 = names.length;
  while (++i2 < n2) list.add(names[i2]);
}
function classedRemove(node2, names) {
  var list = classList(node2), i2 = -1, n2 = names.length;
  while (++i2 < n2) list.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function classed_default(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i2 = -1, n2 = names.length;
    while (++i2 < n2) if (!list.contains(names[i2])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}

// node_modules/d3-selection/src/selection/text.js
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.textContent = v3 == null ? "" : v3;
  };
}
function text_default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}

// node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v3 = value.apply(this, arguments);
    this.innerHTML = v3 == null ? "" : v3;
  };
}
function html_default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

// node_modules/d3-selection/src/selection/raise.js
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
  return this.each(raise);
}

// node_modules/d3-selection/src/selection/lower.js
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
  return this.each(lower);
}

// node_modules/d3-selection/src/selection/append.js
function append_default(name) {
  var create2 = typeof name === "function" ? name : creator_default(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}

// node_modules/d3-selection/src/selection/insert.js
function constantNull() {
  return null;
}
function insert_default(name, before) {
  var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

// node_modules/d3-selection/src/selection/remove.js
function remove() {
  var parent2 = this.parentNode;
  if (parent2) parent2.removeChild(this);
}
function remove_default() {
  return this.each(remove);
}

// node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent2 = this.parentNode;
  return parent2 ? parent2.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

// node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

// node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j3 = 0, i2 = -1, m4 = on.length, o2; j3 < m4; ++j3) {
      if (o2 = on[j3], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i2] = o2;
      }
    }
    if (++i2) on.length = i2;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o2, listener = contextListener(value);
    if (on) for (var j3 = 0, m4 = on.length; j3 < m4; ++j3) {
      if ((o2 = on[j3]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
        o2.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o2];
    else on.push(o2);
  };
}
function on_default(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i2, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j3 = 0, m4 = on.length, o2; j3 < m4; ++j3) {
      for (i2 = 0, o2 = on[j3]; i2 < n2; ++i2) {
        if ((t2 = typenames[i2]).type === o2.type && t2.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i2 = 0; i2 < n2; ++i2) this.each(on(typenames[i2], value, options));
  return this;
}

// node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node2, type2, params) {
  var window2 = window_default(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type2, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function dispatch_default(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}

// node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
  for (var groups = this._groups, j3 = 0, m4 = groups.length; j3 < m4; ++j3) {
    for (var group = groups[j3], i2 = 0, n2 = group.length, node2; i2 < n2; ++i2) {
      if (node2 = group[i2]) yield node2;
    }
  }
}

// node_modules/d3-selection/src/selection/index.js
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: select_default,
  selectAll: selectAll_default,
  selectChild: selectChild_default,
  selectChildren: selectChildren_default,
  filter: filter_default,
  data: data_default,
  enter: enter_default,
  exit: exit_default,
  join: join_default,
  merge: merge_default,
  selection: selection_selection,
  order: order_default,
  sort: sort_default,
  call: call_default,
  nodes: nodes_default,
  node: node_default,
  size: size_default,
  empty: empty_default,
  each: each_default,
  attr: attr_default,
  style: style_default,
  property: property_default,
  classed: classed_default,
  text: text_default,
  html: html_default,
  raise: raise_default,
  lower: lower_default,
  append: append_default,
  insert: insert_default,
  remove: remove_default,
  clone: clone_default,
  datum: datum_default,
  on: on_default,
  dispatch: dispatch_default,
  [Symbol.iterator]: iterator_default
};
var selection_default = selection;

// node_modules/d3-selection/src/select.js
function select_default2(selector) {
  return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
}

// node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

// node_modules/d3-selection/src/pointer.js
function pointer_default(event, node2) {
  event = sourceEvent_default(event);
  if (node2 === void 0) node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node2.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// node_modules/d3-array/src/ascending.js
function ascending2(a3, b2) {
  return a3 == null || b2 == null ? NaN : a3 < b2 ? -1 : a3 > b2 ? 1 : a3 >= b2 ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a3, b2) {
  return a3 == null || b2 == null ? NaN : b2 < a3 ? -1 : b2 > a3 ? 1 : b2 >= a3 ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending2;
    compare2 = (d3, x5) => ascending2(f2(d3), x5);
    delta = (d3, x5) => f2(d3) - x5;
  } else {
    compare1 = f2 === ascending2 || f2 === descending ? f2 : zero;
    compare2 = f2;
    delta = f2;
  }
  function left(a3, x5, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x5, x5) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x5) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a3, x5, lo = 0, hi = a3.length) {
    if (lo < hi) {
      if (compare1(x5, x5) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a3[mid], x5) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a3, x5, lo = 0, hi = a3.length) {
    const i2 = left(a3, x5, lo, hi - 1);
    return i2 > lo && delta(a3[i2 - 1], x5) > -delta(a3[i2], x5) ? i2 - 1 : i2;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x5) {
  return x5 === null ? NaN : +x5;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending2);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start2, stop, count2) {
  const step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start2 * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start2) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start2 / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start2) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start2, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start2 === stop) return [start2];
  const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count2) : tickSpec(start2, stop, count2);
  if (!(i2 >= i1)) return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse) {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i2 - i3) * inc;
  } else {
    if (inc < 0) for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) / -inc;
    else for (let i3 = 0; i3 < n2; ++i3) ticks2[i3] = (i1 + i3) * inc;
  }
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  return tickSpec(start2, stop, count2)[2];
}
function tickStep(start2, stop, count2) {
  stop = +stop, start2 = +start2, count2 = +count2;
  const reverse = stop < start2, inc = reverse ? tickIncrement(stop, start2, count2) : tickIncrement(start2, stop, count2);
  return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent2, definition) {
  var prototype = Object.create(parent2.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color2() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color2, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m4, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m4 = reHex.exec(format2)) ? (l2 = m4[1].length, m4 = parseInt(m4[1], 16), l2 === 6 ? rgbn(m4) : l2 === 3 ? new Rgb(m4 >> 8 & 15 | m4 >> 4 & 240, m4 >> 4 & 15 | m4 & 240, (m4 & 15) << 4 | m4 & 15, 1) : l2 === 8 ? rgba(m4 >> 24 & 255, m4 >> 16 & 255, m4 >> 8 & 255, (m4 & 255) / 255) : l2 === 4 ? rgba(m4 >> 12 & 15 | m4 >> 8 & 240, m4 >> 8 & 15 | m4 >> 4 & 240, m4 >> 4 & 15 | m4 & 240, ((m4 & 15) << 4 | m4 & 15) / 255) : null) : (m4 = reRgbInteger.exec(format2)) ? new Rgb(m4[1], m4[2], m4[3], 1) : (m4 = reRgbPercent.exec(format2)) ? new Rgb(m4[1] * 255 / 100, m4[2] * 255 / 100, m4[3] * 255 / 100, 1) : (m4 = reRgbaInteger.exec(format2)) ? rgba(m4[1], m4[2], m4[3], m4[4]) : (m4 = reRgbaPercent.exec(format2)) ? rgba(m4[1] * 255 / 100, m4[2] * 255 / 100, m4[3] * 255 / 100, m4[4]) : (m4 = reHslPercent.exec(format2)) ? hsla(m4[1], m4[2] / 100, m4[3] / 100, 1) : (m4 = reHslaPercent.exec(format2)) ? hsla(m4[1], m4[2] / 100, m4[3] / 100, m4[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a3) {
  if (a3 <= 0) r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a3);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color2)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color2, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a3 = clampa(this.opacity);
  return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a3) {
  if (a3 <= 0) h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1) h2 = s2 = NaN;
  else if (s2 <= 0) h2 = NaN;
  return new Hsl(h2, s2, l2, a3);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color2)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b2 = o2.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2) h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max2) h2 = (b2 - r2) / s2 + 2;
    else h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color2, {
  brighter(k3) {
    k3 = k3 == null ? brighter : Math.pow(brighter, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  darker(k3) {
    k3 = k3 == null ? darker : Math.pow(darker, k3);
    return new Hsl(this.h, this.s, this.l * k3, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m22;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m22),
      hsl2rgb(h2, m1, m22),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m22),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m22) {
  return (h2 < 60 ? m1 + (m22 - m1) * h2 / 60 : h2 < 180 ? m22 : h2 < 240 ? m1 + (m22 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v22, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v22 + t3 * v3) / 6;
}
function basis_default(values2) {
  var n2 = values2.length - 1;
  return function(t2) {
    var i2 = t2 <= 0 ? t2 = 0 : t2 >= 1 ? (t2 = 1, n2 - 1) : Math.floor(t2 * n2), v1 = values2[i2], v22 = values2[i2 + 1], v0 = i2 > 0 ? values2[i2 - 1] : 2 * v1 - v22, v3 = i2 < n2 - 1 ? values2[i2 + 2] : 2 * v22 - v1;
    return basis((t2 - i2 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n2 = values2.length;
  return function(t2) {
    var i2 = Math.floor(((t2 %= 1) < 0 ? ++t2 : t2) * n2), v0 = values2[(i2 + n2 - 1) % n2], v1 = values2[i2 % n2], v22 = values2[(i2 + 1) % n2], v3 = values2[(i2 + 2) % n2];
    return basis((t2 - i2 / n2) * n2, v0, v1, v22, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default2 = (x5) => () => x5;

// node_modules/d3-interpolate/src/color.js
function linear(a3, d3) {
  return function(t2) {
    return a3 + t2 * d3;
  };
}
function exponential(a3, b2, y4) {
  return a3 = Math.pow(a3, y4), b2 = Math.pow(b2, y4) - a3, y4 = 1 / y4, function(t2) {
    return Math.pow(a3 + t2 * b2, y4);
  };
}
function gamma(y4) {
  return (y4 = +y4) === 1 ? nogamma : function(a3, b2) {
    return b2 - a3 ? exponential(a3, b2, y4) : constant_default2(isNaN(a3) ? b2 : a3);
  };
}
function nogamma(a3, b2) {
  var d3 = b2 - a3;
  return d3 ? linear(a3, d3) : constant_default2(isNaN(a3) ? b2 : a3);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y4) {
  var color2 = gamma(y4);
  function rgb2(start2, end) {
    var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color2(start2.g, end.g), b2 = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      start2.r = r2(t2);
      start2.g = g2(t2);
      start2.b = b2(t2);
      start2.opacity = opacity(t2);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r2 = new Array(n2), g2 = new Array(n2), b2 = new Array(n2), i2, color2;
    for (i2 = 0; i2 < n2; ++i2) {
      color2 = rgb(colors[i2]);
      r2[i2] = color2.r || 0;
      g2[i2] = color2.g || 0;
      b2[i2] = color2.b || 0;
    }
    r2 = spline(r2);
    g2 = spline(g2);
    b2 = spline(b2);
    color2.opacity = 1;
    return function(t2) {
      color2.r = r2(t2);
      color2.g = g2(t2);
      color2.b = b2(t2);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a3, b2) {
  if (!b2) b2 = [];
  var n2 = a3 ? Math.min(b2.length, a3.length) : 0, c3 = b2.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n2; ++i2) c3[i2] = a3[i2] * (1 - t2) + b2[i2] * t2;
    return c3;
  };
}
function isNumberArray(x5) {
  return ArrayBuffer.isView(x5) && !(x5 instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a3, b2) {
  var nb = b2 ? b2.length : 0, na = a3 ? Math.min(nb, a3.length) : 0, x5 = new Array(na), c3 = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2) x5[i2] = value_default(a3[i2], b2[i2]);
  for (; i2 < nb; ++i2) c3[i2] = b2[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2) c3[i2] = x5[i2](t2);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a3, b2) {
  var d3 = /* @__PURE__ */ new Date();
  return a3 = +a3, b2 = +b2, function(t2) {
    return d3.setTime(a3 * (1 - t2) + b2 * t2), d3;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t2) {
    return a3 * (1 - t2) + b2 * t2;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a3, b2) {
  var i2 = {}, c3 = {}, k3;
  if (a3 === null || typeof a3 !== "object") a3 = {};
  if (b2 === null || typeof b2 !== "object") b2 = {};
  for (k3 in b2) {
    if (k3 in a3) {
      i2[k3] = value_default(a3[k3], b2[k3]);
    } else {
      c3[k3] = b2[k3];
    }
  }
  return function(t2) {
    for (k3 in i2) c3[k3] = i2[k3](t2);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string_default(a3, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a3 = a3 + "", b2 = b2 + "";
  while ((am = reA.exec(a3)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i2]) s2[i2] += bs;
      else s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2]) s2[i2] += bm;
      else s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i2]) s2[i2] += bs;
    else s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero2(b2) : (b2 = q2.length, function(t2) {
    for (var i3 = 0, o2; i3 < b2; ++i3) s2[(o2 = q2[i3]).i] = o2.x(t2);
    return s2.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a3, b2) {
  var t2 = typeof b2, c3;
  return b2 == null || t2 === "boolean" ? constant_default2(b2) : (t2 === "number" ? number_default : t2 === "string" ? (c3 = color(b2)) ? (b2 = c3, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a3, b2);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a3, b2) {
  return a3 = +a3, b2 = +b2, function(t2) {
    return Math.round(a3 * (1 - t2) + b2 * t2);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a3, b2, c3, d3, e3, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a3 * a3 + b2 * b2)) a3 /= scaleX, b2 /= scaleX;
  if (skewX = a3 * c3 + b2 * d3) c3 -= a3 * skewX, d3 -= b2 * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d3 * d3)) c3 /= scaleY, d3 /= scaleY, skewX /= scaleY;
  if (a3 * d3 < b2 * c3) a3 = -a3, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f2,
    rotate: Math.atan2(b2, a3) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m4 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m4.isIdentity ? identity : decompose_default(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
}
function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a3, b2, s2, q2) {
    if (a3 !== b2) {
      if (a3 - b2 > 180) b2 += 360;
      else if (b2 - a3 > 180) a3 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "rotate(" + b2 + degParen);
    }
  }
  function skewX(a3, b2, s2, q2) {
    if (a3 !== b2) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a3, b2) });
    } else if (b2) {
      s2.push(pop(s2) + "skewX(" + b2 + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q2) {
    if (xa !== xb || ya !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: number_default(xa, xb) }, { i: i2 - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a3, b2) {
    var s2 = [], q2 = [];
    a3 = parse2(a3), b2 = parse2(b2);
    translate(a3.translateX, a3.translateY, b2.translateX, b2.translateY, s2, q2);
    rotate(a3.rotate, b2.rotate, s2, q2);
    skewX(a3.skewX, b2.skewX, s2, q2);
    scale(a3.scaleX, a3.scaleY, b2.scaleX, b2.scaleY, s2, q2);
    a3 = b2 = null;
    return function(t2) {
      var i2 = -1, n2 = q2.length, o2;
      while (++i2 < n2) s2[(o2 = q2[i2]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-scale/src/constant.js
function constants(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x5) {
  return +x5;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity2(x5) {
  return x5;
}
function normalize(a3, b2) {
  return (b2 -= a3 = +a3) ? function(x5) {
    return (x5 - a3) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a3, b2) {
  var t2;
  if (a3 > b2) t2 = a3, a3 = b2, b2 = t2;
  return function(x5) {
    return Math.max(a3, Math.min(b2, x5));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x5) {
    return r0(d0(x5));
  };
}
function polymap(domain, range2, interpolate) {
  var j3 = Math.min(domain.length, range2.length) - 1, d3 = new Array(j3), r2 = new Array(j3), i2 = -1;
  if (domain[j3] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i2 < j3) {
    d3[i2] = normalize(domain[i2], domain[i2 + 1]);
    r2[i2] = interpolate(range2[i2], range2[i2 + 1]);
  }
  return function(x5) {
    var i3 = bisect_default(domain, x5, 1, j3) - 1;
    return r2[i3](d3[i3](x5));
  };
}
function copy(source2, target) {
  return target.domain(source2.domain()).range(source2.range()).interpolate(source2.interpolate()).clamp(source2.clamp()).unknown(source2.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform4, untransform, unknown, clamp = identity2, piecewise, output, input;
  function rescale() {
    var n2 = Math.min(domain.length, range2.length);
    if (clamp !== identity2) clamp = clamper(domain[0], domain[n2 - 1]);
    piecewise = n2 > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x5) {
    return x5 == null || isNaN(x5 = +x5) ? unknown : (output || (output = piecewise(domain.map(transform4), range2, interpolate)))(transform4(clamp(x5)));
  }
  scale.invert = function(y4) {
    return clamp(untransform((input || (input = piecewise(range2, domain.map(transform4), number_default)))(y4)));
  };
  scale.domain = function(_3) {
    return arguments.length ? (domain = Array.from(_3, number2), rescale()) : domain.slice();
  };
  scale.range = function(_3) {
    return arguments.length ? (range2 = Array.from(_3), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_3) {
    return range2 = Array.from(_3), interpolate = round_default, rescale();
  };
  scale.clamp = function(_3) {
    return arguments.length ? (clamp = _3 ? true : identity2, rescale()) : clamp !== identity2;
  };
  scale.interpolate = function(_3) {
    return arguments.length ? (interpolate = _3, rescale()) : interpolate;
  };
  scale.unknown = function(_3) {
    return arguments.length ? (unknown = _3, scale) : unknown;
  };
  return function(t2, u3) {
    transform4 = t2, untransform = u3;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity2, identity2);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x5) {
  return Math.abs(x5 = Math.round(x5)) >= 1e21 ? x5.toLocaleString("en").replace(/,/g, "") : x5.toString(10);
}
function formatDecimalParts(x5, p2) {
  if ((i2 = (x5 = p2 ? x5.toExponential(p2 - 1) : x5.toExponential()).indexOf("e")) < 0) return null;
  var i2, coefficient = x5.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x5.slice(i2 + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x5) {
  return x5 = formatDecimalParts(Math.abs(x5)), x5 ? x5[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i2 = value.length, t2 = [], j3 = 0, g2 = grouping[0], length = 0;
    while (i2 > 0 && g2 > 0) {
      if (length + g2 + 1 > width) g2 = Math.max(1, width - length);
      t2.push(value.substring(i2 -= g2, i2 + g2));
      if ((length += g2 + 1) > width) break;
      g2 = grouping[j3 = (j3 + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s2) {
  out: for (var n2 = s2.length, i2 = 1, i0 = -1, i1; i2 < n2; ++i2) {
    switch (s2[i2]) {
      case ".":
        i0 = i1 = i2;
        break;
      case "0":
        if (i0 === 0) i0 = i2;
        i1 = i2;
        break;
      default:
        if (!+s2[i2]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x5, p2) {
  var d3 = formatDecimalParts(x5, p2);
  if (!d3) return x5 + "";
  var coefficient = d3[0], exponent = d3[1], i2 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
  return i2 === n2 ? coefficient : i2 > n2 ? coefficient + new Array(i2 - n2 + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x5, Math.max(0, p2 + i2 - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x5, p2) {
  var d3 = formatDecimalParts(x5, p2);
  if (!d3) return x5 + "";
  var coefficient = d3[0], exponent = d3[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x5, p2) => (x5 * 100).toFixed(p2),
  "b": (x5) => Math.round(x5).toString(2),
  "c": (x5) => x5 + "",
  "d": formatDecimal_default,
  "e": (x5, p2) => x5.toExponential(p2),
  "f": (x5, p2) => x5.toFixed(p2),
  "g": (x5, p2) => x5.toPrecision(p2),
  "o": (x5) => Math.round(x5).toString(8),
  "p": (x5, p2) => formatRounded_default(x5 * 100, p2),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x5) => Math.round(x5).toString(16).toUpperCase(),
  "x": (x5) => Math.round(x5).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x5) {
  return x5;
}

// node_modules/d3-format/src/locale.js
var map = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n") comma = true, type2 = "g";
    else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n2, c3;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n2 = value.length;
          while (++i2 < n2) {
            if (c3 = value.charCodeAt(i2), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value.slice(i2 + 1) : value.slice(i2)) + valueSuffix;
              value = value.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero3) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f2(k3 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start2), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d3 = domain();
    return ticks(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d3 = domain();
    return tickFormat(d3[0], d3[d3.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d3 = domain();
    var i0 = 0;
    var i1 = d3.length - 1;
    var start2 = d3[i0];
    var stop = d3[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d3[i0] = start2;
        d3[i1] = stop;
        return domain(d3);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear2() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear2());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}

// node_modules/d3-polygon/src/contains.js
function contains_default(polygon, point) {
  var n2 = polygon.length, p2 = polygon[n2 - 1], x5 = point[0], y4 = point[1], x0 = p2[0], y0 = p2[1], x1, y1, inside = false;
  for (var i2 = 0; i2 < n2; ++i2) {
    p2 = polygon[i2], x1 = p2[0], y1 = p2[1];
    if (y1 > y4 !== y0 > y4 && x5 < (x0 - x1) * (y4 - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }
  return inside;
}

// node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {
} };
function dispatch() {
  for (var i2 = 0, n2 = arguments.length, _3 = {}, t2; i2 < n2; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _3 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _3[t2] = [];
  }
  return new Dispatch(_3);
}
function Dispatch(_3) {
  this._ = _3;
}
function parseTypenames2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0) name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _3 = this._, T2 = parseTypenames2(typename + "", _3), t2, i2 = -1, n2 = T2.length;
    if (arguments.length < 2) {
      while (++i2 < n2) if ((t2 = (typename = T2[i2]).type) && (t2 = get(_3[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i2 < n2) {
      if (t2 = (typename = T2[i2]).type) _3[t2] = set(_3[t2], typename.name, callback);
      else if (callback == null) for (t2 in _3) _3[t2] = set(_3[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _3 = this._;
    for (var t2 in _3) copy2[t2] = _3[t2].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i2 = 0, n2, t2; i2 < n2; ++i2) args[i2] = arguments[i2 + 2];
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (t2 = this._[type2], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
    for (var t2 = this._[type2], i2 = 0, n2 = t2.length; i2 < n2; ++i2) t2[i2].value.apply(that, args);
  }
};
function get(type2, name) {
  for (var i2 = 0, n2 = type2.length, c3; i2 < n2; ++i2) {
    if ((c3 = type2[i2]).name === name) {
      return c3.value;
    }
  }
}
function set(type2, name, callback) {
  for (var i2 = 0, n2 = type2.length; i2 < n2; ++i2) {
    if (type2[i2].name === name) {
      type2[i2] = noop, type2 = type2.slice(0, i2).concat(type2.slice(i2 + 1));
      break;
    }
  }
  if (callback != null) type2.push({ name, value: callback });
  return type2;
}
var dispatch_default2 = dispatch;

// node_modules/d3-drag/src/noevent.js
var nonpassive = { passive: false };
var nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent_default(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", noevent_default, nonpassivecapture);
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", noevent_default, nonpassivecapture);
  } else {
    root3.__noselect = root3.style.MozUserSelect;
    root3.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root3 = view.document.documentElement, selection2 = select_default2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent_default, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root3) {
    selection2.on("selectstart.drag", null);
  } else {
    root3.style.MozUserSelect = root3.__noselect;
    delete root3.__noselect;
  }
}

// node_modules/d3-drag/src/constant.js
var constant_default3 = (x5) => () => x5;

// node_modules/d3-drag/src/event.js
function DragEvent(type2, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x: x5,
  y: y4,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x5, enumerable: true, configurable: true },
    y: { value: y4, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// node_modules/d3-drag/src/drag.js
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d3) {
  return d3 == null ? { x: event.x, y: event.y } : d3;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
  var filter3 = defaultFilter, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch_default2("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d3) {
    if (touchending || !filter3.call(this, event, d3)) return;
    var gesture = beforestart(this, container.call(this, event, d3), event, d3, "mouse");
    if (!gesture) return;
    select_default2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag_default(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent_default(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select_default2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent_default(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d3) {
    if (!filter3.call(this, event, d3)) return;
    var touches = event.changedTouches, c3 = container.call(this, event, d3), n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = beforestart(this, c3, event, d3, touches[i2].identifier, touches[i2])) {
        nopropagation(event);
        gesture("start", event, touches[i2]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        noevent_default(event);
        gesture("drag", event, touches[i2]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n2 = touches.length, i2, gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i2 = 0; i2 < n2; ++i2) {
      if (gesture = gestures[touches[i2].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i2]);
      }
    }
  }
  function beforestart(that, container2, event, d3, identifier, touch) {
    var dispatch2 = listeners.copy(), p2 = pointer_default(touch || event, container2), dx, dy, s2;
    if ((s2 = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag,
      identifier,
      active,
      x: p2[0],
      y: p2[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d3)) == null) return;
    dx = s2.x - p2[0] || 0;
    dy = s2.y - p2[1] || 0;
    return function gesture(type2, event2, touch2) {
      var p0 = p2, n2;
      switch (type2) {
        case "start":
          gestures[identifier] = gesture, n2 = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p2 = pointer_default(touch2 || event2, container2), n2 = active;
          break;
      }
      dispatch2.call(
        type2,
        that,
        new DragEvent(type2, {
          sourceEvent: event2,
          subject: s2,
          target: drag,
          identifier,
          active: n2,
          x: p2[0] + dx,
          y: p2[1] + dy,
          dx: p2[0] - p0[0],
          dy: p2[1] - p0[1],
          dispatch: dispatch2
        }),
        d3
      );
    };
  }
  drag.filter = function(_3) {
    return arguments.length ? (filter3 = typeof _3 === "function" ? _3 : constant_default3(!!_3), drag) : filter3;
  };
  drag.container = function(_3) {
    return arguments.length ? (container = typeof _3 === "function" ? _3 : constant_default3(_3), drag) : container;
  };
  drag.subject = function(_3) {
    return arguments.length ? (subject = typeof _3 === "function" ? _3 : constant_default3(_3), drag) : subject;
  };
  drag.touchable = function(_3) {
    return arguments.length ? (touchable = typeof _3 === "function" ? _3 : constant_default3(!!_3), drag) : touchable;
  };
  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };
  drag.clickDistance = function(_3) {
    return arguments.length ? (clickDistance2 = (_3 = +_3) * _3, drag) : Math.sqrt(clickDistance2);
  };
  return drag;
}

// node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e3;
  while (t2) {
    if ((e3 = clockNow - t2._time) >= 0) t2._call.call(void 0, e3);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t2;
}

// node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default2("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node2, name, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules) node2.__transition = {};
  else if (id2 in schedules) return;
  create(node2, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node2, id2) {
  var schedule = get2(node2, id2);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}
function set2(node2, id2) {
  var schedule = get2(node2, id2);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}
function get2(node2, id2) {
  var schedule = node2.__transition;
  if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
  return schedule;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule, 0, self2.time);
  function schedule(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed) start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j3, n2, o2;
    if (self2.state !== SCHEDULED) return stop();
    for (i2 in schedules) {
      o2 = schedules[i2];
      if (o2.name !== self2.name) continue;
      if (o2.state === STARTED) return timeout_default(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node2, node2.__data__, o2.index, o2.group);
        delete schedules[i2];
      } else if (+i2 < id2) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node2, node2.__data__, o2.index, o2.group);
        delete schedules[i2];
      }
    }
    timeout_default(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n2 = self2.tween.length);
    for (i2 = 0, j3 = -1; i2 < n2; ++i2) {
      if (o2 = self2.tween[i2].value.call(node2, node2.__data__, self2.index, self2.group)) {
        tween[++j3] = o2;
      }
    }
    tween.length = j3 + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n2 = tween.length;
    while (++i2 < n2) {
      tween[i2].call(node2, t2);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i2 in schedules) return;
    delete node2.__transition;
  }
}

// node_modules/d3-transition/src/interrupt.js
function interrupt_default(node2, name) {
  var schedules = node2.__transition, schedule, active, empty2 = true, i2;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i2 in schedules) {
    if ((schedule = schedules[i2]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule.index, schedule.group);
    delete schedules[i2];
  }
  if (empty2) delete node2.__transition;
}

// node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default2(name) {
  return this.each(function() {
    interrupt_default(this, name);
  });
}

// node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i2, 1);
          break;
        }
      }
    }
    schedule.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule = set2(this, id2), tween = schedule.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i2 = 0, n2 = tween1.length; i2 < n2; ++i2) {
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      }
      if (i2 === n2) tween1.push(t2);
    }
    schedule.tween = tween1;
  };
}
function tween_default(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get2(this.node(), id2).tween;
    for (var i2 = 0, n2 = tween.length, t2; i2 < n2; ++i2) {
      if ((t2 = tween[i2]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule = set2(this, id2);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node2) {
    return get2(node2, id2).value[name];
  };
}

// node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a3, b2) {
  var c3;
  return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c3 = color(b2)) ? (b2 = c3, rgb_default) : string_default)(a3, b2);
}

// node_modules/d3-transition/src/transition/attr.js
function attrRemove2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrConstantNS2(fullname, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function attrFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attrFunctionNS2(fullname, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function attr_default2(name, value) {
  var fullname = namespace_default(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i2, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i2, value));
}

// node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t0 = (i0 = i2) && attrInterpolateNS(fullname, i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t0 = (i0 = i2) && attrInterpolate(name, i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween_default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace_default(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

// node_modules/d3-transition/src/transition/delay.js
function delayFunction(id2, value) {
  return function() {
    init2(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init2(this, id2).delay = value;
  };
}
function delay_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
}

// node_modules/d3-transition/src/transition/duration.js
function durationFunction(id2, value) {
  return function() {
    set2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set2(this, id2).duration = value;
  };
}
function duration_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
}

// node_modules/d3-transition/src/transition/ease.js
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set2(this, id2).ease = value;
  };
}
function ease_default(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
}

// node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id2, value) {
  return function() {
    var v3 = value.apply(this, arguments);
    if (typeof v3 !== "function") throw new Error();
    set2(this, id2).ease = v3;
  };
}
function easeVarying_default(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}

// node_modules/d3-transition/src/transition/filter.js
function filter_default2(match) {
  if (typeof match !== "function") match = matcher_default(match);
  for (var groups = this._groups, m4 = groups.length, subgroups = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, subgroup = subgroups[j3] = [], node2, i2 = 0; i2 < n2; ++i2) {
      if ((node2 = group[i2]) && match.call(node2, node2.__data__, i2, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/merge.js
function merge_default2(transition2) {
  if (transition2._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m4 = Math.min(m0, m1), merges = new Array(m0), j3 = 0; j3 < m4; ++j3) {
    for (var group0 = groups0[j3], group1 = groups1[j3], n2 = group0.length, merge2 = merges[j3] = new Array(n2), node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group0[i2] || group1[i2]) {
        merge2[i2] = node2;
      }
    }
  }
  for (; j3 < m0; ++j3) {
    merges[j3] = groups0[j3];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}

// node_modules/d3-transition/src/transition/on.js
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    if (i2 >= 0) t2 = t2.slice(0, i2);
    return !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set2;
  return function() {
    var schedule = sit(this, id2), on = schedule.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}
function on_default2(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}

// node_modules/d3-transition/src/transition/remove.js
function removeFunction(id2) {
  return function() {
    var parent2 = this.parentNode;
    for (var i2 in this.__transition) if (+i2 !== id2) return;
    if (parent2) parent2.removeChild(this);
  };
}
function remove_default2() {
  return this.on("end.remove", removeFunction(this._id));
}

// node_modules/d3-transition/src/transition/select.js
function select_default3(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selector_default(select);
  for (var groups = this._groups, m4 = groups.length, subgroups = new Array(m4), j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, subgroup = subgroups[j3] = new Array(n2), node2, subnode, i2 = 0; i2 < n2; ++i2) {
      if ((node2 = group[i2]) && (subnode = select.call(node2, node2.__data__, i2, group))) {
        if ("__data__" in node2) subnode.__data__ = node2.__data__;
        subgroup[i2] = subnode;
        schedule_default(subgroup[i2], name, id2, i2, subgroup, get2(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}

// node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default2(select) {
  var name = this._name, id2 = this._id;
  if (typeof select !== "function") select = selectorAll_default(select);
  for (var groups = this._groups, m4 = groups.length, subgroups = [], parents = [], j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group[i2]) {
        for (var children2 = select.call(node2, node2.__data__, i2, group), child, inherit2 = get2(node2, id2), k3 = 0, l2 = children2.length; k3 < l2; ++k3) {
          if (child = children2[k3]) {
            schedule_default(child, name, id2, k3, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}

// node_modules/d3-transition/src/transition/selection.js
var Selection2 = selection_default.prototype.constructor;
function selection_default2() {
  return new Selection2(this._groups, this._parents);
}

// node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}
function styleRemove2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant2(name, interpolate, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
  };
}
function styleFunction2(name, interpolate, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove3;
  return function() {
    var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove3 || (remove3 = styleRemove2(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule.on = on1;
  };
}
function style_default2(name, value, priority) {
  var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
  return value == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i2, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i2, value), priority).on("end.style." + name, null);
}

// node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t2 = (i0 = i2) && styleInterpolate(name, i2, priority);
    return t2;
  }
  tween._value = value;
  return tween;
}
function styleTween_default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

// node_modules/d3-transition/src/transition/text.js
function textConstant2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function text_default2(value) {
  return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
}

// node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i2 = value.apply(this, arguments);
    if (i2 !== i0) t0 = (i0 = i2) && textInterpolate(i2);
    return t0;
  }
  tween._value = value;
  return tween;
}
function textTween_default(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}

// node_modules/d3-transition/src/transition/transition.js
function transition_default() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m4 = groups.length, j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group[i2]) {
        var inherit2 = get2(node2, id0);
        schedule_default(node2, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}

// node_modules/d3-transition/src/transition/end.js
function end_default() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule = set2(this, id2), on = schedule.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule.on = on1;
    });
    if (size === 0) resolve();
  });
}

// node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function transition(name) {
  return selection_default().transition(name);
}
function newId() {
  return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: select_default3,
  selectAll: selectAll_default2,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: filter_default2,
  merge: merge_default2,
  selection: selection_default2,
  transition: transition_default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: on_default2,
  attr: attr_default2,
  attrTween: attrTween_default,
  style: style_default2,
  styleTween: styleTween_default,
  text: text_default2,
  textTween: textTween_default,
  remove: remove_default2,
  tween: tween_default,
  delay: delay_default,
  duration: duration_default,
  ease: ease_default,
  easeVarying: easeVarying_default,
  end: end_default,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

// node_modules/d3-ease/src/cubic.js
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}

// node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function transition_default2(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m4 = groups.length, j3 = 0; j3 < m4; ++j3) {
    for (var group = groups[j3], n2 = group.length, node2, i2 = 0; i2 < n2; ++i2) {
      if (node2 = group[i2]) {
        schedule_default(node2, name, id2, i2, group, timing || inherit(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}

// node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default2;
selection_default.prototype.transition = transition_default2;

// node_modules/d3-brush/src/brush.js
var { abs, max, min } = Math;
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number22(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
var X2 = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x5, e3) {
    return x5 == null ? null : [[+x5[0], e3[0][1]], [+x5[1], e3[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y2 = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y4, e3) {
    return y4 == null ? null : [[e3[0][0], +y4[0]], [e3[1][0], +y4[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) {
    return xy == null ? null : number22(xy);
  },
  output: function(xy) {
    return xy;
  }
};
function type(t2) {
  return { type: t2 };
}

// node_modules/d3-force/src/index.js
var src_exports = {};
__export(src_exports, {
  forceCenter: () => center_default,
  forceCollide: () => collide_default,
  forceLink: () => link_default,
  forceManyBody: () => manyBody_default,
  forceRadial: () => radial_default,
  forceSimulation: () => simulation_default,
  forceX: () => x_default2,
  forceY: () => y_default2
});

// node_modules/d3-force/src/center.js
function center_default(x5, y4) {
  var nodes, strength = 1;
  if (x5 == null) x5 = 0;
  if (y4 == null) y4 = 0;
  function force() {
    var i2, n2 = nodes.length, node2, sx = 0, sy = 0;
    for (i2 = 0; i2 < n2; ++i2) {
      node2 = nodes[i2], sx += node2.x, sy += node2.y;
    }
    for (sx = (sx / n2 - x5) * strength, sy = (sy / n2 - y4) * strength, i2 = 0; i2 < n2; ++i2) {
      node2 = nodes[i2], node2.x -= sx, node2.y -= sy;
    }
  }
  force.initialize = function(_3) {
    nodes = _3;
  };
  force.x = function(_3) {
    return arguments.length ? (x5 = +_3, force) : x5;
  };
  force.y = function(_3) {
    return arguments.length ? (y4 = +_3, force) : y4;
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = +_3, force) : strength;
  };
  return force;
}

// node_modules/d3-quadtree/src/add.js
function add_default(d3) {
  const x5 = +this._x.call(null, d3), y4 = +this._y.call(null, d3);
  return add(this.cover(x5, y4), x5, y4, d3);
}
function add(tree, x5, y4, d3) {
  if (isNaN(x5) || isNaN(y4)) return tree;
  var parent2, node2 = tree._root, leaf = { data: d3 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i2, j3;
  if (!node2) return tree._root = leaf, tree;
  while (node2.length) {
    if (right = x5 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (parent2 = node2, !(node2 = node2[i2 = bottom << 1 | right])) return parent2[i2] = leaf, tree;
  }
  xp = +tree._x.call(null, node2.data);
  yp = +tree._y.call(null, node2.data);
  if (x5 === xp && y4 === yp) return leaf.next = node2, parent2 ? parent2[i2] = leaf : tree._root = leaf, tree;
  do {
    parent2 = parent2 ? parent2[i2] = new Array(4) : tree._root = new Array(4);
    if (right = x5 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
  } while ((i2 = bottom << 1 | right) === (j3 = (yp >= ym) << 1 | xp >= xm));
  return parent2[j3] = node2, parent2[i2] = leaf, tree;
}
function addAll(data) {
  var d3, i2, n2 = data.length, x5, y4, xz = new Array(n2), yz = new Array(n2), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
  for (i2 = 0; i2 < n2; ++i2) {
    if (isNaN(x5 = +this._x.call(null, d3 = data[i2])) || isNaN(y4 = +this._y.call(null, d3))) continue;
    xz[i2] = x5;
    yz[i2] = y4;
    if (x5 < x0) x0 = x5;
    if (x5 > x1) x1 = x5;
    if (y4 < y0) y0 = y4;
    if (y4 > y1) y1 = y4;
  }
  if (x0 > x1 || y0 > y1) return this;
  this.cover(x0, y0).cover(x1, y1);
  for (i2 = 0; i2 < n2; ++i2) {
    add(this, xz[i2], yz[i2], data[i2]);
  }
  return this;
}

// node_modules/d3-quadtree/src/cover.js
function cover_default(x5, y4) {
  if (isNaN(x5 = +x5) || isNaN(y4 = +y4)) return this;
  var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x5)) + 1;
    y1 = (y0 = Math.floor(y4)) + 1;
  } else {
    var z2 = x1 - x0 || 1, node2 = this._root, parent2, i2;
    while (x0 > x5 || x5 >= x1 || y0 > y4 || y4 >= y1) {
      i2 = (y4 < y0) << 1 | x5 < x0;
      parent2 = new Array(4), parent2[i2] = node2, node2 = parent2, z2 *= 2;
      switch (i2) {
        case 0:
          x1 = x0 + z2, y1 = y0 + z2;
          break;
        case 1:
          x0 = x1 - z2, y1 = y0 + z2;
          break;
        case 2:
          x1 = x0 + z2, y0 = y1 - z2;
          break;
        case 3:
          x0 = x1 - z2, y0 = y1 - z2;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node2;
  }
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

// node_modules/d3-quadtree/src/data.js
function data_default2() {
  var data = [];
  this.visit(function(node2) {
    if (!node2.length) do
      data.push(node2.data);
    while (node2 = node2.next);
  });
  return data;
}

// node_modules/d3-quadtree/src/extent.js
function extent_default(_3) {
  return arguments.length ? this.cover(+_3[0][0], +_3[0][1]).cover(+_3[1][0], +_3[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

// node_modules/d3-quadtree/src/quad.js
function quad_default(node2, x0, y0, x1, y1) {
  this.node = node2;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

// node_modules/d3-quadtree/src/find.js
function find_default(x5, y4, radius) {
  var data, x0 = this._x0, y0 = this._y0, x1, y1, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node2 = this._root, q2, i2;
  if (node2) quads.push(new quad_default(node2, x0, y0, x32, y32));
  if (radius == null) radius = Infinity;
  else {
    x0 = x5 - radius, y0 = y4 - radius;
    x32 = x5 + radius, y32 = y4 + radius;
    radius *= radius;
  }
  while (q2 = quads.pop()) {
    if (!(node2 = q2.node) || (x1 = q2.x0) > x32 || (y1 = q2.y0) > y32 || (x22 = q2.x1) < x0 || (y22 = q2.y1) < y0) continue;
    if (node2.length) {
      var xm = (x1 + x22) / 2, ym = (y1 + y22) / 2;
      quads.push(
        new quad_default(node2[3], xm, ym, x22, y22),
        new quad_default(node2[2], x1, ym, xm, y22),
        new quad_default(node2[1], xm, y1, x22, ym),
        new quad_default(node2[0], x1, y1, xm, ym)
      );
      if (i2 = (y4 >= ym) << 1 | x5 >= xm) {
        q2 = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i2];
        quads[quads.length - 1 - i2] = q2;
      }
    } else {
      var dx = x5 - +this._x.call(null, node2.data), dy = y4 - +this._y.call(null, node2.data), d22 = dx * dx + dy * dy;
      if (d22 < radius) {
        var d3 = Math.sqrt(radius = d22);
        x0 = x5 - d3, y0 = y4 - d3;
        x32 = x5 + d3, y32 = y4 + d3;
        data = node2.data;
      }
    }
  }
  return data;
}

// node_modules/d3-quadtree/src/remove.js
function remove_default3(d3) {
  if (isNaN(x5 = +this._x.call(null, d3)) || isNaN(y4 = +this._y.call(null, d3))) return this;
  var parent2, node2 = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x5, y4, xm, ym, right, bottom, i2, j3;
  if (!node2) return this;
  if (node2.length) while (true) {
    if (right = x5 >= (xm = (x0 + x1) / 2)) x0 = xm;
    else x1 = xm;
    if (bottom = y4 >= (ym = (y0 + y1) / 2)) y0 = ym;
    else y1 = ym;
    if (!(parent2 = node2, node2 = node2[i2 = bottom << 1 | right])) return this;
    if (!node2.length) break;
    if (parent2[i2 + 1 & 3] || parent2[i2 + 2 & 3] || parent2[i2 + 3 & 3]) retainer = parent2, j3 = i2;
  }
  while (node2.data !== d3) if (!(previous = node2, node2 = node2.next)) return this;
  if (next = node2.next) delete node2.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent2) return this._root = next, this;
  next ? parent2[i2] = next : delete parent2[i2];
  if ((node2 = parent2[0] || parent2[1] || parent2[2] || parent2[3]) && node2 === (parent2[3] || parent2[2] || parent2[1] || parent2[0]) && !node2.length) {
    if (retainer) retainer[j3] = node2;
    else this._root = node2;
  }
  return this;
}
function removeAll(data) {
  for (var i2 = 0, n2 = data.length; i2 < n2; ++i2) this.remove(data[i2]);
  return this;
}

// node_modules/d3-quadtree/src/root.js
function root_default() {
  return this._root;
}

// node_modules/d3-quadtree/src/size.js
function size_default2() {
  var size = 0;
  this.visit(function(node2) {
    if (!node2.length) do
      ++size;
    while (node2 = node2.next);
  });
  return size;
}

// node_modules/d3-quadtree/src/visit.js
function visit_default(callback) {
  var quads = [], q2, node2 = this._root, child, x0, y0, x1, y1;
  if (node2) quads.push(new quad_default(node2, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    if (!callback(node2 = q2.node, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1) && node2.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node2[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
      if (child = node2[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node2[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node2[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
    }
  }
  return this;
}

// node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default(callback) {
  var quads = [], next = [], q2;
  if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q2 = quads.pop()) {
    var node2 = q2.node;
    if (node2.length) {
      var child, x0 = q2.x0, y0 = q2.y0, x1 = q2.x1, y1 = q2.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node2[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
      if (child = node2[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
      if (child = node2[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
      if (child = node2[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
    }
    next.push(q2);
  }
  while (q2 = next.pop()) {
    callback(q2.node, q2.x0, q2.y0, q2.x1, q2.y1);
  }
  return this;
}

// node_modules/d3-quadtree/src/x.js
function defaultX(d3) {
  return d3[0];
}
function x_default(_3) {
  return arguments.length ? (this._x = _3, this) : this._x;
}

// node_modules/d3-quadtree/src/y.js
function defaultY(d3) {
  return d3[1];
}
function y_default(_3) {
  return arguments.length ? (this._y = _3, this) : this._y;
}

// node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x5, y4) {
  var tree = new Quadtree(x5 == null ? defaultX : x5, y4 == null ? defaultY : y4, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x5, y4, x0, y0, x1, y1) {
  this._x = x5;
  this._y = y4;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next = copy2;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy2;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node2 = this._root, nodes, child;
  if (!node2) return copy2;
  if (!node2.length) return copy2._root = leaf_copy(node2), copy2;
  nodes = [{ source: node2, target: copy2._root = new Array(4) }];
  while (node2 = nodes.pop()) {
    for (var i2 = 0; i2 < 4; ++i2) {
      if (child = node2.source[i2]) {
        if (child.length) nodes.push({ source: child, target: node2.target[i2] = new Array(4) });
        else node2.target[i2] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default2;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.remove = remove_default3;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default2;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;

// node_modules/d3-force/src/constant.js
function constant_default5(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-force/src/jiggle.js
function jiggle_default(random) {
  return (random() - 0.5) * 1e-6;
}

// node_modules/d3-force/src/collide.js
function x3(d3) {
  return d3.x + d3.vx;
}
function y2(d3) {
  return d3.y + d3.vy;
}
function collide_default(radius) {
  var nodes, radii, random, strength = 1, iterations = 1;
  if (typeof radius !== "function") radius = constant_default5(radius == null ? 1 : +radius);
  function force() {
    var i2, n2 = nodes.length, tree, node2, xi, yi, ri, ri2;
    for (var k3 = 0; k3 < iterations; ++k3) {
      tree = quadtree(nodes, x3, y2).visitAfter(prepare);
      for (i2 = 0; i2 < n2; ++i2) {
        node2 = nodes[i2];
        ri = radii[node2.index], ri2 = ri * ri;
        xi = node2.x + node2.vx;
        yi = node2.y + node2.vy;
        tree.visit(apply2);
      }
    }
    function apply2(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r2 = ri + rj;
      if (data) {
        if (data.index > node2.index) {
          var x5 = xi - data.x - data.vx, y4 = yi - data.y - data.vy, l2 = x5 * x5 + y4 * y4;
          if (l2 < r2 * r2) {
            if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
            if (y4 === 0) y4 = jiggle_default(random), l2 += y4 * y4;
            l2 = (r2 - (l2 = Math.sqrt(l2))) / l2 * strength;
            node2.vx += (x5 *= l2) * (r2 = (rj *= rj) / (ri2 + rj));
            node2.vy += (y4 *= l2) * r2;
            data.vx -= x5 * (r2 = 1 - r2);
            data.vy -= y4 * r2;
          }
        }
        return;
      }
      return x0 > xi + r2 || x1 < xi - r2 || y0 > yi + r2 || y1 < yi - r2;
    }
  }
  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i2 = quad.r = 0; i2 < 4; ++i2) {
      if (quad[i2] && quad[i2].r > quad.r) {
        quad.r = quad[i2].r;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node2;
    radii = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], radii[node2.index] = +radius(node2, i2, nodes);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.iterations = function(_3) {
    return arguments.length ? (iterations = +_3, force) : iterations;
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = +_3, force) : strength;
  };
  force.radius = function(_3) {
    return arguments.length ? (radius = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : radius;
  };
  return force;
}

// node_modules/d3-force/src/link.js
function index(d3) {
  return d3.index;
}
function find2(nodeById, nodeId) {
  var node2 = nodeById.get(nodeId);
  if (!node2) throw new Error("node not found: " + nodeId);
  return node2;
}
function link_default(links) {
  var id2 = index, strength = defaultStrength, strengths, distance2 = constant_default5(30), distances, nodes, count2, bias, random, iterations = 1;
  if (links == null) links = [];
  function defaultStrength(link) {
    return 1 / Math.min(count2[link.source.index], count2[link.target.index]);
  }
  function force(alpha) {
    for (var k3 = 0, n2 = links.length; k3 < iterations; ++k3) {
      for (var i2 = 0, link, source2, target, x5, y4, l2, b2; i2 < n2; ++i2) {
        link = links[i2], source2 = link.source, target = link.target;
        x5 = target.x + target.vx - source2.x - source2.vx || jiggle_default(random);
        y4 = target.y + target.vy - source2.y - source2.vy || jiggle_default(random);
        l2 = Math.sqrt(x5 * x5 + y4 * y4);
        l2 = (l2 - distances[i2]) / l2 * alpha * strengths[i2];
        x5 *= l2, y4 *= l2;
        target.vx -= x5 * (b2 = bias[i2]);
        target.vy -= y4 * b2;
        source2.vx += x5 * (b2 = 1 - b2);
        source2.vy += y4 * b2;
      }
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, m4 = links.length, nodeById = new Map(nodes.map((d3, i3) => [id2(d3, i3, nodes), d3])), link;
    for (i2 = 0, count2 = new Array(n2); i2 < m4; ++i2) {
      link = links[i2], link.index = i2;
      if (typeof link.source !== "object") link.source = find2(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find2(nodeById, link.target);
      count2[link.source.index] = (count2[link.source.index] || 0) + 1;
      count2[link.target.index] = (count2[link.target.index] || 0) + 1;
    }
    for (i2 = 0, bias = new Array(m4); i2 < m4; ++i2) {
      link = links[i2], bias[i2] = count2[link.source.index] / (count2[link.source.index] + count2[link.target.index]);
    }
    strengths = new Array(m4), initializeStrength();
    distances = new Array(m4), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      strengths[i2] = +strength(links[i2], i2, links);
    }
  }
  function initializeDistance() {
    if (!nodes) return;
    for (var i2 = 0, n2 = links.length; i2 < n2; ++i2) {
      distances[i2] = +distance2(links[i2], i2, links);
    }
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.links = function(_3) {
    return arguments.length ? (links = _3, initialize(), force) : links;
  };
  force.id = function(_3) {
    return arguments.length ? (id2 = _3, force) : id2;
  };
  force.iterations = function(_3) {
    return arguments.length ? (iterations = +_3, force) : iterations;
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = typeof _3 === "function" ? _3 : constant_default5(+_3), initializeStrength(), force) : strength;
  };
  force.distance = function(_3) {
    return arguments.length ? (distance2 = typeof _3 === "function" ? _3 : constant_default5(+_3), initializeDistance(), force) : distance2;
  };
  return force;
}

// node_modules/d3-force/src/lcg.js
var a2 = 1664525;
var c2 = 1013904223;
var m3 = 4294967296;
function lcg_default() {
  let s2 = 1;
  return () => (s2 = (a2 * s2 + c2) % m3) / m3;
}

// node_modules/d3-force/src/simulation.js
function x4(d3) {
  return d3.x;
}
function y3(d3) {
  return d3.y;
}
var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation_default(nodes) {
  var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default2("tick", "end"), random = lcg_default();
  if (nodes == null) nodes = [];
  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }
  function tick(iterations) {
    var i2, n2 = nodes.length, node2;
    if (iterations === void 0) iterations = 1;
    for (var k3 = 0; k3 < iterations; ++k3) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.forEach(function(force) {
        force(alpha);
      });
      for (i2 = 0; i2 < n2; ++i2) {
        node2 = nodes[i2];
        if (node2.fx == null) node2.x += node2.vx *= velocityDecay;
        else node2.x = node2.fx, node2.vx = 0;
        if (node2.fy == null) node2.y += node2.vy *= velocityDecay;
        else node2.y = node2.fy, node2.vy = 0;
      }
    }
    return simulation;
  }
  function initializeNodes() {
    for (var i2 = 0, n2 = nodes.length, node2; i2 < n2; ++i2) {
      node2 = nodes[i2], node2.index = i2;
      if (node2.fx != null) node2.x = node2.fx;
      if (node2.fy != null) node2.y = node2.fy;
      if (isNaN(node2.x) || isNaN(node2.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i2), angle = i2 * initialAngle;
        node2.x = radius * Math.cos(angle);
        node2.y = radius * Math.sin(angle);
      }
      if (isNaN(node2.vx) || isNaN(node2.vy)) {
        node2.vx = node2.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }
  initializeNodes();
  return simulation = {
    tick,
    restart: function() {
      return stepper.restart(step), simulation;
    },
    stop: function() {
      return stepper.stop(), simulation;
    },
    nodes: function(_3) {
      return arguments.length ? (nodes = _3, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },
    alpha: function(_3) {
      return arguments.length ? (alpha = +_3, simulation) : alpha;
    },
    alphaMin: function(_3) {
      return arguments.length ? (alphaMin = +_3, simulation) : alphaMin;
    },
    alphaDecay: function(_3) {
      return arguments.length ? (alphaDecay = +_3, simulation) : +alphaDecay;
    },
    alphaTarget: function(_3) {
      return arguments.length ? (alphaTarget = +_3, simulation) : alphaTarget;
    },
    velocityDecay: function(_3) {
      return arguments.length ? (velocityDecay = 1 - _3, simulation) : 1 - velocityDecay;
    },
    randomSource: function(_3) {
      return arguments.length ? (random = _3, forces.forEach(initializeForce), simulation) : random;
    },
    force: function(name, _3) {
      return arguments.length > 1 ? (_3 == null ? forces.delete(name) : forces.set(name, initializeForce(_3)), simulation) : forces.get(name);
    },
    find: function(x5, y4, radius) {
      var i2 = 0, n2 = nodes.length, dx, dy, d22, node2, closest;
      if (radius == null) radius = Infinity;
      else radius *= radius;
      for (i2 = 0; i2 < n2; ++i2) {
        node2 = nodes[i2];
        dx = x5 - node2.x;
        dy = y4 - node2.y;
        d22 = dx * dx + dy * dy;
        if (d22 < radius) closest = node2, radius = d22;
      }
      return closest;
    },
    on: function(name, _3) {
      return arguments.length > 1 ? (event.on(name, _3), simulation) : event.on(name);
    }
  };
}

// node_modules/d3-force/src/manyBody.js
function manyBody_default() {
  var nodes, node2, random, alpha, strength = constant_default5(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_3) {
    var i2, n2 = nodes.length, tree = quadtree(nodes, x4, y3).visitAfter(accumulate);
    for (alpha = _3, i2 = 0; i2 < n2; ++i2) node2 = nodes[i2], tree.visit(apply2);
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length, node3;
    strengths = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) node3 = nodes[i2], strengths[node3.index] = +strength(node3, i2, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q2, c3, weight = 0, x5, y4, i2;
    if (quad.length) {
      for (x5 = y4 = i2 = 0; i2 < 4; ++i2) {
        if ((q2 = quad[i2]) && (c3 = Math.abs(q2.value))) {
          strength2 += q2.value, weight += c3, x5 += c3 * q2.x, y4 += c3 * q2.y;
        }
      }
      quad.x = x5 / weight;
      quad.y = y4 / weight;
    } else {
      q2 = quad;
      q2.x = q2.data.x;
      q2.y = q2.data.y;
      do
        strength2 += strengths[q2.data.index];
      while (q2 = q2.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x1, _3, x22) {
    if (!quad.value) return true;
    var x5 = quad.x - node2.x, y4 = quad.y - node2.y, w2 = x22 - x1, l2 = x5 * x5 + y4 * y4;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
        if (y4 === 0) y4 = jiggle_default(random), l2 += y4 * y4;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
        node2.vx += x5 * quad.value * alpha / l2;
        node2.vy += y4 * quad.value * alpha / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2) return;
    if (quad.data !== node2 || quad.next) {
      if (x5 === 0) x5 = jiggle_default(random), l2 += x5 * x5;
      if (y4 === 0) y4 = jiggle_default(random), l2 += y4 * y4;
      if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node2) {
        w2 = strengths[quad.data.index] * alpha / l2;
        node2.vx += x5 * w2;
        node2.vy += y4 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : strength;
  };
  force.distanceMin = function(_3) {
    return arguments.length ? (distanceMin2 = _3 * _3, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_3) {
    return arguments.length ? (distanceMax2 = _3 * _3, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_3) {
    return arguments.length ? (theta2 = _3 * _3, force) : Math.sqrt(theta2);
  };
  return force;
}

// node_modules/d3-force/src/radial.js
function radial_default(radius, x5, y4) {
  var nodes, strength = constant_default5(0.1), strengths, radiuses;
  if (typeof radius !== "function") radius = constant_default5(+radius);
  if (x5 == null) x5 = 0;
  if (y4 == null) y4 = 0;
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length; i2 < n2; ++i2) {
      var node2 = nodes[i2], dx = node2.x - x5 || 1e-6, dy = node2.y - y4 || 1e-6, r2 = Math.sqrt(dx * dx + dy * dy), k3 = (radiuses[i2] - r2) * strengths[i2] * alpha / r2;
      node2.vx += dx * k3;
      node2.vy += dy * k3;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    radiuses = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      radiuses[i2] = +radius(nodes[i2], i2, nodes);
      strengths[i2] = isNaN(radiuses[i2]) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_3) {
    nodes = _3, initialize();
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : strength;
  };
  force.radius = function(_3) {
    return arguments.length ? (radius = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : radius;
  };
  force.x = function(_3) {
    return arguments.length ? (x5 = +_3, force) : x5;
  };
  force.y = function(_3) {
    return arguments.length ? (y4 = +_3, force) : y4;
  };
  return force;
}

// node_modules/d3-force/src/x.js
function x_default2(x5) {
  var strength = constant_default5(0.1), nodes, strengths, xz;
  if (typeof x5 !== "function") x5 = constant_default5(x5 == null ? 0 : +x5);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node2; i2 < n2; ++i2) {
      node2 = nodes[i2], node2.vx += (xz[i2] - node2.x) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    xz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(xz[i2] = +x5(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_3) {
    nodes = _3;
    initialize();
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : strength;
  };
  force.x = function(_3) {
    return arguments.length ? (x5 = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : x5;
  };
  return force;
}

// node_modules/d3-force/src/y.js
function y_default2(y4) {
  var strength = constant_default5(0.1), nodes, strengths, yz;
  if (typeof y4 !== "function") y4 = constant_default5(y4 == null ? 0 : +y4);
  function force(alpha) {
    for (var i2 = 0, n2 = nodes.length, node2; i2 < n2; ++i2) {
      node2 = nodes[i2], node2.vy += (yz[i2] - node2.y) * strengths[i2] * alpha;
    }
  }
  function initialize() {
    if (!nodes) return;
    var i2, n2 = nodes.length;
    strengths = new Array(n2);
    yz = new Array(n2);
    for (i2 = 0; i2 < n2; ++i2) {
      strengths[i2] = isNaN(yz[i2] = +y4(nodes[i2], i2, nodes)) ? 0 : +strength(nodes[i2], i2, nodes);
    }
  }
  force.initialize = function(_3) {
    nodes = _3;
    initialize();
  };
  force.strength = function(_3) {
    return arguments.length ? (strength = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : strength;
  };
  force.y = function(_3) {
    return arguments.length ? (y4 = typeof _3 === "function" ? _3 : constant_default5(+_3), initialize(), force) : y4;
  };
  return force;
}

// node_modules/d3-zoom/src/transform.js
function Transform(k3, x5, y4) {
  this.k = k3;
  this.x = x5;
  this.y = y4;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k3) {
    return k3 === 1 ? this : new Transform(this.k * k3, this.x, this.y);
  },
  translate: function(x5, y4) {
    return x5 === 0 & y4 === 0 ? this : new Transform(this.k, this.x + this.k * x5, this.y + this.k * y4);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x5) {
    return x5 * this.k + this.x;
  },
  applyY: function(y4) {
    return y4 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x5) {
    return (x5 - this.x) / this.k;
  },
  invertY: function(y4) {
    return (y4 - this.y) / this.k;
  },
  rescaleX: function(x5) {
    return x5.copy().domain(x5.range().map(this.invertX, this).map(x5.invert, x5));
  },
  rescaleY: function(y4) {
    return y4.copy().domain(y4.range().map(this.invertY, this).map(y4.invert, y4));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity3 = new Transform(1, 0, 0);
transform2.prototype = Transform.prototype;
function transform2(node2) {
  while (!node2.__zoom) if (!(node2 = node2.parentNode)) return identity3;
  return node2.__zoom;
}

// src/lasso.js
function polygonToPath(polygon) {
  return `M${polygon.map((d3) => d3.join(",")).join("L")}`;
}
function distance(pt1, pt2) {
  return Math.sqrt((pt2[0] - pt1[0]) ** 2 + (pt2[1] - pt1[1]) ** 2);
}
function lasso() {
  const d3_dispatch = dispatch_default2("start", "end");
  let closeDistance = 75;
  function lasso2(root3) {
    const g2 = root3.append("g").attr("class", "lasso-group");
    const bbox = root3.node().getBoundingClientRect();
    const area = g2.append("rect").attr("width", bbox.width).attr("height", bbox.height).attr("fill", "tomato").attr("opacity", 0);
    const d3_drag = drag_default().on("start", handleDragStart).on("drag", handleDrag).on("end", handleDragEnd);
    area.call(d3_drag);
    let lassoPolygon;
    let lassoPath;
    let closePath;
    function handleDragStart() {
      lassoPolygon = [pointer_default(this)];
      if (lassoPath) {
        lassoPath.remove();
      }
      lassoPath = g2.append("path").attr("fill", "#ababab").attr("fill-opacity", 0.1).attr("stroke", "#999999").attr("stroke-dasharray", "3, 3");
      closePath = g2.append("line").attr("x2", lassoPolygon[0][0]).attr("y2", lassoPolygon[0][1]).attr("stroke", "#999999").attr("stroke-dasharray", "3, 3").attr("opacity", 0);
      d3_dispatch.call("start", lasso2, lassoPolygon);
    }
    function handleDrag() {
      const point = pointer_default(this);
      lassoPolygon.push(point);
      lassoPath.attr("d", polygonToPath(lassoPolygon));
      if (distance(lassoPolygon[0], lassoPolygon[lassoPolygon.length - 1]) < closeDistance) {
        closePath.attr("x1", point[0]).attr("y1", point[1]).attr("opacity", 1);
      } else {
        closePath.attr("opacity", 0);
      }
    }
    function handleDragEnd() {
      closePath.remove();
      closePath = null;
      if (distance(lassoPolygon[0], lassoPolygon[lassoPolygon.length - 1]) < closeDistance) {
        lassoPath.attr("d", polygonToPath(lassoPolygon) + "Z");
        d3_dispatch.call("end", lasso2, lassoPolygon);
      } else {
        lassoPath.remove();
        lassoPath = null;
        lassoPolygon = null;
      }
    }
    lasso2.reset = () => {
      if (lassoPath) {
        lassoPath.remove();
        lassoPath = null;
      }
      lassoPolygon = null;
      if (closePath) {
        closePath.remove();
        closePath = null;
      }
    };
  }
  lasso2.on = (type2, callback) => {
    d3_dispatch.on(type2, callback);
    return lasso2;
  };
  return lasso2;
}

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root2 = freeGlobal_default || freeSelf || Function("return this")();
var root_default2 = root2;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default2.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/identity.js
function identity4(value) {
  return value;
}
var identity_default2 = identity4;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default2["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid3 = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid3 ? "Symbol(src)_1." + uid3 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default2, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/lodash-es/noop.js
function noop2() {
}
var noop_default = noop2;

// node_modules/lodash-es/_copyArray.js
function copyArray(source2, array2) {
  var index2 = -1, length = source2.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source2[index2];
  }
  return array2;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default7 = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default2 : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default7(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return index2;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array2, value, fromIndex) {
  var index2 = fromIndex - 1, length = array2.length;
  while (++index2 < length) {
    if (array2[index2] === value) {
      return index2;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array2, value, fromIndex) {
  return value === value ? strictIndexOf_default(array2, value, fromIndex) : baseFindIndex_default(array2, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && baseIndexOf_default(array2, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type2 = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source2, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start2, transform4) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform4(array2);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start2) {
  return setToString_default(overRest_default(func, start2, identity_default2), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index2, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike_default(object) && isIndex_default(index2, object.length) : type2 == "string" && index2 in object) {
    return eq_default(object[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources2) {
    var index2 = -1, length = sources2.length, customizer = length > 1 ? sources2[length - 1] : void 0, guard = length > 2 ? sources2[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources2[0], sources2[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source2 = sources2[index2];
      if (source2) {
        assigner(object, source2, index2, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer3 = moduleExports ? root_default2.Buffer : void 0;
var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e3) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform4) {
  return function(arg) {
    return func(transform4(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty9.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_default(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default2, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map3, key) {
  var data = map3.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number3, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path2) {
  path2 = castPath_default(path2, object);
  var index2 = 0, length = path2.length;
  while (object != null && index2 < length) {
    object = object[toKey_default(path2[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get3(object, path2, defaultValue2) {
  var result = object == null ? void 0 : baseGet_default(object, path2);
  return result === void 0 ? defaultValue2 : result;
}
var get_default = get3;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values2) {
  var index2 = -1, length = values2.length, offset = array2.length;
  while (++index2 < length) {
    array2[offset + index2] = values2[index2];
  }
  return array2;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index2 = -1, length = array2.length;
  predicate || (predicate = isFlattenable_default);
  result || (result = []);
  while (++index2 < length) {
    var value = array2[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush_default(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array2, start2, end) {
  var index2 = -1, length = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start2];
  }
  return result;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer4 = moduleExports3 ? root_default2.Buffer : void 0;
var allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default2, "DataView");
var DataView_default = DataView2;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default2, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default2, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default2.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array2 = arguments[0], index2 = length;
  while (index2--) {
    args[index2 - 1] = arguments[index2];
  }
  return arrayPush_default(isArray_default(array2) ? copyArray_default(array2) : [array2], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index2 = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length) {
    this.add(values2[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag3:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag2:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag2:
    case dateTag2:
    case numberTag2:
      return eq_default(+object, +other);
    case errorTag2:
      return object.name == other.name && object.message == other.message;
    case regexpTag2:
    case stringTag2:
      return object == other + "";
    case mapTag3:
      var convert = mapToArray_default;
    case setTag3:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag2:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty11.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag4 = "[object Object]";
var objectProto15 = Object.prototype;
var hasOwnProperty12 = objectProto15.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object), othTag = othIsArr ? arrayTag2 : getTag_default(other);
  objTag = objTag == argsTag3 ? objectTag4 : objTag;
  othTag = othTag == argsTag3 ? objectTag4 : othTag;
  var objIsObj = objTag == objectTag4, othIsObj = othTag == objectTag4, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty12.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty12.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source2, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source2, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result = keys_default(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source2) {
  var matchData = getMatchData_default(source2);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source2 || baseIsMatch_default(object, source2, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path2, hasFunc) {
  path2 = castPath_default(path2, object);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key = toKey_default(path2[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path2) {
  return object != null && hasPath_default(object, path2, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path2, srcValue) {
  if (isKey_default(path2) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path2), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path2) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path2) {
  return function(object) {
    return baseGet_default(object, path2);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path2) {
  return isKey_default(path2) ? baseProperty_default(toKey_default(path2)) : basePropertyDeep_default(path2);
}
var property_default2 = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default2;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default2(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source2, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source2, srcIndex, customizer, stack) {
  if (object === source2) {
    return;
  }
  baseFor_default(source2, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source2, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source2, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array2, value, comparator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (comparator(value, array2[index2])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array2, values2, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, isCommon = true, length = array2.length, result = [], valuesLength = values2.length;
  if (!length) {
    return result;
  }
  if (iteratee) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index2 < length) {
      var value = array2[index2], computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/last.js
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array2, values2) {
  var iteratee = last_default(values2);
  if (isArrayLikeObject_default(iteratee)) {
    iteratee = void 0;
  }
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array2, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array2) ? baseDifference_default(array2, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default2;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result = [];
  baseEach_default(collection, function(value, index2, collection2) {
    if (predicate(value, index2, collection2)) {
      result.push(value);
    }
  });
  return result;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter2(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default3 = filter2;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map2(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default = map2;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee) {
  return baseFlatten_default(map_default(collection, iteratee), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee) {
  return object && baseForOwn_default(object, castFunction_default(iteratee));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/isString.js
var stringTag3 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag3;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax2 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax2(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin = Math.min;
function baseIntersection(arrays, iteratee, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
  while (othIndex--) {
    var array2 = arrays[othIndex];
    if (othIndex && iteratee) {
      array2 = arrayMap_default(array2, baseUnary_default(iteratee));
    }
    maxLength = nativeMin(array2.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || length >= 120 && array2.length >= 120) ? new SetCache_default(othIndex && array2) : void 0;
  }
  array2 = arrays[0];
  var index2 = -1, seen = caches[0];
  outer:
    while (++index2 < length && result.length < maxLength) {
      var value = array2[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_parent.js
function parent(object, path2) {
  return path2.length < 2 ? object : baseGet_default(object, baseSlice_default(path2, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/isEmpty.js
var mapTag4 = "[object Map]";
var setTag4 = "[object Set]";
var objectProto16 = Object.prototype;
var hasOwnProperty13 = objectProto16.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag4 || tag == setTag4) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty13.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source2, srcIndex) {
  baseMerge_default(object, source2, srcIndex);
});
var merge_default3 = merge;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path2) {
  path2 = castPath_default(path2, object);
  object = parent_default(object, path2);
  return object == null || delete object[toKey_default(last_default(path2))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array2, value, fromIndex, comparator) {
  var index2 = fromIndex - 1, length = array2.length;
  while (++index2 < length) {
    if (comparator(array2[index2], value)) {
      return index2;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto2 = Array.prototype;
var splice2 = arrayProto2.splice;
function basePullAll(array2, values2, iteratee, comparator) {
  var indexOf = comparator ? baseIndexOfWith_default : baseIndexOf_default, index2 = -1, length = values2.length, seen = array2;
  if (array2 === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee) {
    seen = arrayMap_default(array2, baseUnary_default(iteratee));
  }
  while (++index2 < length) {
    var fromIndex = 0, value = values2[index2], computed = iteratee ? iteratee(value) : value;
    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array2) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array2, fromIndex, 1);
    }
  }
  return array2;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array2, values2, iteratee) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2, baseIteratee_default(iteratee, 2)) : array2;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array2, values2, comparator) {
  return array2 && array2.length && values2 && values2.length ? basePullAll_default(array2, values2, void 0, comparator) : array2;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto3 = Array.prototype;
var splice3 = arrayProto3.splice;
function basePullAt(array2, indexes) {
  var length = array2 ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index2 = indexes[length];
    if (length == lastIndex || index2 !== previous) {
      var previous = index2;
      if (isIndex_default(index2)) {
        splice3.call(array2, index2, 1);
      } else {
        baseUnset_default(array2, index2);
      }
    }
  }
  return array2;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/remove.js
function remove2(array2, predicate) {
  var result = [];
  if (!(array2 && array2.length)) {
    return result;
  }
  var index2 = -1, indexes = [], length = array2.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result.push(value);
      indexes.push(index2);
    }
  }
  basePullAt_default(array2, indexes);
  return result;
}
var remove_default4 = remove2;

// node_modules/lodash-es/transform.js
function transform3(object, iteratee, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee = baseIteratee_default(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index2, object2) {
    return iteratee(accumulator, value, index2, object2);
  });
  return accumulator;
}
var transform_default = transform3;

// node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array2, iteratee, comparator) {
  var index2 = -1, includes2 = arrayIncludes_default, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set3 = iteratee ? null : createSet_default(array2);
    if (set3) {
      return setToArray_default(set3);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value = array2[index2], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee = last_default(arrays);
  if (isArrayLikeObject_default(iteratee)) {
    iteratee = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// src/pixinet.js
init_eventemitter3();
var combinations = (n2, k3) => {
  const result = [];
  const combos = [];
  const recurse = (start2) => {
    if (combos.length + (n2 - start2 + 1) < k3) {
      return;
    }
    recurse(start2 + 1);
    combos.push(start2);
    if (combos.length === k3) {
      result.push(combos.slice());
    } else if (combos.length + (n2 - start2 + 2) >= k3) {
      recurse(start2 + 1);
    }
    combos.pop();
  };
  recurse(1, combos);
  return result;
};
var range = (arr, accessor) => {
  return [minBy(arr, accessor), maxBy(arr, accessor)];
};
var identity5 = (val) => {
  return val;
};
var compose = (...fns) => fns.reduce((f2, g2) => (...args) => f2(g2(...args)));
var make_scale = (w2, h2) => {
  const scale_x = linear2().domain([0, 1]).range([0, w2]);
  const scale_y = linear2().domain([0, 1]).range([0, h2]);
  const scale_xy = (xy) => {
    return [scale_x(xy[0]), scale_y(xy[1])];
  };
  const invert_scale_xy = (xy) => {
    return [scale_x.invert(xy[0]), scale_x.invert(xy[1])];
  };
  return { scale: scale_xy, invert: invert_scale_xy };
};
var node_style = {
  lineStyle: { size: 1.5, color: 16777215 },
  color: 6621786,
  radius: 6,
  alpha: 1
};
var line_style = { lineWidth: 1, color: 0, alpha: 1 };
var polygon_style = {
  lineStyle: { size: 1.5, color: 16777215 },
  color: 6621786,
  alpha: 0.2
};
var default_link_params = {
  distance: 30,
  iterations: 1,
  id: function(d3) {
    return d3.id;
  }
};
var default_manybody_params = { strength: function() {
  return -30;
}, distanceMin: 1, distanceMax: Infinity };
var default_center_params = { x: 0, y: 0 };
var default_sim_params = {
  alpha: 1,
  force: {
    // < name > : { enabled: < boolean >, type: < force type >, params: { < force parameters > } }
    charge: { enabled: true, type: "forceManyBody", params: default_manybody_params },
    link: { enabled: true, type: "forceLink", params: default_link_params },
    center: { enabled: true, type: "forceCenter", params: default_center_params }
  }
};
var current_ns = (node2) => {
  let gd = node2.graphicsData[0];
  let c_ns = {
    lineStyle: { size: gd.lineWidth, color: gd.lineColor },
    color: gd.fillColor,
    radius: gd.shape.radius,
    alpha: gd.fillAlpha
  };
  c_ns.lineStyle = clean(c_ns.lineStyle);
  if (isEmpty_default(c_ns.lineStyle)) {
    delete c_ns.lineStyle;
  }
  return clean(c_ns);
};
var default_ns = (node2) => {
  let c_ns = current_ns(node2);
  let res = node_style;
  if ("alpha" in c_ns) {
    res.alpha = c_ns.alpha;
  }
  if ("color" in c_ns) {
    res.color = c_ns.color;
  }
  if ("radius" in c_ns) {
    res.radius = c_ns.radius;
  }
  if (!isEmpty_default(c_ns.lineStyle) && "size" in c_ns.lineStyle) {
    res.lineStyle.size = c_ns.lineStyle.size;
  }
  if (!isEmpty_default(c_ns.lineStyle) && "color" in c_ns.lineStyle) {
    res.lineStyle.color = c_ns.lineStyle.color;
  }
  return res;
};
var clean = (obj) => {
  Object.keys(obj).forEach((key) => obj[key] == null && delete obj[key]);
  return obj;
};
var apply_sim = (sim, params) => {
  forOwn_default(params, function(value, key) {
    if (key != "force") {
      console.log(key.toString() + " = " + value.toString());
      sim[key](value);
    }
  });
  return sim;
};
var apply_force = (sim, params) => {
  forOwn_default(params, function(settings, forcename) {
    if (settings.enabled) {
      sim.force(forcename, src_exports[settings.type]());
      forOwn_default(settings.params, function(param_value, param_name) {
        console.log(forcename.toString() + ": " + param_name.toString() + " = " + param_value.toString());
        sim.force(forcename)[param_name](param_value);
      });
    }
  });
  return sim;
};
var scale_nodes = (nodes, w2, h2) => {
  let scale_f = make_scale(w2, h2);
  nodes.forEach((node2) => {
    if (!("x" in node2)) {
      node2.x = Math.random();
    }
    if (!("y" in node2)) {
      node2.y = Math.random();
    }
    let xy = scale_f.scale([node2.x, node2.y]);
    node2.x = xy[0];
    node2.y = xy[1];
  });
  return nodes;
};
var ticker = (app, stage) => {
  let dispatcher = dispatch_default2("tick", "animate", "stop", "restart");
  let end_loop = false;
  function animate() {
    if (!end_loop) {
      requestAnimationFrame(animate);
    }
    app.renderer.render(stage);
    dispatcher.call("tick", this);
  }
  dispatcher.on("animate", animate);
  dispatcher.on("stop", function() {
    end_loop = true;
    console.log("ticker stopped");
  });
  dispatcher.on("restart", function() {
    end_loop = false;
    dispatcher.call("animate");
  });
  return dispatcher;
};
var clear_stage = (stage) => {
  for (var i2 = stage.children.length - 1; i2 >= 0; i2--) {
    stage.removeChild(stage.children[i2]);
  }
  ;
};
var create_viewport = (app, sw, sh, ww = sw, wh = sh) => {
  var viewport = new et({
    screenWidth: sw,
    screenHeight: sh,
    worldWidth: ww,
    worldHeight: wh,
    events: app.renderer.events
    // this changed; app must be initialized
  });
  return viewport;
};
var generate_node_graphics = (nodes) => {
  return map_default(nodes, (node2) => {
    return Object.assign(draw_node(new Graphics()), node2);
  });
};
var generate_links_graphic = () => {
  return new Graphics();
};
var generate_polygon_graphics = (polygons) => {
  return _.map(polygons, (polygon) => {
    polygon.gfx = new Graphics();
    return polygon;
  });
};
var draw_node = (node2, ns = node_style) => {
  node2.clear();
  node2.circle(0, 0, ns.radius).stroke({ width: ns.lineStyle.size, color: ns.lineStyle.color }).fill({ color: ns.color, alpha: ns.alpha });
  return node2;
};
var draw_nodes = (nodes, ns = node_style) => {
  if (ns.constructor === Array && ns.length == nodes.length) {
    nodes.forEach((node2, i2) => {
      draw_node(node2, merge_default3(default_ns(node2), ns[i2]));
    });
  } else if (ns.constructor == Object) {
    let ns_new = merge_default3(default_ns(node), ns);
    nodes.forEach((node2) => {
      draw_node(node2, ns_new);
    });
  }
};
var draw_link = (link, link_gfx, ls = line_style) => {
  const { source: source2, target } = link;
  link_gfx.moveTo(source2.x, source2.y).lineTo(target.x, target.y).stroke({ width: ls.lineWidth, color: ls.color });
  return link;
};
var draw_links = (links, link_gfx, ls = line_style) => {
  if (ls.constructor === Array && ls.length == links.length) {
    links.forEach((link, i2) => {
      draw_link(link, link_gfx, merge_default3(line_style, ls[i2]));
    });
  } else if (ls.constructor == Object) {
    let new_ls = merge_default3(line_style, ls);
    link_gfx.clear();
    links.forEach((link) => {
      draw_link(link, link_gfx, new_ls);
    });
  }
};
var _draw_polygon = (polygon, poly_gfx) => {
  if (polygon.nodes) {
    polygon.points = flatMap_default(polygon.nodes, (node2) => {
      return [node2.x, node2.y];
    });
  }
  poly_gfx.drawPolygon(polygon);
};
var draw_polygon = (polygon, poly_gfx, ps = polygon_style) => {
  poly_gfx.clear();
  poly_gfx.beginFill(ps.color);
  _draw_polygon(polygon, poly_gfx);
  poly_gfx.endFill();
};
var draw_polygons = (polygons, ps = polygon_style) => {
  if (ps.constructor === Array && ps.length == polygons.length) {
    polygons.forEach((poly, i2) => {
      draw_polygon(poly, poly.gfx, Object.assign(polygon_style, ps[i2]));
    });
  } else if (ps.constructor == Object) {
    polygons.forEach((poly) => {
      draw_polygon(poly, poly.gfx, ps);
    });
  }
};
var register_tick_stops = (tick_dispatcher, vp, predicate = function() {
  return true;
}) => {
  vp.on("clicked", () => tick_dispatcher.call("restart"));
  vp.on("drag-start", () => tick_dispatcher.call("restart"));
  vp.on("pinch-start", () => tick_dispatcher.call("restart"));
  vp.on("moved", () => tick_dispatcher.call("restart"));
  vp.on("zoomed", () => tick_dispatcher.call("restart"));
  vp.on("moved-end", () => {
    if (predicate()) {
      tick_dispatcher.call("stop");
    }
  });
};
var enable_interactive = (arr, acc = identity5) => {
  arr.forEach((item) => {
    acc(item).interactive = true;
  });
};
var disable_interactive = (arr, acc = identity5) => {
  arr.forEach((item) => {
    acc(item).interactive = false;
  });
};
var drag_dispatcher = (node2) => {
  let dsp = dispatch_default2("start", "end", "dragging");
  node2.on("pointerdown", function(e3) {
    dsp.call("start", node2, e3);
  });
  node2.on("pointerup", function(e3) {
    dsp.call("end", node2, e3);
  });
  node2.on("pointermove", function(e3) {
    if (this.dragging) {
      console.log("Dragging");
      let coords = this.data.getLocalPosition(this.parent);
      dsp.call("dragging", node2, e3, coords);
    }
  });
  return dsp;
};
var pixi_drag = (pixi_obj) => {
  if (!pixi_obj.interactive) {
    pixi_obj.interactive = true;
  }
  return function(dispatcher) {
    dispatcher.on("start.pixi", function(e3) {
      if (this.parent.pausePlugin) {
        this.parent.pausePlugin("drag");
      }
      ;
      Object.assign(this, { data: e3.data, alpha: 0.8, dragging: true });
    }).on("end.pixi", function(e3) {
      if (this.parent.resumePlugin) {
        this.parent.resumePlugin("drag");
      }
      Object.assign(this, { data: null, alpha: 1, dragging: false });
    }).on("dragging.pixi", function(e3, coords) {
      this.x = coords.x, this.y = coords.y;
    });
    return dispatcher;
  };
};
var force_drag = (sim) => {
  return function(dispatcher) {
    dispatcher.on("start.force", function(e3) {
      sim.alphaTarget(0.3).restart();
      this.fx = this.x;
      this.fy = this.y;
    }).on("dragging.force", function(e3, coords) {
      this.fx = coords.x;
      this.fy = coords.y;
    }).on("end.force", function(e3) {
      if (!this.dragging) {
        sim.alphaTarget(0);
      }
      this.fx = null;
      this.fy = null;
    });
    return dispatcher;
  };
};
var stage_items = (stage, arr, acc = identity5) => {
  arr.forEach((item) => {
    stage.addChild(acc(item));
  });
};
var insert_nodes = (nodes, new_nodes) => {
  let ins_nodes = generate_node_graphics(differenceBy_default(new_nodes, nodes, "id"));
  return concat_default(nodes, ins_nodes);
};
var remove_nodes = (node_ids, nodes, links, stage) => {
  remove_default4(links, (link) => {
    return includes_default(node_ids, link.source.id) || includes_default(node_ids, link.target.id);
  });
  let removed_nodes = remove_default4(nodes, (node2) => {
    return includes_default(node_ids, node2.id);
  });
  removed_nodes.forEach((node2) => {
    stage.removeChild(node2);
  });
};
var update_node_coords = (nodes) => {
  let i2, n2 = nodes.length;
  for (i2 = 0; i2 < n2; ++i2) {
    nodes[i2].gfx.x = nodes[i2].x;
    nodes[i2].gfx.y = nodes[i2].y;
  }
};
var make_group = (nodes) => {
  let container = new Container();
  nodes.forEach((node2) => {
    container.addChild(node2);
  });
  return container;
};
var enable_force = () => {
  return simulation_default();
};
var set_dpi = (canvas, dpi) => {
  canvas.style.width = canvas.style.width || canvas.width + "px";
  canvas.style.height = canvas.style.height || canvas.height + "px";
  var scaleFactor = dpi / 96;
  var width = parseFloat(canvas.style.width);
  var height = parseFloat(canvas.style.height);
  var oldScale = canvas.width / width;
  var backupScale = scaleFactor / oldScale;
  var backup = canvas.cloneNode(false);
  backup.getContext("2d").drawImage(canvas, 0, 0);
  var ctx = canvas.getContext("2d");
  canvas.width = Math.ceil(width * scaleFactor);
  canvas.height = Math.ceil(height * scaleFactor);
  ctx.setTransform(backupScale, 0, 0, backupScale, 0, 0);
  ctx.drawImage(backup, 0, 0);
  ctx.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0);
};
function default_force_settings(sim, app, nodes, links) {
  if (arguments.length < 4) {
    return default_sim_params;
  } else {
    const parent2 = app.canvas.parentNode;
    const width = parent2.clientWidth, height = parent2.clientHeight;
    let center = [width / 2, height / 2];
    sim.nodes(nodes);
    apply_sim(sim, default_sim_params);
    apply_force(sim, default_sim_params.force);
    sim.force("center").x(center[0]).y(center[1]);
    sim.force("link").links(links);
  }
}
var enable_resize = (app, vp = null) => {
  app.renderer.autoResize = true;
  const parent2 = app.canvas.parentNode;
  const _resize = (w2 = parent2.clientWidth, h2 = parent2.clientHeight) => {
    console.log("calling resize");
  };
  return _resize;
};
var resolve_links = (nodes, links) => {
  links.forEach((link) => {
    if (!(link.source instanceof Graphics)) {
      link.source = nodes.find((node2) => {
        return node2.id == link.source;
      });
    }
    if (!(link.target instanceof Graphics)) {
      link.target = nodes.find((node2) => {
        return node2.id == link.target;
      });
    }
  });
};
var enable_lasso = (visRootID) => {
  let dispatcher = dispatch_default2("start", "selected");
  const visRoot = select_default2("#" + visRootID);
  var interaction_svg = visRoot.append("svg").attr("id", "selection_svg").attr("width", visRoot.style("width")).attr("height", visRoot.style("height")).style("position", "absolute").style("top", 0).style("left", 0).style("display", "none");
  var lassoInstance = lasso();
  let local_nodes = null;
  lassoInstance.on("end", function(lassoPolygon) {
    interaction_svg.style("display", "none");
    console.log(local_nodes);
    const selected_nodes = local_nodes.filter((node2) => {
      let xy = [node2.x, node2.y];
      return contains_default(lassoPolygon, xy);
    });
    local_nodes = null;
    dispatcher.call("selected", this, selected_nodes);
  });
  dispatcher.on("start", function(nodes) {
    local_nodes = nodes;
    interaction_svg.style("display", "inline");
    lassoInstance(interaction_svg);
  });
  return dispatcher;
};
var enable_drag_container = (container) => {
  container.interactive = true;
  container.visible = true;
  container.hitArea = container.getBounds();
  return container;
};
var group_items = (items, acc = identity5) => {
  let group = new Container();
  items.forEach((item) => {
    group.addChild(acc(item));
  });
  return group;
};
export {
  Application,
  Graphics,
  Polygon,
  Text,
  _draw_polygon,
  apply_force,
  apply_sim,
  clean,
  clear_stage,
  combinations,
  compose,
  concat_default as concat,
  create_viewport,
  current_ns,
  default_force_settings,
  default_ns,
  differenceBy_default as differenceBy,
  differenceWith_default as differenceWith,
  disable_interactive,
  drag_dispatcher,
  draw_link,
  draw_links,
  draw_node,
  draw_nodes,
  draw_polygon,
  draw_polygons,
  enable_drag_container,
  enable_force,
  enable_interactive,
  enable_lasso,
  enable_resize,
  filter_default3 as filter,
  flatMap_default as flatMap,
  forOwn_default as forOwn,
  force_drag,
  generate_links_graphic,
  generate_node_graphics,
  generate_polygon_graphics,
  group_items,
  identity5 as identity,
  includes_default as includes,
  insert_nodes,
  intersectionWith_default as intersectionWith,
  isEmpty_default as isEmpty,
  make_group,
  make_scale,
  map_default as map,
  merge_default3 as merge,
  pixi_drag,
  pullAllBy_default as pullAllBy,
  pullAllWith_default as pullAllWith,
  range,
  register_tick_stops,
  remove_default4 as remove,
  remove_nodes,
  resolve_links,
  scale_nodes,
  select_default2 as select,
  set_dpi,
  stage_items,
  ticker,
  transform_default as transform,
  unionBy_default as unionBy,
  unionWith_default as unionWith,
  update_node_coords
};
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
